#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## cast is the spell installation utility
## It can be called by the user or by sorcery
##
##=head1 DESCRIPTION
##
## ...
##
##=head1 COPYRIGHT
##
## Original version Copyright 2001 by Kyle Sallee
## Some parts copyright 2002 Anders Bruun Olsen et al
## Other additions/corrections Copyright 2002 by the Source Mage Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#---------------------------------------------------------------------


help()	{

  cat  <<  EOF

Cast installs single or multiple spells

Example:	cast  nano hdparm sudo
Usage:		cast  [parameters]  [spell]

Optional Parameters:

-q  |  --quiet			Do not be verbose, show less info
-t  |  --dot                    Display progress as dots, not percent

-f  |  --fix			Discover and fix broken spells
-n  |  --nofix			Discover, but do not fix broken spells

-d  |  --download		Force download of sources (overwrite existing files)

-s				Download 1st, cast 2nd
    |  --deps			Configure spells and determine dependencies, 
				but do not cast.

-c  |  --compile		Ignore $INSTALL_CACHE and compiles
-r  |  --reconfigure		Select new dependencies for spells

       --from	directory	Specify an alternate for $SOURCE_CACHE
       --url	URL		Specify an alternate download URL

       --pam			Re-casts all installed spells that
				can use Linux-PAM
       
       --queue                  Casts all spells listed in $INSTALL_QUEUE

EOF

  exit  1

}


set_failed_cast() {
  if [[ $FAILED_CASTS ]] ; then
    FAILED_CASTS="$FAILED_CASTS $SPELL"
  else
    FAILED_CASTS="$SPELL"
  fi
}

set_successful_cast() {
  if [[ $SUCCESSFUL_CASTS ]] ; then
    SUCCESSFUL_CASTS="$SUCCESSFUL_CASTS $SPELL"
  else
    SUCCESSFUL_CASTS="$SPELL"
  fi
}

run_conflicts() {

    debug "cast" "Starting run_conflicts() on $SPELL"
    if    [  -x  $SCRIPT_DIRECTORY/CONFLICTS  ]
    then       . $SCRIPT_DIRECTORY/CONFLICTS
    fi

}


# checks for a security file
# returns 0 if spell should be cast, 1 otherwise
run_security() {
    debug "cast" "Starting run_security() on $SPELL"
    if    [  -f  $SCRIPT_DIRECTORY/SECURITY  ]; then
      echo -e "${SPELL_COLOR}${SPELL}:${DEFAULT_COLOR}"
      tee -a $SECURITY_LOG < $SCRIPT_DIRECTORY/SECURITY
        if [ `grep critical $SCRIPT_DIRECTORY/SECURITY` ]; then
          if query "${RED}SECURITY CRITICAL:${QUERY_COLOR} Do you still want to cast ${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}?" "n"; then
            return 0 
          fi
          return 1
        else
          if query "SECURITY: Do you still want to cast ${SPELL_COLOR} $SPELL ${QUERY_COLOR}?" "y"; then
            return 0 
          fi
          return 1
        fi
    fi
    return 0
}


prepare_spell_config()  {

  SPELL_CONFIG=$DEPENDS_CONFIG/$SPELL
  if  !  [  -x  $SPELL_CONFIG  ];  then
    touch       $SPELL_CONFIG
    chmod  a+x  $SPELL_CONFIG
  fi

  . $SPELL_CONFIG

}


use_xinetd()  { (

  if  [  -d  $SCRIPT_DIRECTORY/xinetd.d  ]  &&
      !  grep  -q  "SERVICES="  $SPELL_CONFIG
  then

    ALL_SERVICES=`cat  $SCRIPT_DIRECTORY/xinetd.d/*  |
                  grep  "service"                    |
                  sed   "s/service //"`

    for  SERVICE  in  $ALL_SERVICES;  do
      if    query  "Invoke $SERVICE via xinetd?"  y
      then  SERVICES="$SERVICE $SERVICES"
      fi
    done

    for  SERVICE  in  $SERVICES;  do
      for  FILE  in  `ls  $SCRIPT_DIRECTORY/xinetd.d/*`;  do

         if  grep  -q   "service $SERVICE"  $FILE   &&
             grep  -q   "stunnel"           $FILE;  then
           add_depends  "$SPELL"  "stunnel"  "on"  "optional"
         fi

      done
    done

    if    [  -n  "$SERVICES"  ]
    then  add_depends  "$SPELL"  "xinetd"  "on"   "optional"
    else  add_depends  "$SPELL"  "xinetd"  "off"  "optional"
    fi

    echo  "SERVICES=\"$SERVICES\""  >>  $SPELL_CONFIG

  fi

) }

# Automagic initscript installation.
use_initd()  { (

  debug "cast" "In use_initd()"

  if  [  -d  $SCRIPT_DIRECTORY/init.d  ]  &&
      !  grep  -q  "INITSCRIPTS="  $SPELL_CONFIG
  then
    debug "cast" "use_initd: found an init.d directory - processing"

    ALL_INITSCRIPTS=`ls  $SCRIPT_DIRECTORY/init.d/*.sh  |
                     sed   's#.*/##'                    |
                     sed   "s#\..*##"`
    debug "cast" "use_initd: ALL_INITSCRIPTS: '$ALL_INITSCRIPTS'"

    for  INITSCRIPT  in  $ALL_INITSCRIPTS;  do
      if    query  "Invoke $INITSCRIPT at boot via init?"  y
      then  INITSCRIPTS="$INITSCRIPT $INITSCRIPTS"
      fi
    done

    debug "cast" "saving initscripts"
    echo  "INITSCRIPTS=\"$INITSCRIPTS\""  >>  $SPELL_CONFIG

  fi

) }


run_pre_build() {

  debug "cast" "run_pre_build()"
  message  "${MESSAGE_COLOR}Building"  \
           "${SPELL_COLOR}${SPELL}"    \
           "${DEFAULT_COLOR}"

  cd  $BUILD_DIRECTORY

  verify_sources && 
  if  [  -x  $SCRIPT_DIRECTORY/PRE_BUILD  ];  then
    debug "cast" "run_pre_build() - Prebuild script exists, now sourcing "
    . $SCRIPT_DIRECTORY/PRE_BUILD
  else
    debug "cast" "run_pre_build() - Prebuild script not found, using default"
    default_pre_build
  fi
}


rack()  {

  message  "${MESSAGE_COLOR}Creating"                        \
           "${FILE_COLOR}$COMPILE_LOGS/$SPELL-$VERSION.bz2"  \
           "${DEFAULT_COLOR}"

  bzip2  -9f  <  $C_LOG  >  $COMPILE_LOGS/$SPELL-$VERSION.bz2
  rm             $C_LOG
  rm             $C_FIFO

}


view_compile_log()  {

    sleep   1
    report              $C_LOG  "Compile log"

}


activate_voyeur()  {

  if  [  -z  "$SILENT"  ];  then
    case  $VOYEUR  in
      on)  tee  -a  $C_LOG  <  $C_FIFO              &  ;;
       *)  tee  -a  $C_LOG  <  $C_FIFO  >/dev/null  &  ;;
    esac
  else     tee  -a  $C_LOG  <  $C_FIFO  >/dev/null  &
  fi

}


run_build()  {

  debug "cast" "Starting run_build()"
   C_LOG=/tmp/$SPELL.compile.log
  C_FIFO=/tmp/$SPELL.compile.fifo

  rm  -f $C_FIFO
  mkfifo  $C_FIFO
  rm  -f $C_LOG
  echo  "Compile log for $SPELL  $VERSION  Built on `date  -u`"  >  $C_LOG
  echo  "Using gcc version: `gcc -dumpversion`" >> $C_LOG

  activate_voyeur

  [  -d  "$SOURCE_DIRECTORY"  ]  &&
  cd      $SOURCE_DIRECTORY

  invoke_build_dir
  invoke_gcc2
  optimize
  invoke_installwatch

  message -n "Installing in dir: "
  pwd
  message "$SPELL    $VERSION"
  if  [ -x ./configure ] || [ -x ./src/configure ] ; then
    if  [[  $CONFIG_LOC  == on  ]]; then
      if  [  !  -d  $SM_CONFIG_OPTION_CACHE  ] ; then
        mkdir --parents --mode=0755 $SM_CONFIG_OPTION_CACHE
      fi
      if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ] ; then
        message "${MESSAGE_COLOR}These are your current -- config options for spell ${SPELL_COLOR}$SPELL"
        message "${FILE_COLOR}($SM_CONFIG_OPTION_CACHE/$SPELL)"
        cat $SM_CONFIG_OPTION_CACHE/$SPELL | column
      fi
      if    query  "Do you wish to add -- options to ./configure?"  n ;  then
        edit_file $SM_CONFIG_OPTION_CACHE/$SPELL
        if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ];  then
          OPTS="$OPTS `cat $SM_CONFIG_OPTION_CACHE/$SPELL`"
          message "${MESSAGE_COLOR} OPTS= ${SPELL_COLOR}$OPTS"
        fi
      fi
    fi
  fi

  if  [  -x  $SCRIPT_DIRECTORY/BUILD  ];  then
          .  $SCRIPT_DIRECTORY/BUILD
  else
    default_build
  fi

  if  [  "$?"  ==  0  ];  then
    rack
  else
    sound  FAILURE
    message  "${PROBLEM_COLOR}"      \
             "! Problem Detected !"  \
             "${DEFAULT_COLOR}"
    view_compile_log
    rack
    false
  fi

}


run_post_build() {

  if  [  -x  $SCRIPT_DIRECTORY/POST_BUILD  ];  then
           . $SCRIPT_DIRECTORY/POST_BUILD
  else
    default_post_build
  fi

}


run_post_install() {

  if    [  -x  $SCRIPT_DIRECTORY/POST_INSTALL  ]
  then       . $SCRIPT_DIRECTORY/POST_INSTALL
  fi

  if    [  -x  $SCRIPT_DIRECTORY/TRIGGERS  ]
  then       . $SCRIPT_DIRECTORY/TRIGGERS
  fi

}


lib_dirs()  {

  for  DIRECTORY  in  $*;  do
    for FILE in $DIRECTORY/*.so* ; do
      if file -b "$FILE" | grep  -q  "shared object" ; then
        echo -n "$DIRECTORY:"
	break
      fi
    done
  done

}


export_ld()  {

  if    [  -z  "$LD_LIBRARY_PATH"  ] ; 
  then  export   LD_LIBRARY_PATH="$( lib_dirs  $*  )"
  else  export   LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$(  lib_dirs  $*  )"
  fi
  
  export LD_LIBRARY_PATH=`cat /etc/ld.so.conf | tr '[:blank:][:cntrl:]' ':'`$LD_LIBRARY_PATH


}


ldd_check()  {  (

  if  [  "$LDD_CHECK"  ==  "off"    ] ;  then
    return
  fi

     SPELL=$1
     VERSION=`installed_version  $SPELL`
       I_LOG=$INSTALL_LOGS/$SPELL-$VERSION
  LDD_STATUS=0

  if  [  -e  $I_LOG  ];  then

    LOG=`cat   $I_LOG                               |
         grep      "/bin/\|/games/\|/lib/\|/sbin/"  |
         grep  -v  "/doc/\|/fonts/\|/include/\|/locale/\|/man/\|/modules/\|/var/"`
    
    let size=0
    for FILE in $LOG ; do
    	let size++
    done

    let count=0
    for  FILE  in  $LOG;  do

      if  [  -z  "$QUIET"  ];  then
        progress_bar $DOT_PROGRESS $count $size 50
      fi
      let count++

      if     [  -f  "$FILE"  ]     &&
          !  [  -h  "$FILE"  ]     &&
          file  -b  "$FILE"        |
          grep  -q  "ELF"          &&
          ldd       "$FILE"  2>&1  |
          grep  -q  "not found"
      then
        (
	   clear_line
           message  "${FILE_COLOR}${FILE}"       \
                    "${DEFAULT_COLOR}of"         \
                    "${SPELL_COLOR}${SPELL}"     \
                    "${PROBLEM_COLOR}is broken."  \
                    "${DEFAULT_COLOR}"
           ldd      "$FILE" 2>&1 | grep  "not found"
        )
        LDD_STATUS=1
      fi
    done
	clear_line
  fi
  return  $LDD_STATUS

) }


find_check()  { (

  if  [  "$FIND_CHECK"  ==  "off"             ]   ||
      [  "$1"           ==  "xfree86"         ]   ||
      [  "$1"           ==  "xfree86-custom"  ];  then
    return
  fi

        SPELL=$1
      VERSION=`installed_version  $SPELL`
        I_LOG=$INSTALL_LOGS/$SPELL-$VERSION
  FIND_STATUS=0

  if  [  -e  $I_LOG  ];  then

    LOG=`cat   $I_LOG                                          |
         grep      "/bin/\|/games/\|/include/\|/lib/\|/sbin/"  |
         grep  -v  "/doc/\|/etc/\|/fonts/\|/man/\|/var/"`

    let size=0
    for FILE in $LOG ; do
    	let size++
    done

    let count=0
    for  ITEM  in  $LOG;  do

      if  [  -z  "$QUIET"  ];  then
        progress_bar $DOT_PROGRESS $count $size 50
      fi
      let count++
      
      
      if  [  -e  "$ITEM"  ];  then
        true
      else
        (
	   clear_line
           message  "${FILE_COLOR}${ITEM}"       \
                    "${DEFAULT_COLOR}of"           \
                    "${SPELL_COLOR}${SPELL}"       \
                    "${PROBLEM_COLOR}is missing."  \
                    "${DEFAULT_COLOR}"
        )
        FIND_STATUS=1
      fi
    done
	clear_line
  else
    (
       message  "${SPELL_COLOR}${SPELL} "                     \
                "${PROBLEM_COLOR}is missing an install log."  \
                "${DEFAULT_COLOR}"
    )
    FIND_STATUS=1
  fi
  return  $FIND_STATUS

) }


show_owner()  {

  OWNER=`grep  $TARGET  $INSTALL_LOGS/*  |
         cut  -d :  -f1                  |
         sed  -n  1p`

  if  [  -n  "$OWNER"  ];  then  echo  "`basename  $OWNER`"
                           else  echo  "nobody"
  fi

}


remove_line()  {

  F_TMP=/tmp/`basename  $I_LOG`.$$.$RANDOM

  cp         $I_LOG  $F_TMP
  grep  -v   $ITEM   $F_TMP  >  $I_LOG
  rm    -rf          $F_TMP

  message  "Symbolic link: ${SYMLINK_COLOR}${ITEM}${DEFAULT_COLOR}"  \
           "is owned by ${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}"

  message  "Target of symbolic link is ${FILE_COLOR}${TARGET}${DEFAULT_COLOR}"

  message  "${FILE_COLOR}${TARGET}${DEFAULT_COLOR} is owned by `show_owner`"

  message  "Removed: ${SYMLINK_COLOR}${ITEM}${DEFAULT_COLOR} from ${I_LOG}"

}


sym_check()  { (

  if  [  "$SYM_CHECK"  ==  "off"  ];  then
    return
  fi

      SPELL=$1
      VERSION=`installed_version  $SPELL`
        I_LOG=$INSTALL_LOGS/$SPELL-$VERSION

  if  [  -e  $I_LOG  ];  then

    LOG=`cat   $I_LOG`

    let size=0
    for FILE in $LOG ; do
    	let size++
    done

    let count=0
    for  ITEM  in  $LOG;  do

      if  [  -z  "$QUIET"  ];  then
        progress_bar $DOT_PROGRESS $count $size 50 
      fi
      let count++
      
      if  [  -h  "$ITEM"  ]  &&
          [  -f  "$ITEM"  ]
      then

      TARGET=$(  basename  $(  ls   -la  "$ITEM"  |
                               cut  -d  '>'  -f2  |
                               cut  -c  2-
                            )
              )

        if  !  grep  -q  "$TARGET"  $I_LOG
        then  (  remove_line  )
        fi

      fi
    done
	clear_line
  fi

) }


md5sum_check()  { (

  if  [  "$MD5SUM_CHECK"  ==  "off"  ];  then
    return
  fi

  SPELL=$1
  VERSION=`installed_version  $SPELL`
  MD5_LOG="$MD5SUM_LOGS/$SPELL-$VERSION"

  MD5SUM_STATUS=0

  if  [  -e  $MD5_LOG  ];  then

    OUTPUT=`cat  $MD5_LOG                                         |
            grep      "/bin/\|/games/\|/include/\|/lib/\|/sbin/"  |
            grep  -v  "/doc/\|/etc/\|/fonts/\|/man/\|/var/"       |
            md5sum  --check  2>/dev/null                          |    
            grep   -v       ": OK"                                |
            cut    -d :  -f1`

    if  [  -n  "$OUTPUT"  ];  then
    
      let size=0
      for FILE in $LOG ; do
      	let size++
      done

      let count=0
      for  FILE  in  $OUTPUT;  do

        if  [  -z  "$QUIET"  ];  then
          progress_bar $DOT_PROGRESS $count $size 50 
        fi
        let count++
      
        if     [  -f  "$FILE"  ]  &&
            !  [  -h  "$FILE"  ]  &&
            file  -b  "$FILE"     |
            grep  -q  "ELF"
        then
          MD5SUM=`md5sum  $FILE`
          if  !  grep  -q  "$MD5SUM"  $MD5SUM_LOGS/*;  then
            (
	       clear_line
               message  "${FILE_COLOR}${FILE}"               \
                        "${DEFAULT_COLOR}of"                 \
                        "${SPELL_COLOR}${SPELL}"             \
                        "${PROBLEM_COLOR}has wrong md5sum."  \
                        "${DEFAULT_COLOR}"
            )
            MD5SUM_STATUS=1
          fi
        fi
      done
	  clear_line
    fi
  else
    (
       message  "${SPELL_COLOR}${SPELL} "                   \
                "${PROBLEM_COLOR}is missing a md5sum log."  \
                "${DEFAULT_COLOR}"
    )
    MD5SUM_STATUS=1
  fi
  return  $MD5SUM_STATUS

) }


status_okay()  {

  spell_installed  $1  ||
  spell_held       $1

}


run_checks()  {

  if  [ -z  "$QUIET"  ]; then
    progress_bar $DOT_PROGRESS 1 1 50 
  fi

  #Note: check to see if these should all be joined by &&
     sym_check  $1
    find_check  $1  &&
     ldd_check  $1  &&
  md5sum_check  $1

}


run_fix()  { (

  SPELLS=$*

  if  [  -z  "$QUIET"  ];  then
    if  [  -z  "$PASS_ZERO"  ]  &&  [  -z  "$CAST_PASS"  ];  then
      message  "${CHECK_COLOR}Initiating integrity check, please wait..."  \
               "${DEFAULT_COLOR}"
    fi
  fi

  if  [  -z  "$SPELLS"  ];  then


    # Why are these special cases? (duff, 09/29)
    # Because we want to always check them first?
    if    spell_installed  xfree86
    then  SPELLS="glibc xfree86"
    else  SPELLS="glibc"
    fi

    #was $SPELL_STATUS_BACKUP (2002/09/29)
    SPELLS="$SPELLS $(  awk -F : '{print $1; }' $SPELL_STATUS |
                        grep  -v  'glibc|xfree86|sorcery|j2sdk'   )"
  fi

  if  [  -z  "$QUIET"  ];  then
    progress_bar $DOT_PROGRESS 1 5 50 
  fi

  PASSED=":"

  if    [  "$LDD_CHECK"  ==  "on"    ]
  then  LD_LIBRARY_PATH_OLD="$LD_LIBRARY_PATH"
        if  [  -z  "$QUIET"  ];  then
         progress_bar $DOT_PROGRESS 2 5 50 
          wait_flag_up
          wait_flag  $$  &
        fi
        export_ld  $(  find  /usr/lib  -type  d  ! -empty  )
        if  [  -z  "$QUIET"  ];  then
          wait_flag_down
        fi
  fi

  until  [  "$FIXED"     ==  "yes"  ]   ||
         [  "$HOPELESS"  ==  "yes"  ];  do

       FIXED="yes"
    HOPELESS="no"

    if  [  -z  "$QUIET"  ];  then
      progress_bar $DOT_PROGRESS 3 5 50 
    fi

    for  SPELL  in  $SPELLS;  do

      if  [  -z  "$QUIET"  ];  then
        progress_bar $DOT_PROGRESS 4 5 50 
      fi

      if  status_okay  $SPELL  &&
          !  echo  $PASSED     |
             grep  -q  ":`esc_str $SPELL`:";  then

        if  [  -z  "$QUIET"  ];  then
          progress_bar $DOT_PROGRESS 5 5 50 
		  clear_line 
          message    "${CHECK_COLOR}Checking integrity of"  \
                     "${SPELL_COLOR}${SPELL}"               \
                     "${DEFAULT_COLOR}"
        else
          message  "${CHECK_COLOR}Checking integrity of"  \
                   "${SPELL_COLOR}${SPELL}"               \
                   "${DEFAULT_COLOR}"
        fi

        if    run_checks     $SPELL  ||
              [  -n  "$NOFIX"  ]
        then
          PASSED="$PASSED$SPELL:"
        else

          FIXED="no"
          (  run_details
             satisfy_depends
             unset  FIX
             satisfy_depends
          )

          if  [  "$LDD_CHECK"  ==  "on"    ] ;  then
            export  LD_LIBRARY_PATH="$LD_LIBRARY_PATH_OLD"
            export_ld  $(  find  /usr/lib  -type  d  ! -empty  )
          fi

          if    run_checks     $SPELL  ||
                [  -n  "$NOFIX"  ]
          then

            PASSED="$PASSED$SPELL:"
            if  [  "$LDD_CHECK"  ==  "on"    ] ;  then
              export  LD_LIBRARY_PATH="$LD_LIBRARY_PATH_OLD"
              export_ld  $(  find  /usr/lib  -type  d  ! -empty  )
            fi

          else
            unset  FIX
            if    !  cast  --compile  $SPELL;  then  HOPELESS="yes"
            elif  !  run_checks       $SPELL;  then  HOPELESS="yes"
            fi
            export  FIX="--fix"
          fi
        fi
      fi
    done
  done
  rm  -f  /tmp/LD_LIBRARY_PATH_FILE

) }


process_parameters()  {

  while  [  -n  "$1"  ];  do

    if  echo  "" $1  |  grep  -q  "^ -";  then

      case  $1  in

          -q|--quiet)  QUIET="yes"                ;      shift 1  ;;
	    -t|--dot)  export DOT_PROGRESS='-dot' ;      shift 1  ;;
              --deps)  export  DEPS_ONLY="$1";           shift 1  ;;
    -r|--reconfigure)  RECONFIGURE="$1";                 shift 1  ;;
        -c|--compile)  COMPILE="$1";                     shift 1  ;;
       -d|--download)  export  FORCE_DOWNLOAD="$1";      shift 1  ;;
              --from)  export  SOURCE_CACHE=$2;          shift 2  ;;
            --silent)  SILENT="$1";                      shift 1  ;;
            -f|--fix)  export  FIX="$1";                 shift 1  ;;
          -n|--nofix)  export  FIX="--fix"
                       export  NOFIX="$1";               shift 1  ;;
                  -s)  SEPARATE="$1";                    shift 1  ;;
               --url)  export  BASE_URL="$2";            shift 2  ;;
               --pam)  cast  -c  `find_pam_aware` ;      shift 1  ;;
             --queue)  if [ -z $QUIET ]; then
                         list_install_queue
                       fi
                         
                       if  [  -s $INSTALL_QUEUE  ]; then
                         message -n "${MESSAGE_COLOR}Casting install queue..."
                         message    "${DEFAULT_COLOR}"
                         cast -c `cat $INSTALL_QUEUE`
                         rm $INSTALL_QUEUE
                       fi;                               shift 1  ;;
                   *)  help                                   ;;
      esac

    else

      shift
 
   fi

  done

}


strip_parameters()  {

  while  [  -n  "$1"  ];  do

    if  echo  "" $1  |  grep  -q  "^ -";  then

      case  $1  in

                  --deps)  shift 1  ;;
	        -d|--dot)  shift 1  ;;
        -r|--reconfigure)  shift 1  ;;
                  --from)  shift 2  ;;
                --silent)  shift 1  ;;
                -f|--fix)  shift 1  ;;
              -n|--nofix)  shift 1  ;;
            -c|--compile)  shift 1  ;;
                      -s)  shift 1  ;;
                   --url)  shift 2  ;;
                   --pam)  shift 1  ;;
		 --queue)  shift 1  ;;
                       *)  shift 1  ;;

      esac

    else

      echo  $1
      shift
 
   fi

  done

}


resurrect()  {  (  

  debug "cast" "resurect - $*"

  run_prepare   &&
  run_details  

  STATUS=installed

  if  spell_held  $SPELL;  then
    VERSION=`installed_version  $SPELL`
     STATUS=held
    dispel  $SPELL
  fi

  CACHE_BZ="$INSTALL_CACHE/$SPELL-$VERSION-$BUILD.tar.bz2"

  if  [      -f   $CACHE_BZ  ]  &&
      bzip2  -tf  $CACHE_BZ    
  then
    
    run_conflicts    &&
    satisfy_depends  &&
    bzip2         -cd   $CACHE_BZ  |  tar  -Pkx  1>/dev/null  2>&1
    run_post_install #bug 199
    
    add_spell     "$SPELL"  "$STATUS"  "$VERSION"
    activity_log  "cast"  "$SPELL"  "$VERSION"  "success"
    set_successful_cast  "$SPELL"
    clear_line
    message  "${RESURRECT_COLOR}Resurrected spell:"  \
             "${SPELL_COLOR}${SPELL}"                \
             "${DEFAULT_COLOR}"                      \
             "version"                               \
             "${VERSION_COLOR}${VERSION}"            \
             "${DEFAULT_COLOR}"
    cast  --fix  $SILENT  $SPELL && echo $SPELL >> $SUCCESS_LIST
  else
    false
  fi

)  }


show_download_progress()  {

  if  [  -f  "$D_LOG"   ]   &&
      [  -z  "$SILENT"  ];  then

    LC_OLD=${LC_OLD:-0}

    LC=`cat  $D_LOG  2>/dev/null  |  wc  -l  |  tr  -d ' '`

    if  [  "$LC"  !=  "$LC_OLD"  ];  then
      ((  LC_OLD++  ))
      sed  -n ${LC_OLD},${LC}p  $D_LOG
      LC_OLD=$LC
    fi

  fi

}


show_downloading()  {

#  COMPILE="y"
  debug "cast" "Started show_downloading() on $SPELL"
  while ! ( [[ $D_LOG ]] && 
            [  -f "$D_LOG"  ] ) 
  do
    sleep 1
  done

  #The file is created in run_summon
  until [  -f "${D_LOG}.done.$SPELL"  ] ;  do
    show_download_progress
    sleep 1
  done
  
  rm "${D_LOG}.done.$SPELL"
  show_download_progress

}


report_install()  {

#  rm  -f  $BOOST_LOCK
  INST_LOG=$INSTALL_LOGS/$SPELL-$VERSION
  report  $INST_LOG  "Install log"

}




cast_spell()  { (

  debug "cast" "Casting spell [$SPELL]"
  run_details                                 &&
  run_security                                &&
  run_conflicts                               &&
  run_spell_config                            &&
  debug "DB" "cast_spell run_conflicts done"  &&
#  satisfy_depends             &&  #Not needed since make dakes care of deps now?
  debug "DB" "cast_spell about to show_d/l" &&
  show_downloading            ||   return 1
  
  # Some checks must be made at this poit to see if it's safe to start building
  message -n "Waiting for any ${FILE_COLOR}Solo${DEFAULT_COLOR} spells to complete..."
  lock_resources "castSOLO" "SOLO"
  message " done."
    
  message -n "Waiting for any other casts of ${SPELL_COLOR}$SPELL${DEFAULT_COLOR} to complete..."
  lock_resources "cast" "$SPELL"
  message " done"
    
  # Release the SOLO lock if you don't need to be cast solo
  if ! grep -q "^$SPELL$" $SOLO ; then 
    unlock_resources "castSOLO" "SOLO"
  fi
                               
  run_pre_build               &&
  run_build                   &&
  run_post_build              &&
  run_post_install            &&
  add_spell $SPELL installed $VERSION &&
  cd  /                       &&
  report_install              &&
  sound  SUCCESS
  if [ $? -eq 0 ] ; then
    activity_log  "cast"  "$SPELL"  "$VERSION"  "success"
    rm_source_dir
	echo $SPELL >> $SUCCESS_LIST
  else
    activity_log "cast" "$SPELL"  "$VERSION" "failure"
    rm  -f  $CASTING
    if [[  $CLEAN_SOURCE == on ]]; then
      rm_source_dir
    fi
    CAST_EXIT_STATUS=1
  fi

  unlock_resources "cast" "$SPELL"
  #It's OK to try to release a lock you don't have
  unlock_resources "castSOLO" "SOLO"

  return ${CAST_EXIT_STATUS:-0}

) }

##Removed *_solo functions, Duff 2002/11/01

current_sources()  {

  spell_installed  $SPELL  &&
  [  "$VERSION"  ==  "`installed_version  $SPELL`"  ]

}


run_summon()  {
  
  if 	[[ $COMPILE ]] 			|| 
  		[[ $FORCE_COMPILE ]] 	|| 
		! current_sources 		|| 
		! (spell_installed $SPELL || spell_held $SPELL) 
  then
    lock_file   $D_LOG
    
    ( . summon  $SPELL  >>  $D_LOG  2>&1 )
    
    unlock_file $D_LOG
  fi
  
  #This is to notify show_downloading that it is done this source
  touch "${D_LOG}.done.$SPELL"

}

pass_one()  {
  #  This pass does configuration and dependency identification.
  debug "cast" "Starting pass_one()"

  local i j tempList SPELL_RULES=""
  local numRules=0

  compute_depends "SPELL_RULES" $SPELLS

  message "${MESSAGE_COLOR}Collating dependancies...${DEFAULT_COLOR}"
  echo "$SPELL_RULES" | depends_to_Makefile $numRules $SPELLS > $MAKEFILE

  if  [  -n  "$DEPS_ONLY"  ] ;  then  
   	for i in $SPELLS ; do
	  #BUG: $i=="foo" and "foobar" is also to be built it will remove foobar too"
	  sed -e 's/cast .* $i.*/true/' $MAKEFILE > $MAKEFILE.2
	  mv $MAKEFILE.2 $MAKEFILE
   	done  
  fi
  
  SPELLS=`sed -n 's/^\([^:]*\):.*$/\1/p' $MAKEFILE | grep -v "^all$"`

  debug "cast" "pass_one, done with SPELLS=$SPELLS"

}

function depends_to_Makefile()
{
	debug "cast" "depends_to_Makefile - $*"
	local spell all_spells=""
	local tmp_list i
	local LINE=""
	local args
	tmp_list=""
	
	[[ $COMPILE ]] && args="-c "

	while read LINE ; do

		[[ $LINE ]] || continue		#Remove blank lines
		spell=${LINE%%:*}
		all_spells="$all_spells $spell"
		echo "$LINE"
		echo -e "\t$0 $args $spell"
		echo
		
		for (( i=1 ; i <= $# ; i++ )) ; do
			[[ ${!i} == $spell ]] && tmp_list="$tmp_list $spell"
		done
		
	done
	
	echo "all: $tmp_list"
	echo
	
#	export SPELLS="$all_spells"
	
}


#A bit of a misnomer, eh? Doesn't build anything, just summons it.
build_sources()  {

  for  SPELL  in  $SPELLS;  do
    ( run_details                       &&
#      satisfy_depends  && (duff, probably not needed 10/07)
      run_summon
      debug "cast" "Out of run_summon."
    )
  done

}


function pass_two()  {
  #  This pass downloads required sources.
  #  And starts the make process
  debug "cast" "Starting pass_two()"

  message "${MESSAGE_COLOR}Spells are to be cast:${DEFAULT_COLOR}"
  message "---------------------------"
  message "${SPELL_COLOR}${*}" | tr '[:blank:]' '\n' | column 
  message "${DEFAULT_COLOR}"
  
  if ! query "Do you want to cast these spells?" "y" ; then
  	message "Ok, quiting cast. Figure out what you want."
	return 1
  fi
  
  #make: -k keep going even if there's an error, -s silent, -f <file>
  if  [[  $SEPARATE   ]] ; then
    ( CAST_PASS="three" ; /usr/bin/make -j1 -k -s -f $MAKEFILE all )
  else
    ( CAST_PASS="three" ; /usr/bin/make -j1 -k -s -f $MAKEFILE all ) &
  fi
  
  debug "cast" "Starting stage four make."
  
  ( CAST_PASS="four" ; /usr/bin/make  -j1 -k -s -f $MAKEFILE all )
  rm $MAKEFILE

}

pass_three()  {
  debug "cast" "pass_three - $*"
  SPELL=$1
  build_sources $*
}

pass_four()  {

  debug "cast" "pass_four - $*"
  SPELL=$1
  trigger "pre_cast"

  if ! [[ $COMPILE ]] && (spell_installed $SPELL ||spell_held $SPELL) ; then
    resurrect     $SPELL
  else
    cast_spell $*
  fi
  trigger "cast"
}


# Report generation
pass_five()  {

  local SOME_CAST_FAILED=""
  
  if [ -e $SUCCESS_LIST ] ; then

	  message "${MESSAGE_COLOR}Finished processing install requests."
	  message ""
	  message "Spells installed successfully:"
	  message "------------------------------${SPELL_COLOR}"
	  for item in `cat $SUCCESS_LIST`; do
    	message "$item"
	  done | column
  fi
  
  message "${DEFAULT_COLOR}"
  message "${MESSAGE_COLOR}Spells that encountered problems:"
  message "---------------------------------${PROBLEM_COLOR}"
  for item in $* ; do
    if ! ([ -e $SUCCESS_LIST ] && grep -q "^$item$" $SUCCESS_LIST) ; then
	  message "$item"
	  SOME_CAST_FAILED="1"
	fi
  done | column
  message "${DEFAULT_COLOR}"
  
  [[ $SOME_CAST_FAILED ]] || return 1

}

pass_zero()  {

  debug "cast" "Starting pass_zero()"
  PASS_ZERO="y"  #<--- What is this here for? (Duff, 03/02/13)
  export  D_LOG="/tmp/sorcery.downloading.$$.$RANDOM"
  rm -f $D_LOG 2>/dev/null

  export  CAST_PASS="one";    pass_one $*  &&
  export  CAST_PASS="two";    pass_two $SPELLS
#pass_three and _four are hidden inside the makefile
  export  CAST_PASS="five";  pass_five "$@"

  rm  -f   $D_LOG*
  

}


main()	{

  debug "cast" "main() - $*"
  process_parameters        $*
  SPELLS=`strip_parameters  $*`

  if  [[  $FIX  ]];  then

    run_fix  $SPELLS

  else

    codex_does_spell_exist $SPELLS || return 1
	
	MAKEFILE="/tmp/Makefile.cast.$$"
	SUCCESS_LIST="$0.success_list"
	export ENV_CACHE=${ENV_CACHE:-/tmp/cast.envCache.$$}
	export RM_AT_END="$RM_AT_END $SUCCESS_LIST $0 $ENV_CACHE"
	BASE_SPELLS=" $SPELLS "

    case  $CAST_PASS  in
        one)  pass_one    $SPELLS  ;; #Never matches
        two)  pass_two    $SPELLS  ;; #Never matches
	  three)  pass_three  $SPELLS  ;; #d/l sources, Never matches
	   four)  pass_four   $SPELLS  ;; #real casting, Never matches
	   five)  pass_five   $SPELLS  ;; #cast report
          *)  pass_zero   $SPELLS  ;; #start everything
    esac

  fi

  echo
  true

}


. /etc/sorcery/config

if    [  $#      ==  0  ];  then  help  |  $PAGER
elif  [  "$UID"  !=  0  ];  then

  echo  "Enter the root password, please."
  su  - -c  "DISPLAY=$DISPLAY PATH=$PATH  $0  $*"

elif  [  "$(  dirname  $0  )"  !=  "/tmp"  ];  then

  RM_AT_END=""
  SAFE_CAST=/tmp/casting.$$
  lock_file $SAFE_CAST
  
  cp  $0  $SAFE_CAST
  chmod +x $SAFE_CAST
  exec $SAFE_CAST "$@"
  
else

  renice +10 -p $$  >/dev/null
  main  $*
  if [ $SHLVL -lt 2 ] ; then
  	rm    $0
	unlock_file $SAFE_CAST
	rm $RM_AT_END
  fi

fi

debug "cast" "exiting..."

#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
