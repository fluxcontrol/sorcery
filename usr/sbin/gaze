#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## gaze - view sorcery spell management information
## (gaze into the crystal ball)
##
##=head1 DESCRIPTION
##
## ...
##
##=head1 COPYRIGHT
##
## First version of gaze written & copyrighted 2001 by Brian Peterson
## 
## Current version contains none of Brian Peterson's code and is 
## Copyright 2001 by Kyle Sallee
##
## Other additions/corrections Copyright 2002 by the Source Mage Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#---------------------------------------------------------------------


help() {
cat << EOF

Invoke gaze with desired command followed by arguments.
Please note that anything in brackets [] is optional.

Command		Arguments	Description

-q		<empty>		disable human style output

alien		<empty>		Discover untracked files.
from		path/file	Discover what installed a file.

search		"phrase"	Searches for "phrase" in the long and 
				  short spell descriptions and in the spell name.
search      -name  "phrase" Searches for "phrase" in the spell name.
search      -short "phrase" Searches for "phrase" in the short spell 
                            descriptions

service		port|acronym	Displays spells that provide that service.
provides	feature 	Displays spells that provide the feature.

what		spell		Print the spell's description.
short           spell           Print the spell's short description.
where		spell		Print the spell's section.
website | url	spell		Print the spell's website.
install		spell		View an install log.
installed	[spell]		View/query installed spells.
version		spell		View version of spell installed, and version in 
				the grimoire.
license		spell [spell]	View the license of the given spell(s)
license		section [section]	View the licenses of spells in the given
					section(s)
license		license [license]	View information about the given license(s).
compile		spell		View a compile log.
sources		spell		List the source files for a spell.
history		spell		Show history for a spell.

sum			[spell]		Prints checksums.
md5sum		[spell]		Prints md5sums.
export					Make snapshot of box's configuration.
import		snapshot	Restore snapshot.

section		[section]	List grimoire sections.
maintainer	[section]	See who is the maintainer for a section
grimoire	[grimoire]	View a text listing of all grimoires.
                        Or of the specified grimoire.
html	[-s]	[grimoire]	View a html listing of all grimoires.
                        Or of the specified grimoire.
                        Additionally displays links to the source files 
                        when -s is given.

newer		20020521	Show available spells newer than May 21, 2002.
older		20010521	Show spells installed before May 21, 2001.

prune		<empty>		Removes all old sources from $SOURCE_CACHE
				  and removes all old backups from 
				  $INSTALL_CACHE.

voyeur		[delay or spell]  
				Peek into spell compilation.

pam		<empty>		Display installed or held spells that are
				  Linux-PAM aware.


orphans		<empty>		Display installed spells that have no
				  explicit dependencies on them.

depends		spell [level]		Displays the spells that explicitly or
				    recursively depend on this spell, up to $level levels.
                    $level is kinda infinity if omitted.

dependencies    spell [level]     Displays the spells $spell explicitly or 
                        recursively depends on, up to $level levels.
                        $level is kinda infinity if omitted.

\$SPELL_SCRIPT	spell	will print the spell script for that spell.
EOF
}
#' Just ignore this... it's so my poor syntax hilighting works.'

export_snapshot()  {

  SOURCE_DIRECTORY=$BUILD_DIRECTORY/snapshot
  mk_source_dir          $SOURCE_DIRECTORY
  cp  -a  /etc           $SOURCE_DIRECTORY
  cp  -a  $CONFIG_CACHE  $SOURCE_DIRECTORY

  for  LINE  in  `cat  $SPELL_STATUS`;  do
    SPELL=`echo  $LINE  |  cut  -d  :  -f1`
     STATUS=`echo  $LINE  |  cut  -d  :  -f2`
    if  [  "$STATUS"  ==  "installed"  ];  then
      echo  $SPELL  >>  /usr/src/snapshot/install
    fi
  done

  SNAPSHOT="/root/snapshot-$HOSTNAME-`date  -u  +%Y%m%d`.tar.bz2"

  cd  $BUILD_DIRECTORY
  tar    -c  snapshot     |
  bzip2  -9  >  $SNAPSHOT
  rm_source_dir          $SOURCE_DIRECTORY
  echo  "$SNAPSHOT created."

}


import_snapshot()  {

          SNAPSHOT=$1
  SOURCE_DIRECTORY=$BUILD_DIRECTORY/snapshot

  if  [  -f  "$1"  ];  then

    cd  $BUILD_DIRECTORY
    mk_source_dir          $SOURCE_DIRECTORY

    bzcat $SNAPSHOT  |  tar  -x
    cd  $SOURCE_DIRECTORY

    for  LINE  in  `cat  install`;  do
      push_install_queue  $LINE
    done
    report  $INSTALL_QUEUE  "Install Queue"

    cp  -ai  local  /etc/sorcery
    cp  -ai  etc    /

    cd  /
    rm_source_dir  $SOURCE_DIRECTORY

  else

    message  "Unable to find snapshot  \"$SNAPSHOT\""
    false

  fi

}


checksum()      { for FILE in `cat $1 | files`; do sum -s  $FILE; done; }
md5sum_files()  { for FILE in `cat $1 | files`; do md5sum  $FILE; done; }


alien()  {

  message  "In a few minutes I will print files found on this disk"
  message  "that were not installed by sorcery.  This is not a"
  message  "security feature!  Files could still be lurking"
  message  "undetected on this box."

  rm    -f  /tmp/gaze.found
  rm    -f  /tmp/gaze.known

  message  "Discovering ambient files..."
  find  $TRACKED  |  files  |  filter  "$EXCLUDED"  |  sort  >/tmp/gaze.found
 
  message  "Discovering installed files..."
  cat  $INSTALL_LOGS/*  |  files  |  sort  >  /tmp/gaze.known

  diff  -B  -a  -d  /tmp/gaze.found  /tmp/gaze.known  |
  grep  -v  "^> "                                     |
  grep      "^< "                                     |
  cut  -c  3-                                         |
  filter  "$PROTECTED"

  rm  -f  /tmp/gaze.found
  rm  -f  /tmp/gaze.known

}


gaze_catalog()  {

  local grimoire

  if [[ $# -gt 0 ]]; then
        grimoire=$(codex_find_grimoire_by_name $1)
        if [[ $? != 0 ]]; then
            echo "No such grimoire $1"
            exit 1;
        fi  
  fi

  echo  "Sorcery Grimoire for `date  -u`"

  if [ $grimoire ]; then
        echo "Grimoire: " $(basename $grimoire)
  else
        echo "Grimoires: " $(codex_get_all_grimoires | get_basenames)
  fi

  ((  COUNT=0  ))

  for  SECTION  in  `codex_get_all_sections $grimoire`;  do
    echo 
    echo  "-------------------------------------------------"
    echo  "SECTION:  $(  basename  $SECTION  )"  
    echo  "-------------------------------------------------"
    for  spell  in  `codex_get_spells $SECTION`;  do
      codex_set_current_spell  $spell
      echo  $SPELL
      ((  COUNT++  ))
    done
  done

  echo
  echo  "Total spells:  $COUNT"

}


gaze_catalog_html()  {

  local grimoire COLS=4

  if [[ $1 == "-s" ]]; then
        shift;
        (( COLS++ ))
  fi
    
  if [[ $# -gt 0 ]]; then
        grimoire=$(codex_find_grimoire_by_name $1)
        if [[ $? != 0 ]]; then
            echo "No such grimoire $1"
            exit 1;
        fi
  fi

  echo  "<html><head><title>Sorcery Grimoires for `date  -u`</title></head>"
  echo  "<body background=\"media/blackmarble.jpg\">"

  echo  "<table  align=\"center\""
  echo  "        background=\"media/whitemarble.jpg\""
  echo  "        border=5>"

  echo  "<tr><th colspan=${COLS}><font color=green  size=+1>"
  echo  "Sorcery Grimoires<br>"
  echo  $(date -u) "<br>"

  if [ $grimoire ]; then
        echo  "Grimoire: " $(basename $grimoire)
  else
        echo  "Grimoires: " $(codex_get_all_grimoires | get_basenames)
  fi

  echo  "</font></th></tr>"

  echo  "<tr>"
  echo  "<th>Spell</th>"
  echo  "<th>Version</th>"
  echo  "<th>Updated</th>"
  echo  "<th>Website</th>"
  [[ $COLS -eq 5 ]] && echo "<th>Source</th>"
  echo  "</tr>"

  ((  COUNT=0  ))

  for  SECTION  in  `codex_get_all_sections $grimoire`;  do
    echo  "<tr><th colspan=${COLS}><font color="green">$( basename  $SECTION )</font></th></tr>"
    for  SPELL  in  `codex_get_spells  $SECTION`;  do
      (
        codex_set_current_spell  $SPELL

        echo  "<tr>"
        if  [  "$SPELL"  ==  "linux"  ]   ||
            [  "$SPELL"  ==  "glibc"  ];  then
            BOLD="<b>"
          UNBOLD="</b>"
        else
          unset    BOLD
          unset  UNBOLD
        fi
        if  [  ${#SPELL}  -gt  15  ];  then
          SPELL="<font size=-1>$SPELL</font>"
        fi
	if  [  -z  "$UPDATED"  ]  &&  [  "$ENTERED"  ];  then
	    UPDATED=$ENTERED
	fi
        echo  "<td>$BOLD $SPELL $UNBOLD</td>"
        echo  "<td><font size=-1>$BOLD $VERSION $UNBOLD</font></td>"
        echo  "<td><font size=-1>$UPDATED</font></td>"

        WEBSITE=$WEB_SITE
        if    [  ${#WEB_SITE}  -lt 20  ];  then
            SHRINK="<font size=-1>"
          UNSHRINK="</font>"
        elif  [  ${#WEB_SITE}  -lt 30  ];  then
            SHRINK="<font size=-2>"
          UNSHRINK="</font>"
        else
           WEBSITE="`echo  $WEB_SITE  |  cut  -c-30`..."
            SHRINK="<font size=-3>"
          UNSHRINK="</font>"
        fi

        if  [  "$WEB_SITE"  !=  "unknown"  ];  then
          echo  "<td> $SHRINK"
          echo  "<a href=\"$WEB_SITE\" target=\"_blank\">$WEBSITE</a>"
          echo  "$UNSHRINK </td>"
        else
          echo  "<td></td>"
        fi
        if [[ $COLS -eq 5 ]]; then
            echo "<td>"
            echo "<a href=\"$SOURCE_URL\">$(echo $SOURCE | cut -c-25)</a>"

	    i=2
	    ii=SOURCE${i}
	    while  [  -n "${!ii}"  ];  do
		    iii="${ii}_URL"
		    echo "<br><a href=\"${!iii}\">$(echo ${!ii} | cut -c-25)</a>"
		    i=$(($i+1))
		    ii=SOURCE${i}
	    done
            echo "</td>"
        fi
        echo  "</tr>"
      )
      ((  COUNT++  ))
    done
  done

  echo  "<tr><th colspan=${COLS}>Total spells:  $COUNT</th></tr>"
  echo  "</table></body></html>"
}


display()  {

  if  [  -f  "$1"  ];  then
    case  `file  -b  $1  |  cut -d ' ' -f1`  in
      ASCII)    cat  $1  |  $PAGER  ;;
      bzip2)  bzcat  $1  |  $PAGER  ;;
    esac
  else
    message  "$2"
    false
  fi

}


newer()  {

  DATE=$1
  if  [  -n  "$DATE"  ];  then
    for  SPELL  in  `codex_get_all_spells`;  do
      codex_set_current_spell  $SPELL
      if  [  "$ENTERED"  ]  &&  [  $ENTERED  -gt  $DATE  ];  then
        echo  $SPELL
      fi
    done
  else
    help  |  $PAGER
  fi

}


older()  {

  DATE=$1

  if  [  -n  "$DATE"  ];  then
    for  LINE  in `cat  $SPELL_STATUS`;  do
      CAST_DATE=`echo  $LINE  |  cut  -d  :  -f2`
      if  [  $CAST_DATE  -gt  $DATE  ]  2>/dev/null;  then
        true
      else
        echo  $LINE  |  cut  -d  :  -f1
      fi
    done
  else
    help  |  $PAGER
  fi

}



show_from()  {

  cd  $INSTALL_LOGS
  grep  "`esc_str $1`$"  *

}


show_spell_component()  {

  local        COMPONENT=$1
  local       SPELL_NAME=$2
  local  SPELL_DIRECTORY=`codex_find_spell_by_name  $SPELL_NAME`
  if  [  -x  $SPELL_DIRECTORY/$COMPONENT  ];  then
    cat      $SPELL_DIRECTORY/$COMPONENT
  fi

}


#-----------------------------------------------------------------------
#
# gaze_search 
#
# parameter processing for the search routines.
# the case statement should be self-explanatory 
#
#-----------------------------------------------------------------------

gaze_search() {
    case $1 in

     -name) shift; real_name_search  "$@"  ;;
    -short) shift; real_short_search "$@"  ;;
         *)        real_long_search  "$@"  ;;

    esac
}


#-----------------------------------------------------------------------
#
# real_name_search pattern(s) 
#
# searches for pattern(s) in the name of all spells.
# it searches in the codex.index files for the sake of speed 
#
#-----------------------------------------------------------------------

real_name_search() {
    local grimoire pattern

    for grimoire in $(codex_get_all_grimoires); do
        for pattern in "$@"; do
            gawk ' BEGIN {
                        OFS=""
                        IGNORECASE=1
                        quiet = "'$GAZE_VERBOSE'"
                    }
                    /^[^[:blank:]]*'"$pattern"'/ {
                        if (quiet) {
                            print $1
                        }
                        else {
                            print "'"$pattern"' -> ", $1 
                        }
                    }
                ' "$grimoire/$SPELL_INDEX_FILE"
        done
    done
}


#-----------------------------------------------------------------------
#
# grep_find_grimoire path filename pattern
#
# path should be a grimoire, since it only searches files in a specific
# depth
# filename is the filename it searches for in path
# pattern is the pattern it searches for in the files
#
# returns the full path to the matching files
# eg /var/lib/sorcery/codex/grimoire/games/coal/DETAILS
#
#-----------------------------------------------------------------------

grep_find_grimoire() {
        local path=$1
        local name=$2
        local pattern="$3"

        grep -il -- "${pattern}" $( codex_find_in_grimoire "$path" "$name" )
}


#-----------------------------------------------------------------------
#
# real_short_search pattern(s) 
#
# searches for pattern(s) in the SHORT field of every SPELL in every 
# grimoire
#
#-----------------------------------------------------------------------

real_short_search() {
    local pattern grimoire spell spellname

    for pattern in "$@"; do
        for grimoire in $(codex_get_all_grimoires); do
            for spell in $(
    grep_find_grimoire $grimoire "DETAILS" "SHORT=.*${pattern}"
                        ); do

                spellname=$(basename $(dirname $spell))
                if [[ $GAZE_VERBOSE == 0 ]]; then
                    echo $spellname
                else
                    echo "$pattern -> $spellname" 
                fi

            done
        done
    done
}



real_long_search()  {

  local numSpells=`codex_get_all_spells|wc -l`
  local atSpell=0
  local file

  if ! [[ $GAZE_VERBOSE == 0 ]] ; then
	echo  "Searching...   "
  fi

  let j=0	
  for  SPELL_DIRECTORY  in  `codex_get_all_spells`;  do

    if ! [[ $GAZE_VERBOSE == 0 ]] ; then
     progress_bar $((atSpell++)) "$numSpells" 40
    fi

#	SPELL=`basename $SPELL_DIRECTORY`
	file="$SPELL_DIRECTORY/DETAILS"
	
    for pattern in "$@"; do
		grep -iq -- "$pattern" $file || continue
		SEARCH_RESULTS[$j]=$(gawk 'BEGIN{ORS = ""; IGNORECASE=1; inLongDesc=0}
			/'"${pattern}"'/{
				if(/^[[:blank:]]*SPELL/)	{print "(Name Match)";			exit 0;}
				if(/^[[:blank:]]*SHORT/)	{print "(Short Description)";	exit 0;}
				if(inLongDesc)	{print "(Description)";			exit 0;}
			}
			/cat[[:blank:]]*<<[[:blank:]]*EOF/{inLongDesc = 1;}
			/^EOF$/{inLongDesc=0;} ' $file)
    	
		if [[ ${SEARCH_RESULTS[$j]} ]]; then 
			SEARCH_RESULTS[$j]="$pattern ->  $(basename $SPELL_DIRECTORY) ${SEARCH_RESULTS[$j]}"
			if [[ $GAZE_VERBOSE == 0 ]]; then
				basename $SPELL_DIRECTORY
			else
				clear_line
				echo ${SEARCH_RESULTS[$j]}
			fi
			let j++
    	fi
    
    done  
  
  done

if ! [ "$GAZE_VERBOSE" == "0" ]; then
	clear_line
fi

#This dumps the array at the end of the search
#redundant at the moment. Left for future use -rha
#  let dump_count=0
#  while [ $dump_count -lt $j ]; do
#   echo "${SEARCH_RESULTS[$dump_count]}"
#   let dump_count++
#  done
unset SEARCH_RESULTS

}


service()  {
	
  for  SPELL  in  `codex_get_all_spells`;  do
    if    [  -f  $SPELL/services  ]  &&
	  grep  -q  -i  "$1"  $SPELL/services
    then  echo  "$( basename  $SPELL )"
    fi
  done
  
}


#---------------------------------------------------------------------
##=item gaze_provides <feature>
##
## Given a feature, shows a list of spells that provide the feature
## or functionality.  For example:
##
##    % gaze provides alsa-drivers
##    alsa-driver
##    linux-devel
##    linux-dj
##
## This output indicates that alsa-driver, linux-devel, and linux-dj
## all provide the alsa-drivers feature.
##
#---------------------------------------------------------------------
gaze_provides()  {

local spell

  for feature in "$@"; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${feature}:${DEFAULT_COLOR}"
        spell=$(find_providers "$feature")
        if [[ "$spell" ]]; then
                echo "$spell"
        else
                echo "no providers found"
        fi
  done
}


find_casting()  {

  for  FILE in `cat /tmp/locklist | grep :cast: 2>/dev/null`;  do
    if  ps  `echo $FILE | cut -d':' -f3`  |  grep  -q  cast;  then
      echo  $FILE  |  cut -d':' -f1
      return  0
    fi
  done
  false

}


peek_casting()  {

  if  [  -f   /tmp/locklist ]                                                &&
      ps  `cat  /tmp/locklist | grep "$1"':cast' | cut -d':' -f3 2>/dev/null`  |
      grep  -q  cast                                                         &&
      [  -f  /tmp/$1.compile.log  ]
  then
    nice  -n  +20                  \
    tail  -f  /tmp/$1.compile.log  \
          --follow=name            \
          --pid=`cat  /tmp/locklist | grep "$1"':cast' | cut -d':' -f3 2>/dev/null`  2>/dev/null
  fi

}


activate_voyeur()  {

  if  [  -n  "$1"  ]  &&
      !  find_section  $1  >  /dev/null
  then  ((  DEFAULT_DELAY  =  $1  *  60  ))
        shift  1
  fi

  for  SPELL  in  $@;  do
    peek_casting  $SPELL
  done

  DEFAULT_DELAY=${DEFAULT_DELAY:=60}

  while  true;  do

    if    !  ACTIVE_SPELL=`find_casting`;  then
      message  "${MESSAGE_COLOR}Waiting"       \
               "${DEFAULT_DELAY}"              \
               "seconds for a cast to begin."  \
               "${DEFAULT_COLOR}"

      for  ((  DELAY=DEFAULT_DELAY  ;  DELAY > 0  ;  DELAY--  )); do
        if  ACTIVE_SPELL=`find_casting`;  then
          break
        else
          sleep 1
        fi
      done
    fi

    if    [  -z  "$ACTIVE_SPELL"  ];  
    then  break
    else  peek_casting  $ACTIVE_SPELL
    fi

  done

}


show_orphans()  {

  for  SPELL  in  `cat  $SPELL_STATUS  |  cut  -d :  -f1`;  do
    if    !  cut  -d :  -f2-  $DEPENDS_STATUS  |
             grep             "^`esc_str $SPELL`:"       |
             grep  -q         ":on:"
    then     echo   $SPELL
    fi
  done

}




#---------------------------------------------------------------------
##=item gaze_show_website <spell>
##
## Shows the website/home page for the given spell.
##
#---------------------------------------------------------------------
gaze_show_website()  {

  for spell in $@; do
    if  codex_set_current_spell_by_name  $spell;  then
      if  [  -n  "$WEB_SITE"  ];  then
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        echo  $WEB_SITE
      else
        echo  "  "
        echo  "No website found for '$spell'.  If you know of a website for"
        echo  "'$spell',  please let the Source Mage developers know so that"
        echo  "it can be included in future versions of the Source Mage"
        echo  "grimoire.  You can report the omission at the Source Mage"
        echo  "bug tracking website:"
        echo  "  "
        echo  "           http://bugs.sourcemage.org/"
      fi
    else
      echo  "  "
      echo  "'$spell' is not a spell in the current grimoire(s).  If it's"
      echo  "not a typo and it's a spell you'd really like to see, consider"
      echo  "creating a spell for it yourself.  For instructions on how to"
      echo  "write & submit spells, see the Source Mage Wiki:"
      echo  "  "
      echo  "             http://wiki.sourcemage.org."
    fi
  done
}

show_maintainer()  {

  for section in $@; do
    ! [[ $GAZE_VERBOSE == 0 ]] &&
    message "${SPELL_COLOR}${section}:${DEFAULT_COLOR}"
    SECTION=`codex_find_section_by_name $section`

    if  [  -d  "$SECTION"  ];  then

      if  [  -f  "$SECTION/MAINTAINER"  ];  then
        cat $SECTION/MAINTAINER
      else
        echo "No maintainer available for section '$( basename  $SECTION )'"
      fi

    else

      echo  "No such section"

    fi
  done

}


show_history()  {

  local SPELL=`codex_find_spell_by_name  $1`

  if  [  -n  "$SPELL"  ];  then

    if  [  -f  "$SPELL/HISTORY"  ]; then
      cat  $SPELL/HISTORY
    else
      echo "No history available for spell '$( basename  $SPELL )'"
    fi

  else

    echo "No such spell '$1'"

  fi
}


#---------------------------------------------------------------------
##=item gaze_show_section [<section> [<section>...]]
##
## Given a section name, shows a table of spells in that section along
## with their grimoire version and installed verion
##
#---------------------------------------------------------------------
gaze_show_section()  {

  local SECTION_NAME

  if  [  $# -gt 0  ]; then

    (
      for  SECTION_NAME  in  $@;  do
        local SECTION=$(codex_find_section_by_name  $SECTION_NAME)
        [[ $SECTION ]] && codex_get_spell_names $SECTION
      done
    ) | column

  else

    codex_get_all_section_names | column

  fi

}


#---------------------------------------------------------------------
##=item gaze_show_section_version_table <section>
##
## Given a section name, shows a table of spells in that section along
## with their grimoire version and installed verion
##
#---------------------------------------------------------------------
gaze_show_section_version_table()  {

   local  SPELLS=`codex_get_spells $1`

   (

     echo  "Section|Spell|Grimoire Version|Installed Version"
     echo  "-------|-----|----------------|-----------------"

     for  spell  in  $SPELLS;  do 

       codex_set_current_spell  $spell                            &&
       local  INSTALLED=`installed_version  $SPELL`               && 
       echo  "$SECTION|$SPELL|${VERSION:="-"}|${INSTALLED:="-"}"

     done 

   ) | column -t -s "|"

}


#---------------------------------------------------------------------
##=item gaze_show_spell_version_table <spell> [<spell> ...]
##
## Shows the versions of spells, both the version in the grimoire and
## the version installed on the system.  
##
#---------------------------------------------------------------------
gaze_show_spell_version_table()  {

  (
    echo  "Section|Spell|Grimoire Version|Installed Version"
    echo  "-------|-----|----------------|-----------------"
 
   for  SPELL  in  $@; do 

      codex_set_current_spell  $SPELL                        &&
      local  INSTALLED=`installed_version  $SPELL`           &&
      echo  "$SECTION|$SPELL|${VERSION:="-"}|${INSTALLED:="-"}"

    done 

  ) | column -t -s "|"

}


#---------------------------------------------------------------------
##=item gaze_show_version <spell or section> [<spell or section> ...]
##
## Shows the versions of spells, both the version in the grimoire and
## the version installed on the system.  
##
#---------------------------------------------------------------------
gaze_show_version()  {
    
  local SPELLS_AND_SECTIONS=$@
  local SPELLS=
  local UNKNOWN=

  for  spell_or_section  in  $SPELLS_AND_SECTIONS;  do

    if  codex_find_spell_or_section_by_name  $spell_or_section;  then

      [  -n  "$CODEX_FOUND_SECTION"  ]                                      &&
      gaze_show_section_version_table  $CODEX_FOUND_SECTION  2>  /dev/null  &&
      echo " "

      [  -n  "$CODEX_FOUND_SPELL"  ]    &&
      SPELLS="$SPELLS $CODEX_FOUND_SPELL"

    else
      UNKNOWN="$spell_or_section $UNKNOWN"
    fi 

  done

  [  -n  "$SPELLS"  ]  &&
  gaze_show_spell_version_table  $SPELLS  2>  /dev/null  &&
  echo " "


  [  -n  "$UNKNOWN"  ]                  &&
  message "Unknown Spells or Sections"  &&
  message "--------------------------"  &&
  message "$UNKNOWN"

}


#---------------------------------------------------------------------
##=item gaze_show_section_license_table <section>
##
## Given a section name, shows a table of spells in that section along
## with their licenses.
##
#---------------------------------------------------------------------
gaze_show_section_license_table()  {

   local  SPELLS=`codex_get_spells $1`

   (

     echo  "Section|Spell|License(s)"
     echo  "-------|-----|----------"

     for  spell  in  $SPELLS;  do 

       codex_set_current_spell  $spell        &&
       echo  "$SECTION|$SPELL|${LICENSE[@]}"

     done 

   ) | column -t -s "|"

}


#---------------------------------------------------------------------
##=item gaze_show_spell_license_table <spell> [<spell> ...]
##
## Shows the licenses of spells
##
#---------------------------------------------------------------------
gaze_show_spell_license_table()  {

  (
    echo  "Spell|License(s)"
    echo  "-----|----------"
 
    for  SPELL  in  $@; do 

      codex_set_current_spell  $SPELL                        &&
      echo "$SPELL|${LICENSE[@]}"

    done 

  ) | column -t -s "|"

}


#---------------------------------------------------------------------
##=item gaze_show_license_table <license> [<license> ...]
##
## Shows the information about the given licenses. 
##
#---------------------------------------------------------------------
gaze_show_license_table()  {

  
  (
    echo  "Abbr|License Full Name|URL"
    echo  "----|-----------------|---"

    for  LICENSE  in  $@; do 

      grep "^$LICENSE|"  ${SM_LICENSE_LIST}  2> /dev/null

    done 

  ) | column -t -s "|"

}



#---------------------------------------------------------------------
##=item gaze_show_license <spell, section, or license> [<spell, section, or license> ...]
##
## Shows the licenses of spells if a spell or section name is given.
## Shows info a license if a license name is given.
##
#---------------------------------------------------------------------
gaze_show_license()  {
    
  local SPELLS_AND_SECTIONS_AND_LICENSES=$@
  local SPELLS=
  local LICENSES=
  local UNKNOWN=

  for  spell_section_or_license  in  $SPELLS_AND_SECTIONS_AND_LICENSES;  do

    if  codex_find_spell_or_section_by_name  $spell_section_or_license;  then

      [  -n  "$CODEX_FOUND_SECTION"  ]                                      &&
      gaze_show_section_license_table  $CODEX_FOUND_SECTION  2>  /dev/null  &&
      echo " "

      [  -n  "$CODEX_FOUND_SPELL"  ]    &&
      SPELLS="$SPELLS $CODEX_FOUND_SPELL"

    elif  grep -q "^`esc_str $spell_section_or_license`|"  ${SM_LICENSE_LIST} 2> /dev/null;  then
      LICENSES="$LICENSES $spell_section_or_license"
    else
      UNKNOWN="$spell_section_or_license $UNKNOWN"
    fi 

  done

  [  -n  "$SPELLS"  ]                                    &&
  gaze_show_spell_license_table  $SPELLS  2>  /dev/null  &&
  echo " "

  [  -n  "$LICENSES"  ]                              &&
  gaze_show_license_table  $LICENSES  2>  /dev/null  &&
  echo " "


  [  -n  "$UNKNOWN"  ]                              &&
  message "Unknown Spells or Sections or Licenses"  &&
  message "--------------------------------------"  &&
  message "$UNKNOWN"

}

gaze_show_installed() {

  if    [  -z  "$1"    ]
        then  $PAGER   $SPELL_STATUS
  else
        for spell in $@; do
                ! [[ $GAZE_VERBOSE == 0 ]] &&
                message  "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
                VERSION=$(installed_version  $spell)
                if  [  -n  "$VERSION"  ]; then
                        echo   "$VERSION"
                else
                        message  "not installed"
                fi
        done
  fi
}

gaze_show_short_description() {

  for spell in $@; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        (
          codex_set_current_spell_by_name  $spell           &&
          echo $SHORT
        )                                                 ||
        message  "No details found"
  done
}

gaze_show_long_description() {

  for spell in $@; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        (
          codex_set_current_spell_by_name  $spell           &&
          codex_get_spell_description  $SPELL_DIRECTORY
        )                                       ||
        message  "No details found"
  done
}

gaze_show_where() {
	for spell in $@; do
		SECTION=$(codex_get_spell_section_name  $spell)
                if ! [[ $GAZE_VERBOSE == 0 ]]; then
		        if [[ $SECTION ]]; then
			        message "$spell -> $SECTION"
                        else
                                message "$spell -> no such spell"
                        fi
		else
                        [[ $SECTION ]] && message "$SECTION"
		fi
	done
}

gaze_show_depends() {
    local spell="$1"
    local MAX_DEPTH=$2 #as a global for show_depends.

    codex_does_spell_exist "$spell" && show_depends "$spell" | sort | uniq
}

gaze_show_dependencies() {
    local SPELL=$1
    [[ $# == 2 ]] && MAX_DEPTH=$2

    (
        query() {
            return 0
        }
        depends() {
                recurse $1 $DEPTH "depends"
                return 0
        }
        optional_depends() {
                recurse $1 $DEPTH "optional"
                return 0
        }
        requires() {
                recurse $1 $DEPTH "requires"
                return 0
        }
        repeat () {
            local CHAR="$1" COUNT="$2"
    
            while (( COUNT-- )); do echo -en "$CHAR"; done
        }
    
        recurse () {
            local name=$1 DEPTH=$2 WHAT=$3
    
            [[ $MAX_DEPTH ]] && [[ $DEPTH -ge $MAX_DEPTH ]] && return 1
    
            repeat "\t" $DEPTH
            echo "$name ($WHAT)"
    
            local SPELL=$(codex_find_spell_by_name $name)
            [[ -e "$SPELL/DEPENDS" ]] &&
            (
                    (( DEPTH++ ))
                    source "$SPELL/DEPENDS" 2>/dev/null
            )
        }
        recurse $SPELL
    )
}



parse()  {

  if [ $1 == "-q" ]; then
        shift;
        GAZE_VERBOSE=0
  fi


  SPELL=$2
  SECTION=$2
  VERSION=`installed_version  $SPELL`

  case  $1  in

        # Spell components. In alphabetical order.
           BUILD)  show_spell_component $1 $2            ;;
       CONFIGURE)  show_spell_component $1 $2            ;;
       CONFLICTS)  show_spell_component $1 $2            ;;
         DETAILS)  show_spell_component $1 $2            ;;
         DEPENDS)  show_spell_component $1 $2            ;;
         HISTORY)  show_spell_component $1 $2            ;;
           PATCH)  show_spell_component $1 $2            ;;
      POST_BUILD)  show_spell_component $1 $2            ;;
    POST_INSTALL)  show_spell_component $1 $2            ;;
     POST_REMOVE)  show_spell_component $1 $2            ;;
      PRE_REMOVE)  show_spell_component $1 $2            ;;
       PRE_BUILD)  show_spell_component $1 $2            ;;
         PREPARE)  show_spell_component $1 $2            ;;
        PROVIDES)  show_spell_component $1 $2            ;;
        TRIGGERS)  show_spell_component $1 $2            ;;

        # Other options
            html)  shift; gaze_catalog_html $@           ;;
          export)  export_snapshot                       ;;
          import)  import_snapshot   $2                  ;;
         section)  shift; gaze_show_section $@           ;;
         version)  shift; gaze_show_version $@           ;;
         license)  shift; gaze_show_license $@           ;;
           alien)  alien                                 ;;
            from)  show_from         $2                  ;;
           newer)  newer             $2                  ;;
           older)  older             $2                  ;;
           prune)  prune                                 ;;
         sources)  sources           $SPELL              ;;
        grimoire)  shift; gaze_catalog $@  |   $PAGER    ;;
          search)  shift; gaze_search "$@"               ;;
         service)  service       "$2"                    ;;
        provides)  shift; gaze_provides $@               ;;
    dependencies)  shift; gaze_show_dependencies $@      ;;
         depends)  shift; gaze_show_depends  "$@"        ;;
         orphans)  show_orphans        |  sort  |  uniq  ;;
         history)  show_history  "$2"                    ;;
     website|url)  shift; gaze_show_website           $@ ;;
      maintainer)  shift; show_maintainer             $@ ;;
       installed)  shift; gaze_show_installed         $@ ;;
           short)  shift; gaze_show_short_description $@ ;;
            what)  shift; gaze_show_long_description  $@ ;;
           where)  shift; gaze_show_where             $@ ;;


    compile)  if  [  -z  "$VERSION"  ];  then
                  codex_set_current_spell_by_name  $2
              fi
              display  $COMPILE_LOGS/$SPELL-$VERSION.bz2   \
                       "Compile log for $SPELL does not exist"
              ;;

    install)  display  $INSTALL_LOGS/$SPELL-$VERSION   \
              "Install log for $SPELL does not exist"
              ;;

    sum)  [  -n  "$SPELL"  ]                         &&
          checksum  "$INSTALL_LOGS/$SPELL-$VERSION"  ||
          checksum  "$INSTALL_LOGS/*"
          ;;


    md5sum)  [  -n  "$SPELL"  ]                             &&
             md5sum_files  "$INSTALL_LOGS/$SPELL-$VERSION"  ||
             md5sum_files  "$INSTALL_LOGS/*"
             ;;

   voyeur)  shift  1;  activate_voyeur  $@  ;;

      pam)  find_pam_aware  ;;

        *)  help  ;;

  esac

}


. /etc/sorcery/config
if  [  $#  == 0  ];  then  help  |  $PAGER;  else  parse  "$@";  fi


#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
