#!/bin/bash
#---------------------------------------------------------------------
## @Synopsis gaze - view sorcery spell management information
## (gaze into the crystal ball)
## @Copyright First version of gaze written & copyrighted 2001 by Brian Peterson
## @Copyright Current version contains none of Brian Peterson's code and is Copyright 2001 by Kyle Sallee
## @Copyright Other additions/corrections Copyright 2002 by the Source Mage Team
#---------------------------------------------------------------------


function help() {
cat << EOF

Invoke gaze with desired command followed by arguments.
Please note that anything in brackets [] is optional.

Command		Arguments	Description

-q		<empty>		disables human style output

alien		<empty>		Discovers untracked files.
from		path/file	Discovers what installed a file.

search		"phrase"	Searches for "phrase" in the long and short
				spell descriptions and in the spell name.
search -name  	"phrase" 	Searches for "phrase" in the spell name.
search -short 	"phrase" 	Searches for "phrase" in the short spell 
				descriptions

service		port|acronym	Displays spells that provide that service.
provides	feature 	Displays spells that provide the feature.

what		spell		Prints the spell's description.
short           spell           Prints the spell's short description.
where		spell		Prints the spell's section.
website | url	spell		Prints the spell's website.
install		spell		Views an install log, and sorcery log files for to the spell.
install-full		spell		Views an install log including all sorcery state files.
install-spell		spell		Views an install log without any sorcery files included.
installed	[spell]		Views installed spells.
version		spell		Views version of spell installed,
				 and version in the grimoire.
versions	spell		Views version of spell in the in all grimoires
license		spell		Views the license of the given spell(s)
license		section		Views the licenses of spells in the given
				 section(s)
license		license		Views information about the given license(s).
compile		spell [version]	Views a compile log. If no optional version
				 was given, try the installed version,
				 if the spell is not installed use the
				 version in the grimoire.
sources		spell		Lists the source files for a spell.
source_urls	spell		Lists the source urls for a spell.
history		spell		Shows history for a spell.

sum		[spell]		Prints checksums.
md5sum		[spell]		Prints md5sums.
size		spell		Prints total size of all files installed
				 by this spell
export				Makes snapshot of box's configuration.
import		snapshot	Restores snapshot.

section		[section]	Lists grimoire sections.
maintainer	[section]	Lists who is the maintainer for a section
grimoire	[grimoire]	Views a text listing of all grimoires.
                	         Or of the specified grimoire.
grimoires			Views list of installed grimoires' names
html	[-s]	[grimoire]	Views a html listing of all grimoires.
                        	 Or of the specified grimoire.
                        	 Additionally displays links to the source
				 files when -s is given.

newer		20020521	Shows available spells newer than May 21, 2002.
older		20010521	Shows spells installed before May 21, 2001.
newer last_sorcery_update  Shows spells newer than your previous sorcery update
newer last_cast            Shows spells newer than your last casting

voyeur		[delay or spell]  
				Peeks into spell compilation.

pam		<empty>		Displays installed or held spells that are
				  linux-pam aware.


orphans		<empty>		Displays installed spells that no installed
				  spells explicitly depend on.

depends		spell [level]	Displays the spells that explicitly or
                   		 recursively depend on this spell,
				 up to $level levels (infinity if omitted)

dependencies    spell [level]	Displays the spells this spell explicitly or 
                        	 recursively depends on,
				 up to $level levels (infinity if omitted)

SCRIPT NAME	spell		will print the spell script for that spell.

activity	<empty>		View the activity log

install-queue	<empty>		View the install queue

remove-queue	<empty>		View the remove queue

checkmd5s       [spell|section]	Print a md5 check of spells

show-held          		Shows all held spells.

show-exiled        		Shows all exiled spells.

EOF
}

#-----
## override column so that we can pass -q to not columnate.
#-----
function maybe_column()  {
  if [ -n "$GAZE_VERBOSE" ]; then
    cat
  else
    column "$@"
  fi
}

#-----
## Make building multiple identical systems easy with exporint of a 
## snapshot of the current state.
## <p>Is this actualy used for anything still? Does it work?
#-----
function export_snapshot()  {

  SOURCE_DIRECTORY=$BUILD_DIRECTORY/snapshot
  mk_source_dir          $SOURCE_DIRECTORY
  cp  -a  /etc           $SOURCE_DIRECTORY
  cp  -a  $CONFIG_CACHE  $SOURCE_DIRECTORY

  for  LINE  in  `cat  $SPELL_STATUS`;  do
    SPELL=`echo  $LINE  |  cut  -d  :  -f1`
     STATUS=`echo  $LINE  |  cut  -d  :  -f2`
    if  [  "$STATUS"  ==  "installed"  ];  then
      echo  $SPELL  >>  /usr/src/snapshot/install
    fi
  done

  SNAPSHOT="/root/snapshot-$HOSTNAME-`date  -u  +%Y%m%d`.tar$EXTENSION"

  cd  $BUILD_DIRECTORY
  if  [  -n  "$EXTENSION"  ];  then
    tar    -c  snapshot     |
    $COMPRESSBIN      >  $SNAPSHOT
  else
    tar  -cf  $SNAPSHOT  snapshot
  fi
  
  rm_source_dir          $SOURCE_DIRECTORY
  echo  "$SNAPSHOT created."

}

#-----
## To make the <@function export_snapshot> actualy be useful, an import
## is quite handy.
## @param snapshot file
#-----
function import_snapshot()  {

          SNAPSHOT=$1
  SOURCE_DIRECTORY=$BUILD_DIRECTORY/snapshot

  if  [  -f  "$1"  ];  then

    cd  $BUILD_DIRECTORY
    mk_source_dir          $SOURCE_DIRECTORY

    if  [  -n  "$EXTENSION"  ];  then
      $COMPRESSBIN -dc $SNAPSHOT  |  tar  -x
    else
      tar  -xf  $SNAPSHOT
    fi

    cd  $SOURCE_DIRECTORY

    for  LINE  in  `cat  install`;  do
      push_install_queue  $LINE
    done
    report  $INSTALL_QUEUE  "Install Queue"

    cp  -ai  local  /etc/sorcery
    cp  -ai  etc    /

    cd  /
    rm_source_dir  $SOURCE_DIRECTORY

  else

    message  "Unable to find snapshot  \"$SNAPSHOT\""
    false

  fi

}

#-----
## Run a simple checksum of a list of files in a file
## Is this used anywhere?
## @param File with list of files the sum
#-----
function checksum()      { for FILE in `cat $1 | files`; do sum -s  $FILE; done; }

#-----
## Run an md5sum of a list of files in a file
## Is this used anywhere?
## @param File with list of files the sum
#-----
function md5sum_files()  { for FILE in `cat $1 | files`; do md5sum  "$FILE"; done; }

#-----
## Find all files on the system not installed by a spell
## This can be quite time consuming.
#-----
function alien()  {

  message  "In a few minutes I will print files found on this disk"
  message  "that were not installed by sorcery.  This is not a"
  message  "security feature!  Files could still be lurking"
  message  "undetected on this box."

  rm    -f  $TMP_DIR/gaze.found
  rm    -f  $TMP_DIR/gaze.known

  message  "Discovering ambient files..."
  find  $TRACKED  |  files  |  filter  "$EXCLUDED"  |  sort  >$TMP_DIR/gaze.found
 
  message  "Discovering installed files..."
  cat  $INSTALL_LOGS/*  /etc/sorcery/update/sorcery-${SORCERY_BRANCH}.log  |  files  |  sort  >  $TMP_DIR/gaze.known

  diff  -B  -a  -d  $TMP_DIR/gaze.found  $TMP_DIR/gaze.known  |
  grep  -v  "^> "                                     |
  grep      "^< "                                     |
  cut  -c  3-                                         |
  filter  "$PROTECTED"

  rm  -f  $TMP_DIR/gaze.found
  rm  -f  $TMP_DIR/gaze.known

}

#-----
## Lists sections and spells in a grimoire.
## Used by <code>gaze grimoire</code>
## @param Grimoire name
## @Stdout catalog
#-----
function gaze_catalog()  {

  local grimoire

  if [[ $# -gt 0 ]]; then
        grimoire=$(codex_find_grimoire $1)
        if [[ $? != 0 ]]; then
            echo "No such grimoire $1"
            exit 1;
        fi  
  fi

  echo  "Sorcery Grimoire for `date  -u`"

  if [ $grimoire ]; then
        echo "Grimoire: " $(basename $grimoire)
  else
        echo "Grimoires: " $(codex_get_all_grimoires | get_basenames)
  fi

  ((  COUNT=0  ))

  for  SECTION  in  `codex_get_all_sections $grimoire`;  do
    echo 
    echo  "-------------------------------------------------"
    echo  "SECTION:  $(  basename  $SECTION  )"  
    echo  "-------------------------------------------------"
    for  spell  in  `codex_get_spells_in_section $SECTION`;  do
       echo `basename $spell`
      ((  COUNT++  ))
    done
  done

  echo
  echo  "Total spells:  $COUNT"

}

#-----
## Lists all sections and spells, output is in HTML format
## @param Grimoire
## @Stdout HTML Catalog
#-----
function gaze_catalog_html()  {

  local grimoire COLS=4

  if [[ $1 == "-s" ]]; then
        shift;
        (( COLS++ ))
  fi
    
  if [[ $# -gt 0 ]]; then
        grimoire=$(codex_find_grimoire $1)
        if [[ $? != 0 ]]; then
            echo "No such grimoire $1"
            exit 1;
        fi
  fi

  echo  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 STRICT//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">"
  echo  "<html xmlns=\"http://www.w3.org/1999/xhtml\">"
  echo  "<head>"
  echo  "<title>Sorcery Grimoires for `date  -u`</title>"
  echo  "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" />"
  echo  "<style type=\"text/css\" media=\"all\"> <!--"
  echo  "body"
  echo  "{"
  echo  "background: white;"
  echo  "color: black;"
  echo  "font-family: Verdana, Arial, Helvetica, sans-serif;"
  echo  "font-size: 10pt;"
  echo  "margin:0px;"
  echo "}"
  echo ""
  echo "h1"
  echo "{"
  echo "background: white;"
  echo "color: green;"
  echo "text-align: center;"
  echo "font-family: Verdana, Arial, Helvetica, sans-serif;"
  echo "font-size: 14pt; "
  echo "}"

  echo "h2"
  echo "{"
  echo "background: white;"
  echo "color: green;"
  echo "text-align: center;"
  echo "font-family: Verdana, Arial, Helvetica, sans-serif;"
  echo "font-size: 12pt; "
  echo "}"

  echo "table"
  echo "{"
  echo "width: 100%;"
  echo "border-style: solid;"
  echo "border-color: black;"
  echo "border-width: 2px;"
  echo "}"

  echo "th"
  echo "{"
  echo "vertical-align: top;"
  echo "text-align: left;"
  echo "background: white;"
  echo "color: black;"
  echo "border-style: solid;"
  echo "border-color: black;"
  echo "border-width: 2px;"
  echo "font-size:12pt;"
  echo "}"

  echo "td"
  echo "{"
  echo "background: white;"
  echo "color: black;"
  echo "vertical-align: top; "
  echo "text-align: left;"
  echo "border-style: solid;"
  echo "border-color: black;"
  echo "border-width: 2px;"
  echo "font-size: 10pt;"
  echo "}"

  echo "--></style>"

  echo  "</head>"
  echo  "<body>"

  echo  "<table>"

  echo "<tr>"
  echo "<th colspan=\"${COLS}\">"
  echo "<h1>Sorcery Grimoires</h1>"
  echo "<h1>$(date -u)</h1>"

  if [ $grimoire ]; then
        echo  "<h1>Grimoire: " $(basename $grimoire)"</h1>"
  else
        echo  "<h1>Grimoires: " $(codex_get_all_grimoires | get_basenames)"</h1>"
  fi

  echo  "</th>"
  echo  "</tr>"

  echo  "<tr>"
  echo  "<th>Spell</th>"
  echo  "<th>Version</th>"
  echo  "<th>Updated</th>"
  echo  "<th>Website</th>"
  [[ $COLS -eq 5 ]] && echo "<th>Source</th>"
  echo  "</tr>"

  ((  COUNT=0  ))

  for  SECTION  in  `codex_get_all_sections $grimoire`;  do
    echo  "<tr>"
    echo  "<th colspan=\"${COLS}\">"
    echo  "<h2>$( basename  $SECTION )</h2>"
    echo  "</th></tr>"
    for  SPELL  in  `codex_get_spells_in_section  $SECTION`;  do
      (
        codex_set_current_spell  $SPELL

        echo  "<tr>"
        if  [  "$SPELL"  ==  "linux"  ]   ||
            [  "$SPELL"  ==  "glibc"  ];  then
            BOLD="<th>"
          UNBOLD="</th>"
        else
            BOLD="<td>"
            UNBOLD="</td>"
        fi
	if  [  -z  "$UPDATED"  ]  &&  [  "$ENTERED"  ];  then
	    UPDATED=$ENTERED
	fi
        echo  "${BOLD}${SPELL}${UNBOLD}"
        echo  "${BOLD}${VERSION}${UNBOLD}"
        echo  "<td>$UPDATED</td>"

        if  [  "$WEB_SITE"  !=  "unknown"  ];  then
	    WEBSITE="`echo  $WEB_SITE  |  cut  -c-30`..."
	    echo  "<td>"
	    echo  "<a href=\"$WEB_SITE\">$WEBSITE</a>"
	    echo  "</td>"
        else
	    echo  "<td></td>"
        fi
        if [[ $COLS -eq 5 ]]; then
            echo "<td>"
            echo "<a href=\"$SOURCE_URL\">$(echo $SOURCE | cut -c-25)</a>"
           i=2
           ii=SOURCE${i}
           while  [  -n "${!ii}"  ];  do
               iii="${ii}_URL"
               echo "<br />"
	       echo "<a href=\"${!iii}\">$(echo ${!ii} | cut -c-25)</a>"
               i=$(($i+1))
               ii=SOURCE${i}
           done
           echo "</td>"
        fi
        echo  "</tr>"
      )
      ((  COUNT++  ))
    done
  done


  echo  "<tr>"
  echo "<th colspan=\"${COLS}\">Total spells:  $COUNT</th>"
  echo "</tr>"
  echo  "</table></body></html>"
}

#-----
## Display a file. Decompresses it if necessary.
## @Note We may want to move this function as it is a generaly handy function
## @param File to display
## @param Message to display if file doesn't exist
#-----
function display()  {

  if  [  -s  "$1"  ];  then
    case  "$(file  -b  $1)"  in
      *text)       cat  $1  |  $PAGER  ;;
      bzip2*)     bzcat  $1  |  $PAGER  ;;
      gzip*)   gzip -cd  $1  |  $PAGER  ;;
	  *) message "Unknown file type."
	    return 1 ;;
    esac
  else
    message  "$2" 1>&2
    false
  fi

}

#-----
## List spells created more recently than the given date
## @param Date
#-----
function newer()  {

  local DATE=$1
  local COMPUTE

  if [ x"$DATE" == x"last_sorcery_update" ]; then
    COMPUTE='($3=="update") { a=a+1; if (a>1) { print $5 ; exit } }'
  elif [ x"$DATE" == x"last_cast" ]; then
    COMPUTE='($3 == "cast" && $6 == "success") { print $1 ; exit }'
  fi

  if [ -n "$COMPUTE" ]; then
    DATE=$( tac $ACTIVITY_LOG | awk -F '\t| |:' "$COMPUTE" )
    if [ -z "$DATE" ]; then
      message "${PROBLEM_COLOR}No previous $1 date found${DEFAULT_COLOR}"
      exit 1
    fi
  fi

  if  [  -n  "$DATE"  ];  then
  (
    echo "Grimoire|Section|Spell|Grimoire Version|Installed Version|Added"
    echo "--------|-------|-----|----------------|-----------------|-----"
    for  SPELL_DIR  in  `codex_get_all_spells`;  do
      unset ENTERED
      .  "$SPELL_DIR/DETAILS" 1>/dev/null 2>&1
      if  [  "$ENTERED"  ]  &&  [  $ENTERED  -gt  $DATE  ];  then
        codex_set_current_spell  $SPELL_DIR
        echo "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|$VERSION|${INSTALLED:="-"}|$ENTERED"
      fi
    done
  ) | maybe_column -t -s "|"
  else
    help  |  $PAGER
  fi

}

#-----
## List spells created less recently than the given date
## @param Date
#-----
function older()  {

  DATE=$1
  if  [  -n  "$DATE"  ];  then
  (
    echo "Grimoire|Section|Spell|Grimoire Version|Installed Version|Added"
    echo "--------|-------|-----|----------------|-----------------|-----"
    for  SPELL_DIR  in  `codex_get_all_spells`;  do
      unset ENTERED
      .  "$SPELL_DIR/DETAILS" 1>/dev/null 2>&1
      if  [  "$ENTERED"  ]  &&  [  $ENTERED  -lt  $DATE  ];  then
        codex_set_current_spell  $SPELL_DIR
        echo "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|$VERSION|${INSTALLED:="-"}|$ENTERED"
      fi
    done
  ) | maybe_column -t -s "|"
  else
    help  |  $PAGER
  fi

}

#-----
## Find all install logs that mention the given string
## @param Search string
## @Stdout grep results
#-----
function show_from()  {

  cd  $INSTALL_LOGS
  grep  "`esc_str $1`$"  *

}

#-----
## Generalized show component of a spell, BUILD, DEPENDS, etc...
## @param Component
## @param Spell
#-----
function show_spell_component()  {

  local        COMPONENT=$1
  local       SPELL_NAME=$2
  local  SPELL_DIRECTORY=`codex_find_spell_by_name  $SPELL_NAME`
  if  [  -e  $SPELL_DIRECTORY/$COMPONENT  ];  then
    cat      $SPELL_DIRECTORY/$COMPONENT
  fi

}


#-----------------------------------------------------------------------
## parameter processing for the search routines.
## the case statement should be self-explanatory 
## @param (optional) Type pf search (-name or -short)
## @param words to search for
#-----------------------------------------------------------------------
function gaze_search() {
    case $1 in

     -name) shift; real_name_search  "$@"  ;;
    -short) shift; real_short_search "$@"  ;;
         *)        real_long_search  "$@"  ;;

    esac
}

#-----------------------------------------------------------------------
##
## searches for pattern(s) in the name of all spells.
## it searches in the codex.index files for the sake of speed 
##
## @Args Patterns
##
#-----------------------------------------------------------------------
function real_name_search() {
    local grimoire pattern

    for grimoire in $(codex_get_all_grimoires); do
        for pattern in "$@"; do
            gawk ' BEGIN {
                        OFS=""
                        IGNORECASE=1
                        quiet = "'$GAZE_VERBOSE'"
                    }
                    /^[^[:blank:]]*'"$pattern"'/ {
                        if (quiet) {
                            print $1
                        }
                        else {
                            print "'"$pattern"' -> ", $1 
                        }
                    }
                ' "$grimoire/$SPELL_INDEX_FILE"
        done
    done
}


#-----------------------------------------------------------------------
##
## Searches for something in a specified grimoire. Not really sure what
## it looks for or why. 
##
## @param Path to grimoire
## @param Spell to look for
## @param Patern to find in the files
## @Stdout The full path to the file, /var/lib/sorcery/codex/grimoire/games/coal/DETAILS
##
#-----------------------------------------------------------------------
function grep_find_grimoire() {
        local path=$1
        local name=$2
        local pattern="$3"

        codex_find_in_grimoire "$path" "$name" | xargs grep -il -- "${pattern}"
}

#-----------------------------------------------------------------------
##
## searches for pattern(s) in the SHORT field of every SPELL in every 
## grimoire
##
## @Args Patterns
##
#-----------------------------------------------------------------------
function real_short_search() {
    local pattern grimoire spell spellname

    for pattern in "$@"; do
        for grimoire in $(codex_get_all_grimoires); do
            for spell in $(
    grep_find_grimoire $grimoire "DETAILS" "SHORT=.*${pattern}"
                        ); do

                spellname=$(basename $(dirname $spell))
                if [[ $GAZE_VERBOSE == 0 ]]; then
                    echo $spellname
                else
                    echo "$pattern -> $spellname" 
                fi

            done
        done
    done
}



#-----------------------------------------------------------------------
##
## searches for pattern(s) in the long description of every SPELL in every 
## grimoire
##
## @Args Patterns
##
#-----------------------------------------------------------------------
function real_long_search()  {
  local atSpell=0
  local file
  local SEARCH

  if ! [[ $GAZE_VERBOSE == 0 ]] ; then
	echo  "Searching...   "
  fi

  let j=0	

  SEARCH=''
  for pattern in "$@"; do
    SEARCH="$SEARCH -e $pattern"
  done

  for file in `codex_get_all_spells | sed 's/$/\/DETAILS/' | xargs grep -il $SEARCH`; do
     for pattern in "$@"; do
       SEARCH_RESULTS[$j]=$(gawk 'BEGIN{ORS = ""; IGNORECASE=1; inLongDesc=0}
         /'"${pattern}"'/{
           if(/^[[:blank:]]*SPELL/)   {print "(Name Match)";        exit 0;}
           if(/^[[:blank:]]*SHORT/)   {print "(Short Description)"; exit 0;}
           if(inLongDesc) {print "(Description)";       exit 0;}
         }
         /cat[[:blank:]]*<<[[:blank:]]*EOF/{inLongDesc = 1;}
         /^EOF$/{inLongDesc=0;} ' $file)

      if [[ ${SEARCH_RESULTS[$j]} ]]; then
        SEARCH_RESULTS[$j]="$pattern ->  $(basename $(dirname $file) ) ${SEARCH_RESULTS[$j]}"
        if [[ $GAZE_VERBOSE == 0 ]]; then
          basename $SPELL_DIRECTORY
        else
          clear_line
          echo ${SEARCH_RESULTS[$j]}
        fi
        let j++
      fi

    done
  done

  if ! [ "$GAZE_VERBOSE" == "0" ]; then
    clear_line
  fi

unset SEARCH_RESULTS

}

#-----
## Search for providers of a service in all spells
## @param service name
#-----
function service()  {
	
  for  SPELL  in  `codex_get_all_spells`;  do
    if    [  -f  $SPELL/services  ]  &&
	  grep  -q  -i  "$1"  $SPELL/services
    then  echo  "$( basename  $SPELL )"
    fi
  done
  
}


#---------------------------------------------------------------------
##
## Given a feature, shows a list of spells that provide the feature
## or functionality.  For example:
##
##    % gaze provides alsa-drivers
##    alsa-driver
##    linux-devel
##    linux-dj
##
## This output indicates that alsa-driver, linux-devel, and linux-dj
## all provide the alsa-drivers feature.
##
## @param feature
##
#---------------------------------------------------------------------
gaze_provides()  {

local spell

  for feature in "$@"; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${feature}:${DEFAULT_COLOR}"
        spell=$(find_providers "$feature")
        if [[ "$spell" ]]; then
                echo "$spell"
        else
                echo "no providers found"
        fi
  done
}

#-----
## Watches a specific exhibisionist
## @param PID of exhibitionist
#-----
function specific_voyeur()
{
  if ! [ -d "/tmp/liblock-0/cast.$1" ]
  then
    return 1
  fi
  nice -n +20			\
   tail /tmp/$1.compile.log	\
    --follow=name --pid=`ls "/tmp/liblock-0/cast.$1"` 2>/dev/null
}

#-----
## Watches the first exhibisionist found
## @param PID of exhibitionist
#-----
function any_voyeur()
{
  local FILE=`find /tmp/liblock-0 -maxdepth 1 -mindepth 1 -name "cast.*" |
         sed "s/.*\/cast\.//"` # We happily assume no spell names contain "cast."
  [ $FILE ] || return 1
  debug "voyeur" "Looking at spell \"$FILE\""
  nice -n +20				\
    tail $(find /tmp/sorcery/cast/ -name $FILE.compile.log )\
         --follow=name --pid=`ls "/tmp/liblock-0/cast.$FILE"` 2>/dev/null
}

#-----
## Start waiting for an exhibisionist.
## @param (optional) Not sure if this is used... specifies a section or something
#-----
function gaze_activate_voyeur()  {

  if  [  -n  "$1"  ]  &&
      !  find_section  $1  >  /dev/null
  then  ((  DEFAULT_DELAY  =  $1  *  60  ))
        shift  1
  fi

  for  SPELL  in  $@;  do
    specific_voyeur $SPELL
  done

  DEFAULT_DELAY=${DEFAULT_DELAY:=60}
  DELAY=$DEFAULT_DELAY
  message  "${MESSAGE_COLOR}Waiting ${DEFAULT_DELAY} seconds for a cast to begin.${DEFAULT_COLOR}"
  while ((DELAY>0));
  do
    if any_voyeur
    then
      DELAY=$DEFAULT_DELAY
      message "${MESSAGE_COLOR}Waiting ${DEFAULT_DELAY} seconds for another cast to begin.${DEFAULT_COLOR}"
      global_clean_resources # normally an internal liblock function, inserted to clean out dead casts
    else
      sleep 1
      let DELAY--
    fi
  done

}

#-----
## Show spells that have no other spell depending on them
#-----
function show_orphans()  {
  compute_reverse_installed_depends my_hash
  for each in $(get_all_spells_with_status 'installed';get_all_spells_with_status 'held'); do
  if [[ ! $(hash_get my_hash $each) ]] ; then
    echo "$each"
  fi
  done|sort
}




#---------------------------------------------------------------------
##
## Shows the website/home page for the given spell.
## @param Spell
##
#---------------------------------------------------------------------
function gaze_show_website()  {

  for spell in $@; do
    if  codex_set_current_spell_by_name  $spell;  then
      if  [  -n  "$WEB_SITE"  ];  then
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        echo  $WEB_SITE
      else
        echo  "  "
        echo  "No website found for '$spell'.  If you know of a website for"
        echo  "'$spell',  please let the Source Mage developers know so that"
        echo  "it can be included in future versions of the Source Mage"
        echo  "grimoire.  You can report the omission at the Source Mage"
        echo  "bug tracking website:"
        echo  "  "
        echo  "           http://bugs.sourcemage.org/"
      fi
    else
      echo  "  "
      echo  "'$spell' is not a spell in the current grimoire(s).  If it's"
      echo  "not a typo and it's a spell you'd really like to see, consider"
      echo  "creating a spell for it yourself.  For instructions on how to"
      echo  "write & submit spells, see the Source Mage Wiki:"
      echo  "  "
      echo  "             http://wiki.sourcemage.org."
    fi
  done
}

#---------------------------------------------------------------------
##
## Shows the maintainer for the given spell.
## @param Spell
##
#---------------------------------------------------------------------
function show_maintainer()  {

  for section in $@; do
    ! [[ $GAZE_VERBOSE == 0 ]] &&
    message "${SPELL_COLOR}${section}:${DEFAULT_COLOR}"
    SECTION=`codex_find_section_by_name $section`

    if  [  -d  "$SECTION"  ];  then

      if  [  -f  "$SECTION/MAINTAINER"  ];  then
        cat $SECTION/MAINTAINER
      else
        echo "No maintainer available for section '$( basename  $SECTION )'"
      fi

    else

      echo  "No such section"

    fi
  done

}


#---------------------------------------------------------------------
##
## Shows the HISTORY for the given spell.
## @param Spell
##
#---------------------------------------------------------------------
function show_history()  {

  local SPELL=`codex_find_spell_by_name  $1`

  if  [  -n  "$SPELL"  ];  then

    if  [  -f  "$SPELL/HISTORY"  ]; then
      cat  $SPELL/HISTORY
    else
      echo "No history available for spell '$( basename  $SPELL )'"
    fi

  else

    echo "No such spell '$1'"

  fi
}


#---------------------------------------------------------------------
##
## Given a section name, shows a table of spells in that section along
## with their grimoire version and installed verion
## @param Section
## @param ...
##
#---------------------------------------------------------------------
function gaze_show_section()  {

  local SECTION_NAME

  if  [  $# -gt 0  ]; then

    (
      for  SECTION_NAME  in  $@;  do
        local SECTION=$(codex_find_section_by_name  $SECTION_NAME)
        [[ $SECTION ]] && codex_get_spell_names $SECTION
      done
    ) | maybe_column

  else

    codex_get_all_section_names | maybe_column

  fi

}


#---------------------------------------------------------------------
##
## Given a section name, shows a table of spells in that section along
## with their grimoire version and installed verion
## @param Section
##
#---------------------------------------------------------------------
function gaze_show_section_version_table()  {

   local  SPELLS=`codex_get_spells_in_section $1`

   (

     echo  "Grimoire|Section|Spell|Grimoire Version|Installed Version"
     echo  "--------|-------|-----|----------------|-----------------"

     for  spell  in  $SPELLS;  do 

       codex_set_current_spell  $spell                            &&
       local  INSTALLED=`installed_version  $SPELL`               && 
       echo  "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|${VERSION:="-"}|${INSTALLED:="-"}"

     done 

   ) | maybe_column -t -s "|"

}


#---------------------------------------------------------------------
##
## Shows the versions of spells, both the version in the grimoire and
## the version installed on the system.  
## @param Spell
## @param ...
##
#---------------------------------------------------------------------
function gaze_show_spell_version_table()  {

  (
	echo  "Grimoire|Section|Spell|Grimoire Version|Installed Version"
    echo  "--------|-------|-----|----------------|-----------------"
 
   for  SPELL  in  $@; do 

      codex_set_current_spell  $SPELL                        &&
      local  INSTALLED=`installed_version  $SPELL`           &&
	  echo  "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|${VERSION:="-"}|${INSTALLED:="-"}"

    done 

  ) | maybe_column -t -s "|"

}


#---------------------------------------------------------------------
##
## Shows the versions of spells, both the version in the grimoire and
## the version installed on the system.  
## @param Spell or section
## @param ...
##
#---------------------------------------------------------------------
function gaze_show_version()  {
    
  local SPELLS_AND_SECTIONS=$@
  local SPELLS=
  local UNKNOWN=

  for  spell_or_section  in  $SPELLS_AND_SECTIONS;  do

    if  codex_find_spell_or_section_by_name  $spell_or_section;  then

      [  -n  "$CODEX_FOUND_SECTION"  ]                                      &&
      gaze_show_section_version_table  $CODEX_FOUND_SECTION  2>  /dev/null  &&
      echo " "

      [  -n  "$CODEX_FOUND_SPELL"  ]    &&
      SPELLS="$SPELLS $CODEX_FOUND_SPELL"

    else
      UNKNOWN="$spell_or_section $UNKNOWN"
    fi 

  done

  [  -n  "$SPELLS"  ]  &&
  gaze_show_spell_version_table  $SPELLS  2>  /dev/null  &&
  echo " "


  [  -n  "$UNKNOWN"  ]                  &&
  message "Unknown Spells or Sections"  &&
  message "--------------------------"  &&
  message "$UNKNOWN"

}

#---------------------------------------------------------------------
##
## Shows the all versions of spell, all versions in all grimoires and 
## the version installed on the system.
## @param Spell
##
#---------------------------------------------------------------------
function gaze_show_versions()  {

  local SPELL=$1
  local SPELL_DIRECTORY=
  local GRIMOIRE=
  local GRIMOIRES=
  local ECHO_INSTALLED=1

  if ! codex_does_spell_exist $SPELL
  then return 1
  fi

  local INSTALLED=`installed_version $SPELL`

  GRIMOIRES=$(codex_get_all_grimoires)

  (

  echo "Grimoire|Section|Spell|Grimoire Version|Installed Version"
  echo "--------|-------|-----|----------------|-----------------"

  for GRIMOIRE in $GRIMOIRES
  do
    if SPELL_DIRECTORY=$(codex_cache_spell_lookup $SPELL $GRIMOIRE)
    then
      codex_set_current_spell $SPELL_DIRECTORY

	  if [ $ECHO_INSTALLED -eq 1 ]
	  then
        echo "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|$VERSION|${INSTALLED:="-"}"
        ECHO_INSTALLED=0
      else
        echo  "$(echo $GRIMOIRE | get_basenames)|$SECTION|$SPELL|$VERSION|-"
      fi

    else
      echo "$(echo $GRIMOIRE | get_basenames)|-|-|-|-"
    fi
  done

  ) | maybe_column -t -s "|"

  echo
}



#---------------------------------------------------------------------
##
## Given a section name, shows a table of spells in that section along
## with their licenses.
## @param Section
##
#---------------------------------------------------------------------
function gaze_show_section_license_table()  {

   local  SPELLS=`codex_get_spells_in_section $1`

   (

     echo  "Section|Spell|License(s)"
     echo  "-------|-----|----------"

     for  spell  in  $SPELLS;  do 

       codex_set_current_spell  $spell        &&
       echo  "$SECTION|$SPELL|${LICENSE[@]}"

     done 

   ) | maybe_column -t -s "|"

}


#---------------------------------------------------------------------
##
## Shows the licenses of spells
## @param Spell
## @param ...
##
#---------------------------------------------------------------------
function gaze_show_spell_license_table()  {

  (
    echo  "Spell|License(s)"
    echo  "-----|----------"
 
    for  SPELL  in  $@; do 

      codex_set_current_spell  $SPELL                        &&
      echo "$SPELL|${LICENSE[@]}"

    done 

  ) | maybe_column -t -s "|"

}


#---------------------------------------------------------------------
##
## Shows the information about the given licenses.
## @param Licence
## @param ... 
##
#---------------------------------------------------------------------
function gaze_show_license_table()  {
  (
    echo  "Abbr|License Full Name|URL"
    echo  "----|-----------------|---"

    for  LICENSE  in  $@; do 

      grep "^$LICENSE|"  ${SM_LICENSE_LIST}  2> /dev/null

    done 

  ) | maybe_column -t -s "|"

}


#---------------------------------------------------------------------
##
## Shows lising of installed grmoires by grimoire name only.
##
#---------------------------------------------------------------------
function gaze_show_grimoires()  {

	echo  ""
	echo  ""
	echo  "Installed Grimoires: " $(codex_get_all_grimoires | get_basenames)
	echo  ""
	echo  ""
	exit
	
}


#---------------------------------------------------------------------
##
## Shows the licenses of spells if a spell or section name is given.
## Shows info a license if a license name is given.
## @param Spell, section, or license
## @param ...
##
#---------------------------------------------------------------------
function gaze_show_license()  {
    
  local SPELLS_AND_SECTIONS_AND_LICENSES=$@
  local SPELLS=
  local LICENSES=
  local UNKNOWN=

  for  spell_section_or_license  in  $SPELLS_AND_SECTIONS_AND_LICENSES;  do

    if  codex_find_spell_or_section_by_name  $spell_section_or_license;  then

      [  -n  "$CODEX_FOUND_SECTION"  ]                                      &&
      gaze_show_section_license_table  $CODEX_FOUND_SECTION  2>  /dev/null  &&
      echo " "

      [  -n  "$CODEX_FOUND_SPELL"  ]    &&
      SPELLS="$SPELLS $CODEX_FOUND_SPELL"

    elif  grep -q "^`esc_str $spell_section_or_license`|"  ${SM_LICENSE_LIST} 2> /dev/null;  then
      LICENSES="$LICENSES $spell_section_or_license"
    else
      UNKNOWN="$spell_section_or_license $UNKNOWN"
    fi 

  done

  [  -n  "$SPELLS"  ]                                    &&
  gaze_show_spell_license_table  $SPELLS  2>  /dev/null  &&
  echo " "

  [  -n  "$LICENSES"  ]                              &&
  gaze_show_license_table  $LICENSES  2>  /dev/null  &&
  echo " "


  [  -n  "$UNKNOWN"  ]                              &&
  message "Unknown Spells or Sections or Licenses"  &&
  message "--------------------------------------"  &&
  message "$UNKNOWN"

}

#-----
##
## Displays the installed version of spells
## @param Spell
## @param ...
##
#-----
function gaze_show_installed() {

  local total_rc=0
  if    [  -z  "$1"    ]
        then  grep -v ':exiled:[^:]*$' $SPELL_STATUS | $PAGER
  else
        for spell in $@; do
                ! [[ $GAZE_VERBOSE == 0 ]] &&
                message  "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
                VERSION=$(installed_version  $spell)
                if  [  -n  "$VERSION"  ]; then
                        echo   "$VERSION"
                else
                        total_rc=1
                        message  "not installed"
                fi
        done
  fi
  return $total_rc
}

#-----
##
## Display the SHORT description of spells
## @param Spell
## @param ...
##
#-----
function gaze_show_short_description() {

  for spell in $@; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        (
          codex_set_current_spell_by_name  $spell           &&
          echo $SHORT
        )                                                 ||
        message  "No details found"
  done
}

#-----
##
## Display the long description of spells
## @param Spell
## @param ...
##
#-----
function gaze_show_long_description() {

  for spell in $@; do
        ! [[ $GAZE_VERBOSE == 0 ]] &&
        message "${SPELL_COLOR}${spell}:${DEFAULT_COLOR}"
        (
          codex_set_current_spell_by_name  $spell           &&
          codex_get_spell_description  $SPELL_DIRECTORY
        )                                       ||
        message  "No details found"
  done
}

#-----
##
## Display the section spells are located in
## @param Spell
## @param ...
##
#-----
function gaze_show_where() {
	for spell in $@; do
		SECTION=$(codex_get_spell_section_name  $spell)
                if ! [[ $GAZE_VERBOSE == 0 ]]; then
		        if [[ $SECTION ]]; then
			        message "$spell -> $SECTION"
                        else
                                message "$spell -> no such spell"
                        fi
		else
                        [[ $SECTION ]] && message "$SECTION"
		fi
	done
}

#-----
##
## Display what spells depend on the given spell
## @param The given spell
##
#-----
function gaze_show_depends() {
    local spell="$1"
    local MAX_DEPTH=$2 #as a global for show_depends.

    codex_does_spell_exist "$spell" && show_depends "$spell" | sort | uniq
}

#-----
##
## @See <@function gaze_show_depends>
## @param Spell
## @param (optional) depth to recurse for
##
#-----
function gaze_show_dependencies() {
    local SPELL=$1
    [[ $# == 2 ]] && MAX_DEPTH=$2

    (
        query() {
            return 0
        }
        depends() {
                recurse $1 $DEPTH "depends"
                return 0
        }
        optional_depends() {
                recurse $1 $DEPTH "optional"
                return 0
        }
        requires() {
                recurse $1 $DEPTH "requires"
                return 0
        }
        repeat () {
            local CHAR="$1" COUNT="$2"
    
            while (( COUNT-- )); do echo -en "$CHAR"; done
        }
    
        recurse () {
            local name=$1 DEPTH=$2 WHAT=$3
    
            [[ $MAX_DEPTH ]] && [[ $DEPTH -ge $MAX_DEPTH ]] && return 1
    
            repeat "\t" $DEPTH
            echo "$name ($WHAT)"
            grep () {
               local foo=$( which grep )
               $foo "$@"
            }
    
            local SPELL=$(codex_find_spell_by_name $name)
            [[ -e "$SPELL/DEPENDS" ]] &&
            (
                    (( DEPTH++ ))
                    grep () { return 0; }
                    source "$SPELL/DEPENDS" 2>/dev/null
            )
        }
        recurse $SPELL
    )
}

#-----
##
## Display the space an installed spell uses
## @param Spell
## @param ...
##
#-----
function gaze_show_size () {
    local spell each
    for spell in "$@"; do
        if ! spell_ok $spell ; then
          message "$spell is not installed"
          continue
        fi
        local version=$(installed_version $spell)
        local file="$INSTALL_LOGS/$spell-$version"
        if ! test -e $file ; then
           message "No install log for $spell ($file)"
           continue
        fi
        for each in $(<$file); do
          test -f $each && echo $each
        done | xargs du -b |
            awk '{ x += $1 } 
                END { print "'$spell' -> " x " bytes in " NR " files." }'
    done
}

#---------------------------------------------------------------------
##
## displays a spell's install log
##
## @param spell - the spell name
## @param version - version for that spell
## @param type - If empty show the log without state files, if "spell"
##        show log without sorcery log files eitther, if "full" show the entire
##        log including sorcery state files
##
#---------------------------------------------------------------------
function gaze_install() {
  local SPELL=$1
  local VERSION=$2
  local TYPE=$3

  local log=$INSTALL_LOGS/$SPELL-$VERSION
  test -f $log || {
    message "Install log for $SPELL does not exist"
    return 1
  }

  if [[ "$TYPE" == full ]] ; then
    sort $log | $PAGER
  elif [[ "$TYPE" == spell ]] ; then
    seperate_state_files $log /dev/stdout /dev/null | sort | $PAGER
  else
    {
      seperate_state_files $log /dev/stderr /dev/stdout | grep $LOG_DIRECTORY
    } 2>&1 | sort | $PAGER
  fi

}

#---------------------------------------------------------------------
##
## prints all spells of a given status.
## @param status - what are we looking for
## @param describe - how is that staus described in english
##
#---------------------------------------------------------------------
function gaze_show_spells_by_status () {
    message -n "${MESSAGE_COLOR}The following spells are set to"
    message -n "${DEFAULT_COLOR} $2"
    message    "${SPELL_COLOR}"
    get_all_spells_with_status $1 | sort | maybe_column
    message -n "${DEFAULT_COLOR}"
}

parse()  {

  # Maintain "TMP_DIR is always set as a global" invariant in the case of
  # non-root users, this leaves vague security holes but they're limited 
  # to files the non-root user can access.
  # a future goal is to make mk_tmp_dirs work for regular users too...
  if  [  "$UID"  -gt  0  ];  then
    export TMP_DIR=/tmp
  else
    mk_tmp_dirs gaze
  fi
  if [ $1 == "-q" ]; then
        shift;
        GAZE_VERBOSE=0
  fi


  SPELL=$2
  SECTION=$2
  VERSION=`installed_version  $SPELL`

  case  $1  in

        # Spell components. In alphabetical order.
           BUILD)  show_spell_component $1 $2            ;;
       CONFIGURE)  show_spell_component $1 $2            ;;
       CONFLICTS)  show_spell_component $1 $2            ;;
         DETAILS)  show_spell_component $1 $2            ;;
         DEPENDS)  show_spell_component $1 $2            ;;
           FINAL)  show_spell_component $1 $2            ;;
         HISTORY)  show_spell_component $1 $2            ;;
         INSTALL)  show_spell_component $1 $2            ;;
           PATCH)  show_spell_component $1 $2            ;;
      POST_BUILD)  show_spell_component $1 $2            ;;
    POST_INSTALL)  show_spell_component $1 $2            ;;
     POST_REMOVE)  show_spell_component $1 $2            ;;
       PRE_BUILD)  show_spell_component $1 $2            ;;
     PRE_INSTALL)  show_spell_component $1 $2            ;;
      PRE_REMOVE)  show_spell_component $1 $2            ;;
         PREPARE)  show_spell_component $1 $2            ;;
        PROVIDES)  show_spell_component $1 $2            ;;
        TRIGGERS)  show_spell_component $1 $2            ;;

        # Other options
            html)  shift; gaze_catalog_html $@           ;;
          export)  export_snapshot                       ;;
          import)  import_snapshot   $2                  ;;
         section)  shift; gaze_show_section $@           ;;
         version)  shift; gaze_show_version $@           ;;
	versions)  shift; gaze_show_versions $@         ;;
         license)  shift; gaze_show_license $@           ;;
           alien)  alien                                 ;;
        activity)  display $ACTIVITY_LOG                 ;;
            from)  show_from         $2                  ;;
           newer)  newer             $2                  ;;
           older)  older             $2                  ;;
         sources)  sources           $SPELL              ;;
     source_urls)  source_urls       $SPELL              ;;
        grimoire)  shift; gaze_catalog $@  |   $PAGER    ;;
       grimoires)  gaze_show_grimoires                   ;;
          search)  shift; gaze_search "$@"               ;;
         service)  service       "$2"                    ;;
        provides)  shift; gaze_provides $@               ;;
         depends)  shift; gaze_show_depends  "$@"        ;;
    dependencies)  shift; gaze_show_dependencies  "$@"   ;;
         orphans)  show_orphans                          ;;
         history)  show_history  "$2"                    ;;
     website|url)  shift; gaze_show_website           $@ ;;
      maintainer)  shift; show_maintainer             $@ ;;
       installed)  shift; gaze_show_installed         $@ ;;
       show-held)  gaze_show_spells_by_status held hold  ;;
     show-exiled)  gaze_show_spells_by_status exiled exiled ;;
           short)  shift; gaze_show_short_description $@ ;;
            what)  shift; gaze_show_long_description  $@ ;;
           where)  shift; gaze_show_where             $@ ;;
            size)  shift; gaze_show_size              $@ ;;
       checkmd5s)  shift; gaze_md5check               $@ ;;


    compile)  if  [  -n  "$3"        ];  then
                  VERSION=$3
              elif  [  -z  "$VERSION"  ];  then
                  codex_set_current_spell_by_name  $2
              fi
              display  $COMPILE_LOGS/$SPELL-$VERSION$EXTENSION   \
                       "Compile log for $SPELL-$VERSION does not exist"
              ;;

        install) gaze_install $SPELL $VERSION ;;
   install-full) gaze_install $SPELL $VERSION full ;;
  install-spell) gaze_install $SPELL $VERSION spell ;;

    sum)  [  -n  "$SPELL"  ]                         &&
          checksum  "$INSTALL_LOGS/$SPELL-$VERSION"  ||
          checksum  "$INSTALL_LOGS/*"
          ;;


    md5sum)  [  -n  "$SPELL"  ]                             &&
             md5sum_files  "$INSTALL_LOGS/$SPELL-$VERSION"  ||
             md5sum_files  "$INSTALL_LOGS/*"
             ;;

   voyeur)  shift  1;  gaze_activate_voyeur  $@  ;;

      pam)  find_pam_aware  ;;

 install-queue)  display  $INSTALL_QUEUE  "Install queue does not exist"  ;;

  remove-queue)  display  $REMOVE_QUEUE   "Remove queue does not exist"   ;;

             *)  help  ;;

  esac

  # dont put code here unless you save the return value from the case/esac code

}


. /etc/sorcery/config
if  [  $#  == 0  ];  then
  help  |  $PAGER
else
  parse  "$@"
  # dont put code here unless you save the return value from the line above
fi


#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
# vim: tabstop=2:shiftwidth=2:expandtab
