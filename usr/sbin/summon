#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## summon is a script for downloading spell source files
##
##=head1 DESCRIPTION
##
## ...
##
##=head1 COPYRIGHT
##
## Original version Copyright 2001 by Kyle Sallee
## Some parts copyright 2002 by Anders Bruun Olsen et al
## Other additions/corrections Copyright 2002 by the Source Mage Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#---------------------------------------------------------------------


help() {

  cat  <<  EOF

Summon downloads single or multiple spell source files.

Example:        summon  nano hdparm sudo
Usage:          summon  [parameters] [spells]

Optional Parameters:

       --from        <directory>        Specify an alternate for $SOURCE_CACHE

       --url        <URL>               Specify an alternate download URL

       -d | --download                  Force download of source, regardless of
                                        of whether it exists locally or not.

       -g | --grimoire <grimoire path>  Searches only the given grimoire when
                                        searching for spells to summon.

       -g | --grimoire <grimoire name>  Searches only the named grimoire when
                                        searching for spells to summon.  Looks
                                        under the codex root for the grimoire.

       -p | --print <type>              Instead of downloading, print out
                                        information in some form according
                                        to the value of <type> for each spell:
                                        source   - print out the filenames
                                        one_url  - print the first url
                                        all_urls - print out all the urls
                                        raw      - print out all the file
                                        and urls, this format is meant to
                                        be re-read by summon in raw mode.

       -r | --raw                       Read in urls in "raw" form, eg:
                                        file1 url1-1 url1-2 ...
                                        file2 url2-1 url2-2 ...
                                        ...

       --queue                       Download all spells in the install queue.
       --all                         Download all spells in the grimoire.
EOF

  exit  1

}


process_parameters()  {

if [ ! -n "$1" ]; then
  help;
fi

  while  [  -n  "$1"  ];  do

    if echo "" $1 | grep  -q "^ -"; then

      case $1 in
         --from) SOURCE_CACHE=$2;         shift 2 ;;
         --help) help;                    exit  1 ;;
          --url) BASE_URL="$2" ;          shift 2 ;;
  -d|--download) FORCE_DOWNLOAD=1;        shift 1 ;;
  -g|--grimoire) codex_set_grimoires $2;  shift 2 ;;
     -p|--print) set_print_type $2;       shift 2 ;;
        --queue) QUEUE=1;                 shift 1 ;;
          --all) SUMMON_ALL=1;            shift 1 ;; 
       -r|--raw) RAW=1;                   shift 1 ;; 
              *) help;                            ;;
      esac

    else  shift 1
    fi

  done

}


strip_parameters()  {

  while  [  -n  "$1"  ];  do

    if  echo  "" $1  |  grep  -q  "^ -";  then

      case  $1  in
        --from)  shift 2  ;;
        --help)  shift 1  ;;
         --url)  shift 2  ;;
 -d|--download)  shift 1  ;;
 -g|--grimoire)  shift 2  ;;
    -p|--print)  shift 2  ;;
       --queue)  shift 1  ;;
         --all)  shift 1  ;;
         --raw)  shift 1  ;;
             *)  shift 1  ;;
      esac

    else  echo  $1
          shift 1
    fi

  done

}

set_print_type() {
  PRINT_TYPE="$1"
  [ "$PRINT_TYPE" == source ]    ||
  [ "$PRINT_TYPE" == one_url ]   ||
  [ "$PRINT_TYPE" == all_urls ]  ||
  [ "$PRINT_TYPE" == raw ]       ||
  help
}

summon_locked()  {

  [     -f        $SUMMONING  ]  &&
  ps        `cat  $SUMMONING`    |
  grep  -q  "summon"
  
  echo "This function is depricated. Please submit a bug report if this is seen:"
  echo "summon::summon_locked (2002/09/30)"
  debug "summon" "This function is depricated. Please submit a bug report if this is seen:"
  debug "summon" "summon::summon_locked (2002/09/30)"
}


run_xdelta()  { (
  echo "This function is depricated. Please submit a bug report if this is seen:"
  echo "summon::run_xdelta"
  debug "summon" "This function is depricated. Please submit a bug report if this is seen:"
  debug "summon" "summon::run_xdelta (2004/05/30)"
  
  cd  $BUILD_DIRECTORY

  PATCH_DIR=$BUILD_DIRECTORY/$SPELL.patcher

  mk_source_dir  $PATCH_DIR
  cd             $PATCH_DIR

  NEW_SOURCE="$SOURCE_CACHE/$3"

  COMPRESSOR=$(  file  -b  $2        |
                 cut   -d  ' '  -f1  |
                 tr    -d \'         )

  case  $COMPRESSOR  in
    bzip2)  bzip2  -cd  $2  >  infile  ;;
     gzip)  gzip   -cd  $2  >  infile  ;;
  esac

  xdelta  patch  $1  infile outfile  &&
  rm  -f  $1                         &&

  if    echo  "$3"  |  grep  -q  "\.bz2"
  then  bzip2  -9  <  outfile  >  $3
  else  gzip   -9  <  outfile  >  $3
  fi  &&

  message  "${MESSAGE_COLOR}Patch successful${DEFAULT_COLOR}"  ||
  message  "${PROBLEM_COLOR}Patch failed${DEFAULT_COLOR}"

  cd  /tmp

  umount  $PATCH_DIR  2>  /dev/null
  rmdir   $PATCH_DIR  2>  /dev/null

) }


patcher()  { (
  echo "This function is depricated. Please submit a bug report if this is seen:"
  echo "summon::patcher"
  debug "summon" "This function is depricated. Please submit a bug report if this is seen:"
  debug "summon" "summon::patcher (2004/05/30)"

#  patcher( OLD_SOURCE, NEW_SOURCE, PATCH_FILE, PATCH_URL )

  OLD_SOURCE=$1
  NEW_SOURCE=$2
  PATCH_FILE=$3
   PATCH_URL=$4

  if  !  [  -f  $SOURCE_CACHE/$NEW_SOURCE  ]  &&
         [  -f  $SOURCE_CACHE/$OLD_SOURCE  ]
  then

    NO_FUZZ="on"
    if  [  -f  $SOURCE_CACHE/$PATCH_FILE  ]  ||
        dl_source            $PATCH_FILE  $PATCH_URL
    then

      message  "${MESSAGE_COLOR}Patching"    \
               "${FILE_COLOR}${OLD_SOURCE}"  \
               "${MESSAGE_COLOR}to"          \
               "${FILE_COLOR}${NEW_SOURCE}${DEFAULT_COLOR}"

      run_xdelta  $SOURCE_CACHE/$PATCH_FILE  \
                  $SOURCE_CACHE/$OLD_SOURCE  \
                  $SOURCE_CACHE/$NEW_SOURCE

    fi
  fi

) }


run_patch()  {
  echo "This function is depricated. Please submit a bug report if this is seen:"
  echo "summon::run_patch"
  debug "summon" "This function is depricated. Please submit a bug report if this is seen:"
  debug "summon" "summon::run_patch (2004/05/30)"

  [     "$PATCH"  ==  "on"          ]  &&
  [  -x  /usr/bin/xdelta            ]  &&
  [  -x  $SCRIPT_DIRECTORY/PATCH    ]  &&
      .  $SCRIPT_DIRECTORY/PATCH

}

main() {

  local spells_to_get
  cd  /tmp
  process_parameters $*

  if [ -n "$RAW" ] ; then
    # this will read from stdin
    download_files "for raw mode summon"
  fi

  if  [  -n  "$SUMMON_ALL"  ];  then
    spells_to_get=`codex_get_all_spells|get_basenames`
  elif [  -n  "$QUEUE"  ]; then

    # Since sometimes we'll be running in raw output mode and possibly
    # redirecting that output somewhere, we dont want to be prompting
    # the "user" about the install queue, but if stdout is a character
    # device (such as a terminal) we may as well try. Im not expecting
    # the user to redirect to a character device too often...but that
    # may be an issue at some point.
    if test -c /dev/stdout ; then
      message -n "${MESSAGE_COLOR}Summoning all spells listed in the queue..."
      message "${DEFAULT_COLOR}"
      list_install_queue
    fi
    spells_to_get=$(< $INSTALL_QUEUE)
  else 
    spells_to_get=`strip_parameters  $*`
  fi

  if [ -n "$PRINT_TYPE" ]; then
    summon_print_spells $spells_to_get
  else
    summon_spells $spells_to_get
  fi
}


. /etc/sorcery/config
if    [  "$UID"  ==  0  ] ; then
  if  [[ $NICE != "0" ]] ; then
    renice $NICE -p $$  >/dev/null
  fi
  main  $*
elif  [[  $1 == -h  ]]  ||  [[  $1 == --help  ]] ; then help
else  
  echo  "Enter the root password, please."  1>&2
  su  -  -c  "DISPLAY=$DISPLAY PATH=$PATH  $0  $*"
fi


#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
