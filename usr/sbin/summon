#!/bin/sh
############################################################
# Copyright 2001 by Kyle Sallee                            #
############################################################
# summon is a script for downloading spell source files     #
############################################################


help()	{

  cat  <<  EOF

Summon downloads single or multiple spell source files.

Example:	summon  nano hdparm sudo
Usage:		summon  [parameters] [spells]

Typing summon with no spells causes summon to download 
every available source specified in the grimoire.

Optional Parameters:

       --from	directory	Specify an alternate for $SOURCE_CACHE
       --url	URL		Specify an alternate download URL
EOF

  exit  1

}


erase()  {

  if  [  -z  "$CONTINUE"  ];  then
    rm  -f  $S_FILE.tar.gz  $S_FILE.tgz  $S_FILE.tar.bz2
  fi

}


call_wget()  {  wget  $NO_CACHE  $RATE  $PASSIVE  $CONTINUE  $1;  }

fuzzy_wget()  {

  if    [  -n  "$ACTIVE_FTP"  ]
  then  unset  PASSIVE
  else         PASSIVE="--passive-ftp"
  fi

  if    echo  "$URL"  |  grep  -q  "sourceforge"
  then  unset  CONTINUE
  else         CONTINUE="-c"
  fi

  if    [  -n  "$DOWNLOAD_RATE"  ]
  then  RATE="--limit-rate=${DOWNLOAD_RATE}"
  fi

  S_URL=`echo  $URL              |
         sed  "s/\.tar\.gz$//"   |
         sed  "s/\.tgz$//"       |
         sed  "s/\.tar\.bz2$//"`

  S_FILE=`echo  $FILE             |
          sed  "s/\.tar\.gz$//"   |
          sed  "s/\.tgz$//"       |
          sed  "s/\.tar\.bz2$//"`

  if    erase  &&  call_wget  $URL;            then  FILE="$FILE"
  elif  [  "$NO_FUZZ"  ==  "on"  ];            then  return 1
  elif  erase  &&  call_wget  $S_URL.tar.bz2;  then  FILE="$S_FILE.tar.bz2"
  elif  erase  &&  call_wget  $S_URL.tar.gz;   then  FILE="$S_FILE.tar.gz"
  elif  erase  &&  call_wget  $S_URL.tgz;      then  FILE="$S_FILE.tgz"
  else  false
  fi


}


disconnect()  {

  if    ps  -C disconnect  >  /dev/null
  then  return
  fi

  rm  -rf          /tmp/disconnect
  cat  <<  EOF  >  /tmp/disconnect
#!/bin/sh

while  ps  -A  |  egrep  -q  "summon|leach";  do  sleep  120;  done
poff
rm  /tmp/disconnect
EOF

chmod  a+x  /tmp/disconnect
            /tmp/disconnect  &

}


connect()  {

  if  !  ifconfig  |  grep  -q  "^eth"   &&
      !  ifconfig  |  grep  -q  "^wlan"  &&
      !  ifconfig  |  grep  -q  "^ppp";  then
    pon

    # Timeout in deciseconds to wait for Interface to come up.
    TIMEOUT=30

    until  ifconfig  |  grep  -q  eth   ||
           ifconfig  |  grep  -q  ppp   ||
           [  $TIMEOUT == 0  ]
    do
      sleep  10
      (( TIMEOUT-- ))
    done
    disconnect

  fi

}


get() {

  if  [  -n  "$1"  ] ;  then

    FILE=`basename  $1`
    if  [  -n  "$BASE_URL"  ];  then  URL=$BASE_URL/$FILE
                                else  URL=$1
    fi

    connect          &&
    fuzzy_wget       &&
    testpack  $FILE  &&
    mv        $FILE  $SOURCE_CACHE  &&
    touch            $SOURCE_CACHE/$FILE

  fi

}


process_parameters()  {

  while  [  -n  "$1"  ];  do

    if  echo  "" $1  |  grep  -q  "^ -";  then

      case  $1  in
         --from)  SOURCE_CACHE=$2;  shift 2  ;;
         --help)  help              exit  1  ;;
          --url)  BASE_URL="$2"     shift 2  ;;
              *)  help                       ;;
      esac

    else  shift
    fi

  done

}


strip_parameters()  {

  while  [  -n  "$1"  ];  do

    if  echo  "" $1  |  grep  -q  "^ -";  then

      case  $1  in
        --from)  shift 2  ;;
        --help)  shirt 1  ;;
         --url)  shift 2  ;;
             *)  shift 1  ;;
      esac

    else  echo  $1
          shift 
    fi

  done

}


dl_source()  {

  if  [  -n  "$1"  ];  then

    FILE="$1"
    shift  1

    if    [  -n  "$LIFESPAN"  ]
    then  rm  -f  $( find $SOURCE_CACHE/$FILE -mmin +$LIFESPAN 2>/dev/null )
    fi

    if  !  `guess_filename  $SOURCE_CACHE/$FILE  > /dev/null`
    then

      message  "${MESSAGE_COLOR}Downloading source file"  \
               "${FILE_COLOR}${FILE}${DEFAULT_COLOR}"     \
               "for spell"                                \
               "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}"

      for  URL  in  $*;  do
        if  get  $URL;  then  break;  fi
      done

    fi

  fi

}


summon_locked()  {

  [     -f        $SUMMONING  ]  &&
  ps        `cat  $SUMMONING`    |
  grep  -q  "summon"

}


run_xdelta()  { (
  
  cd  $BUILD_DIRECTORY

  PATCH_DIR=$BUILD_DIRECTORY/$SPELL.patcher

  mk_source_dir  $PATCH_DIR
  cd             $PATCH_DIR

  NEW_SOURCE="$SOURCE_CACHE/$3"

  COMPRESSOR=$(  file  -b  $2        |
                 cut   -d  ' '  -f1  |
                 tr    -d \'         )

  case  $COMPRESSOR  in
    bzip2)  bzip2  -cd  $2  >  infile  ;;
     gzip)  gzip   -cd  $2  >  infile  ;;
  esac

  xdelta  patch  $1  infile outfile  &&
  rm  -f  $1                         &&

  if    echo  "$3"  |  grep  -q  "\.bz2"
  then  bzip2  -9  <  outfile  >  $3
  else  gzip   -9  <  outfile  >  $3
  fi  &&

  message  "${MESSAGE_COLOR}Patch successful${DEFAULT_COLOR}"  ||
  message  "${PROBLEM_COLOR}Patch failed${DEFAULT_COLOR}"

  cd  /tmp

  umount  $PATCH_DIR  2>  /dev/null
  rmdir   $PATCH_DIR  2>  /dev/null

) }


patcher()  { (

#  patcher( OLD_SOURCE, NEW_SOURCE, PATCH_FILE, PATCH_URL )

  OLD_SOURCE=$1
  NEW_SOURCE=$2
  PATCH_FILE=$3
   PATCH_URL=$4

  if  !  [  -f  $SOURCE_CACHE/$NEW_SOURCE  ]  &&
         [  -f  $SOURCE_CACHE/$OLD_SOURCE  ]
  then

    NO_FUZZ="on"
    if  [  -f  $SOURCE_CACHE/$PATCH_FILE  ]  ||
        dl_source            $PATCH_FILE  $PATCH_URL
    then

      message  "${MESSAGE_COLOR}Patching"    \
               "${FILE_COLOR}${OLD_SOURCE}"  \
               "${MESSAGE_COLOR}to"          \
               "${FILE_COLOR}${NEW_SOURCE}${DEFAULT_COLOR}"

      run_xdelta  $SOURCE_CACHE/$PATCH_FILE  \
                  $SOURCE_CACHE/$OLD_SOURCE  \
                  $SOURCE_CACHE/$NEW_SOURCE

    fi
  fi

) }


run_patch()  {

  [     "$PATCH"  ==  "on"          ]  &&
  [  -x  /usr/bin/xdelta            ]  &&
  [  -x  $SCRIPT_DIRECTORY/PATCH    ]  &&
      .  $SCRIPT_DIRECTORY/PATCH

}


download() {

  if  !  summon_locked;  then

    echo  $$  >  $SUMMONING

    run_patch

    dl_source  $SOURCE    ${SOURCE_URL[*]}
    dl_source  $SOURCE2   ${SOURCE2_URL[*]}
    dl_source  $SOURCE3   ${SOURCE3_URL[*]}
    dl_source  $SOURCE4   ${SOURCE4_URL[*]}
    dl_source  $SOURCE5   ${SOURCE5_URL[*]}
    dl_source  $SOURCE6   ${SOURCE6_URL[*]}
    dl_source  $SOURCE7   ${SOURCE7_URL[*]}
    dl_source  $SOURCE8   ${SOURCE8_URL[*]}
    dl_source  $SOURCE9   ${SOURCE9_URL[*]}
    dl_source  $SOURCE10  ${SOURCE10_URL[*]}
    dl_source  $SOURCE11  ${SOURCE11_URL[*]}
    dl_source  $SOURCE12  ${SOURCE12_URL[*]}
    dl_source  $SOURCE13  ${SOURCE13_URL[*]}
    dl_source  $SOURCE14  ${SOURCE14_URL[*]}
    dl_source  $SOURCE15  ${SOURCE15_URL[*]}
    dl_source  $SOURCE16  ${SOURCE16_URL[*]}
    dl_source  $SOURCE17  ${SOURCE17_URL[*]}
    dl_source  $SOURCE18  ${SOURCE18_URL[*]}
    dl_source  $SOURCE19  ${SOURCE19_URL[*]}

    rm  -f  $SUMMONING

  else  false
  fi

}



summon_grimoire()  {

  for  SECTION  in  `ls  $GRIMOIRE`;  do
    for  SPELL  in  `ls  $GRIMOIRE/$SECTION`;  do
      (  SUMMONING=/var/lock/summoning.$SPELL
         run_details  &&
         download
      )
    done
  done

}


main()	{

  cd  /tmp
  process_parameters        $*
  SPELLS=`strip_parameters  $*`

  if  [  -z  "$SPELLS"  ];  then
    summon_grimoire
  else

    for  SPELL  in  $SPELLS;  do
      (  SUMMONING=/var/lock/summoning.$SPELL
         run_details  &&
         download
      )
    done

  fi

}


. /etc/sorcery/config
if    [  "$UID"  ==  0  ]
then  renice +10 -p $$  >/dev/null
      main  $*
else  
  echo  "Enter the root password, please."  1>&2
  su  -  -c  "DISPLAY=$DISPLAY PATH=$PATH  $0  $*"
fi
