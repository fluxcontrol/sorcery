#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## Functions for dealing with the actual compiling/installation of spells
## and walking through casts 'pass 4' pipeline.
##
##=head1 DESCRIPTION
##
## Contains functions for the build api version 2
## which has the following steps:
## PRE_BUILD -> BUILD -> PRE_INSTALL -> INSTALL -> POST_INSTALL ->
## FINAL -> TRIGGERS
##
##=head1 COPYRIGHT
##
## Copyright (C) 2002 The Source Mage Team <http://www.sourcemage.org>
##
##=head1 FUNCTIONS
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## This runs through the phase 4 pipeline of building and installing
## a spell for BUILD_API 2.
#---------------------------------------------------------------------
function run_build_spell() {
  debug "build_api/api2" "run_build_spell"

  C_LOG=$TMP_DIR/$SPELL.compile.log
  C_FIFO=/dev/stdout # not needed for api2 anymore, but just in case

  rm  -f $C_LOG
  touch $C_LOG
  
  if [[ $SCREEN_NAME ]] ; then  
    screen_new_window "$SCREEN_NAME" $SCREEN_CAST_WIN "cast $SPELL" \
      tail -f -s 0.1 $C_LOG
    screen_switch_window "$SCREEN_NAME" $SCREEN_MAIN_WIN

    VOYEUR_STDOUT=/dev/null
    VOYEUR_STDERR=/dev/null
  elif [ "$VOYEUR" == "on" -a -z "$SILENT" ] ; then
    VOYEUR_STDOUT=/dev/stdout
    VOYEUR_STDERR=/dev/stderr
  else
    VOYEUR_STDOUT=/dev/null
    VOYEUR_STDERR=/dev/null
  fi
                      
  local PROTECT_SORCERY=yes
  local rs
  (
    run_pre_build                           || return 1
    run_config_loc                          || return 2
    (
      run_build                             &&
      pwd > $TMP_DIR/build.saved.pwd        &&
      run_pre_install                       &&
      prepare_stage_root                    &&
      invoke_installwatch                   &&
      if [[ "$STAGED_INSTALL" != "off" ]]
      then
        invoke_stage_root
      fi                                    &&
      export C_LOG=$C_LOG                   &&
      export C_FIFO=$C_FIFO                 &&
      export IW_LOG=$IW_LOG                 &&
      export VOYEUR_STDOUT=$VOYEUR_STDOUT   &&
      export VOYEUR_STDERR=$VOYEUR_STDERR   &&
      export S_PWD=$TMP_DIR/build.saved.pwd &&
      delve $SPELL INSTALL                  &&
      delve $SPELL POST_INSTALL             || return 2
      if [[ "$STAGED_INSTALL" != "off" ]]
      then
        devoke_stage_root &&
	install_staged_spell
      fi                                    &&
      devoke_installwatch                   &&
      destroy_stage_root                    &&
      run_final                             || return 3
    ) 2> >(tee -a $C_LOG 1>&2 >> $VOYEUR_STDERR) \
       > >(tee -a $C_LOG >> $VOYEUR_STDOUT)
  )
  rs=$?
  if [[ $SCREEN_NAME ]] && [ $rs -gt 0 ] ; then
    screen_move_window "$SCREEN_NAME" $SCREEN_CAST_WIN $SCREEN_LAST_FAILED_CAST_WIN
    screen_name_window "$SCREEN_NAME" $SCREEN_LAST_FAILED_CAST_WIN "Failed $SPELL"
    screen_kill_window "$SCREEN_NAME" $SCREEN_CAST_WIN
    screen_notify "$SCREEN_NAME" "Last failed cast at $SCREEN_LAST_FAILED_CAST_WIN"
  elif [[ $SCREEN_NAME ]] ; then
    screen_kill_window "$SCREEN_NAME" $SCREEN_CAST_WIN
  fi
  
  # triggers don't run in the window
  [ $rs -gt 0 ] && return $rs

  run_triggers || return 4

  return 0
}
#---------------------------------------------------------------------
## This phase of casting involves unpacking the source into the
## source directories. If a PRE_BUILD file exists in SCRIPT_DIRECTORY
## and is executable it is run in preference to the default_pre_build.
#---------------------------------------------------------------------
function run_pre_build() {

  debug "build_api/api2" "run_pre_build()"
  message  "${MESSAGE_COLOR}Building"  \
           "${SPELL_COLOR}${SPELL}"    \
           "${DEFAULT_COLOR}"

  rm_source_dir
  mkdir -p $BUILD_DIRECTORY
  cd  $BUILD_DIRECTORY

  verify_sources &&
  persistent_load &&
  if  [  -x  $SCRIPT_DIRECTORY/PRE_BUILD  ];  then
    . $SCRIPT_DIRECTORY/PRE_BUILD
  elif [[ "$PRE_BUILD_CMD" ]] ; then
    $PRE_BUILD_CMD
  else
    default_pre_build
  fi &&
  persistent_save
}


#---------------------------------------------------------------------
## Starts up the compile logs, turns on the various environment
## settings that need to be on, eventually gets around to running
## BUILD or default_build.
#---------------------------------------------------------------------
function run_build()  {

  debug "build_api/api2" "Starting run_compile()"

  echo  "Compile log for $SPELL $VERSION Built on `date  -u`"  >  $C_LOG
  echo  "Using gcc version: `gcc -dumpversion`" >> $C_LOG

  [  -d  "$SOURCE_DIRECTORY"  ]  &&
  cd      $SOURCE_DIRECTORY

  invoke_build_dir
  invoke_gcc2
  optimize

  message -n "Installing in dir: "
  pwd
  message "$SPELL    $VERSION"

  persistent_load &&
  if  [  -x  $SCRIPT_DIRECTORY/BUILD  ];  then
    .  $SCRIPT_DIRECTORY/BUILD
  elif [[ "$BUILD_CMD" ]] ; then
    $BUILD_CMD
  else
    default_build
  fi &&
  persistent_save

  if  [  "$?"  !=  0  ];  then
    message  "${PROBLEM_COLOR}"      \
             "! Problem Detected !"  \
             "${DEFAULT_COLOR}"
    return 1
  fi
}


#---------------------------------------------------------------------
## Turns all the various logs back on that were turned off from after
## run_build finished, then runs PRE_INSTALL or default_pre_install
#---------------------------------------------------------------------
function run_pre_install() {
  debug "build_api/api2" "Starting run_pre_install()"

  persistent_load &&
  if  [  -x  $SCRIPT_DIRECTORY/PRE_INSTALL  ];  then
    .  $SCRIPT_DIRECTORY/PRE_INSTALL 
  elif [[ "$PRE_INSTALL_CMD" ]] ; then
    $PRE_INSTALL_CMD
  else
    default_pre_install
  fi &&
  persistent_save &&
  echo  "Compile log for $SPELL $VERSION Completed Build on `date  -u`"  >>  $C_LOG
}


#---------------------------------------------------------------------
## load persistent vars, then runs INSTALL or default_install
## Along with other stuff that needs to be transplanted elsewhere.
## NOTE: this function is run from delve so installwatch can be invoked
## around an execed bash shell, this is needed for installwatch to
## stage root properly
#---------------------------------------------------------------------
function run_install() {
  debug "build_api/api2" "Starting run_install()"
  
  persistent_load &&
  if  [  -x  $SCRIPT_DIRECTORY/INSTALL  ];  then
    .  $SCRIPT_DIRECTORY/INSTALL 
  elif [[ "$INSTALL_CMD" ]] ; then
    $INSTALL_CMD
  else
    default_install
  fi &&
  persistent_save


  if  [  "$?"  !=  0  ];  then
    message  "${PROBLEM_COLOR}"      \
             "! Problem Detected !"  \
             "${DEFAULT_COLOR}"
    false
  fi
}

#---------------------------------------------------------------------
## Checks for a POST_BUILD file in SCRIPT_DIRECTORY, and if it is
## executable, runs it. This file is run after INSTALL and before
## FINAL. Its purpose is to manipulate the installed files in the stage
## root and install other tracked files.
## NOTE: this function is run from delve so installwatch can be invoked
## around an execed bash shell, this is needed for installwatch to
## stage root properly
#---------------------------------------------------------------------
function run_post_install() {
  debug "build_api/api2" "Starting run_post_install()"
  persistent_load &&
  if    [  -x  $SCRIPT_DIRECTORY/POST_INSTALL  ]; then
    cd $STAGE_DIRECTORY/TRANSL &&
    . $SCRIPT_DIRECTORY/POST_INSTALL
  elif [[ "$POST_INSTALL_CMD" ]] ; then
    cd $STAGE_DIRECTORY/TRANSL &&
    $POST_INSTALL_CMD
  else
    default_post_install
  fi &&
  persistent_save &&
  unlock_resources "libgrimoire" "install"
}

#---------------------------------------------------------------------
## Checks for a FINAL file in SCRIPT_DIRECTORY, and if it is
## executable, runs it. This file is used for extra files that need
## to be installed, but not tracked by installwatch.
#---------------------------------------------------------------------
function run_final() {

  debug "build_api/api2" "Starting run_final()"
  persistent_load &&
  if    [  -x  $SCRIPT_DIRECTORY/FINAL  ]
  then
    . $SCRIPT_DIRECTORY/FINAL
  elif [[ "$FINAL_CMD" ]] ; then
    $FINAL_CMD
  fi &&
  persistent_save
}

#---------------------------------------------------------------------
## @Type API
## Creates the source directory and unpacks the source package into it.
## Used if no PRE_BUILD script is found for a spell.
##
#---------------------------------------------------------------------
function real_default_pre_build() {

  debug "libgrimoire" "default_pre_build() - SOURCE=$SOURCE SOURCE_DIRECTORY=$SOURCE_DIRECTORY"
  mk_source_dir        $SOURCE_DIRECTORY  &&
  unpack_file

}


#---------------------------------------------------------------------
## @Type API
## Used if no BUILD script is found 
## Default build is:
## <pre>
##  ./configure  --build=$BUILD        \
##               --prefix=/usr         \
##               --sysconfdir=/etc     \
##               --localstatedir=/var  \
##               $OPTS                 &&
##  make
## </pre>
##
#---------------------------------------------------------------------
function real_default_build() {
  debug "build_api/api2" "real_default_build"

  OPTS="$OPTS --build=${BUILD}"
  #If these switches are used, they _may_ stop distcc and ccache from working
  # for some spells (bug 3798)
  #  We could write wrappers for all of the possible binaries
  [[ $CROSS_INSTALL == on ]] && OPTS="$OPTS --host=${HOST}"

  ./configure --prefix=${INSTALL_ROOT}/usr  \
          --sysconfdir=${INSTALL_ROOT}/etc  \
       --localstatedir=${INSTALL_ROOT}/var  \
              --mandir=${INSTALL_ROOT}/usr/share/man   \
             --infodir=${INSTALL_ROOT}/usr/share/info  \
                       $OPTS                 &&
  make

}

#---------------------------------------------------------------------
## @Type API
## Used if no PRE_INSTALL script is found
## Default pre_install is:
## <pre>
##  prepare_install
## </pre>
##
#---------------------------------------------------------------------
function real_default_pre_install() {
  debug "build_api/api2" "Starting real_default_pre_install"
  prepare_install
}

#---------------------------------------------------------------------
## @Type API
## Used if no INSTALL script is found
## Default install is:
## <pre>
##  make    install
## </pre>
##
#---------------------------------------------------------------------
function real_default_install() {
  debug "build_api/api2" "Starting real_default_install"
  make    install
}


#---------------------------------------------------------------------
## @Type API
## Installs configuration files and documentation.  Stops installwatch.
## Used if no POST_INSTALL script is found for a spell.
##
## This is identical to api1's post_build
#---------------------------------------------------------------------
function real_default_post_install() {

  debug "build_api/api2" "Starting real_default_post_install"
  install_xinetd
  install_initd
  install_pam_confs
  install_desktop_files
  gather_docs
  init_post_install
  ldconfig
  # release_saved_libraries
  cd  /

}

#---------------------------------------------------------------------
## @License
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
