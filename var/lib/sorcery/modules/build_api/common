#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## Functions for dealing with the actual compiling/installation of spells
## and walking through casts 'pass 4' pipeline.
##
##=head1 DESCRIPTION
##
##
##=head1 COPYRIGHT
##
## Copyright (C) 2002 The Source Mage Team <http://www.sourcemage.org>
##
##=head1 FUNCTIONS
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## Prompts the user about spells that are in conflict with the current
## spell and allows them to dispel them. If the user chooses not to
## dispel the conflicting spell, the function returns 1
## @return nothing if the user dispels the conflicting spell
## @return 1 if the user chooses not to dispel the conflicting spell
#---------------------------------------------------------------------
function run_conflicts() {

  debug "build_api/common" "Starting run_conflicts() on $SPELL"

  if  [  -x  $SCRIPT_DIRECTORY/CONFLICTS  ]; then
    local CONFLICTS=$(
        persistent_load
        . $SCRIPT_DIRECTORY/CONFLICTS
        persistent_save
    )

    local tmp to_dispel=""
    for  tmp  in  $CONFLICTS  ;  do
      local spell_and_default
      explode  $tmp  ':'  spell_and_default

      local text="${SPELL_COLOR}${SPELL}${MESSAGE_COLOR} conflicts with"
      text="$text ${SPELL_COLOR}${spell_and_default[0]}${MESSAGE_COLOR}."
      text="$text Dispel"
      text="$text ${SPELL_COLOR}${spell_and_default[0]}${MESSAGE_COLOR}?"

      if  query  "$text"  ${spell_and_default[1]}  ;  then
        to_dispel="$to_dispel ${spell_and_default[0]}"
      else
        echo  $SPELL  >>  $FAILED_LIST
        return  1
      fi

      dispel  $to_dispel
    done
  fi

}


#---------------------------------------------------------------------
## Prompts the user about possible security problems with the current
## spell. Allows a safe way of failing a spell due to security problems.
## @return 0 if there are no security problem or the user acknowledges them.
## @return 1 if the user decides not to accept the security concerns
#---------------------------------------------------------------------
# checks for a security file
# returns 0 if spell should be cast, 1 otherwise
function run_security() {
    debug "build_api/common" "Starting run_security() on $SPELL"
    if    [  -f  $SCRIPT_DIRECTORY/SECURITY  ]; then
      echo -e "${SPELL_COLOR}${SPELL}:${DEFAULT_COLOR}"
      tee -a $SECURITY_LOG < $SCRIPT_DIRECTORY/SECURITY
        if [ `grep critical $SCRIPT_DIRECTORY/SECURITY` ]; then
          if query "${RED}SECURITY CRITICAL:${QUERY_COLOR} Do you still want to cast ${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}?" "n"; then
            return 0
          fi
          return 1
        else
          if query "SECURITY: Do you still want to cast ${SPELL_COLOR} $SPELL ${QUERY_COLOR}?" "y"; then
            return 0
          fi
          return 1
        fi
    fi
    return 0
}


#---------------------------------------------------------------------
## pokes around for a configure or src/configure and if it exists
## asks the user if they want to edit the custom options
#---------------------------------------------------------------------
function run_config_loc () {
  debug "build_api/common" "Starting run_config_loc() on $SPELL"
  pushd . > /dev/null # may have been somewhere else
  [  -d  "$SOURCE_DIRECTORY"  ]  &&
  cd      $SOURCE_DIRECTORY   # we need to be in here for this function to work
  if  [[  $CONFIG_LOC  == on  ]]; then

    if  [ -x ./configure ] || [ -x ./src/configure ] ; then

      if  [  !  -d  $SM_CONFIG_OPTION_CACHE  ] ; then
        mkdir --parents --mode=0755 $SM_CONFIG_OPTION_CACHE
      fi

      if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ] ; then
        message "${MESSAGE_COLOR}These are your current -- config options for spell ${SPELL_COLOR}$SPELL"
        message "${FILE_COLOR}($SM_CONFIG_OPTION_CACHE/$SPELL)"
        cat $SM_CONFIG_OPTION_CACHE/$SPELL | column
      fi

      if    query  "Do you wish to add -- options to ./configure?"  n ;  then
				F_TMP=/tmp/cast.$$.configure
        rm -f $F_TMP
				
        if [ -x ./configure ]; then
          ./configure --help > $F_TMP
        elif [ -x ./src/configure ]; then
          ./src/configure --help > $F_TMP
        fi

        if [ -f $F_TMP ]; then
          sedit 's/^/# /' $F_TMP
        fi

        cat $SM_CONFIG_OPTION_CACHE/$SPELL >> $F_TMP 2>/dev/null
        edit_file $F_TMP
        rm -f $SM_CONFIG_OPTION_CACHE/$SPELL
        sedit '/^#.*$/d' $F_TMP
        mv $F_TMP $SM_CONFIG_OPTION_CACHE/$SPELL
      fi

      # load custom OPTS
      if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ];  then
        OPTS="$OPTS $(< $SM_CONFIG_OPTION_CACHE/$SPELL)"
        message "${MESSAGE_COLOR} OPTS= ${DEFAULT_COLOR}$OPTS"
      fi

    fi

  fi

  popd

}

#---------------------------------------------------------------------
## Checks for a TRIGGERS file in SCRIPT_DIRECTORY, and if it is
## executable, runs it.
#---------------------------------------------------------------------
function run_triggers() {
  debug "build_api/common" "Starting run_triggers() on $SPELL"

  if    [  -x  $SCRIPT_DIRECTORY/TRIGGERS  ]
  then
    persistent_load
    . $SCRIPT_DIRECTORY/TRIGGERS
    persistent_save
  fi

}




#---------------------------------------------------------------------
## Stuff that should be done if run_build_spell succeeds
## This is intended to be overridable at some point
#---------------------------------------------------------------------
function run_spell_success() {
    debug "build_api/common" "cast of $SPELL-$VERSION was successful"

    local INST_LOG="$INSTALL_LOGS/$SPELL-$VERSION"
    local MD5_LOG="$MD5SUM_LOGS/$SPELL-$VERSION"
    local TMP_INST_LOG="$TMP_DIR/$SPELL-$VERSION.install"
    local TMP_MD5_LOG="$TMP_DIR/$SPELL-$VERSION.md5"
    local CACHE_COMP="$INSTALL_CACHE/$SPELL-$VERSION-$BUILD.tar$EXTENSION"
    local C_LOG_COMP="$COMPILE_LOGS/$SPELL-$VERSION$EXTENSION"

    sound  SUCCESS

    create_compile_log
    view_compile_log

    activity_log  "cast"  "$SPELL"  "$VERSION"  "success"
    add_spell $SPELL installed $VERSION
    echo $SPELL >> $SUCCESS_LIST

    debug "build_api/common" "Merging depends info"
    local t_DEPENDS_STATUS=$(lock_start_transaction $DEPENDS_STATUS)
    # none of the old values are valid, only the new, uncommitted values are
    remove_depends_status $t_DEPENDS_STATUS $SPELL
    local spell_depends=$(hash_get uncommitted_hash $SPELL)
    if [ -e $spell_depends ] ; then
      cat  $spell_depends >> $t_DEPENDS_STATUS
      rm -f $spell_depends &>/dev/null 
    fi
    lock_commit_transaction $DEPENDS_STATUS

    # since the database is now accurate, no reason to keep old answers
    # floating around
    [ -e "$ABANDONED_DEPENDS/$SPELL" ] &&
    rm -f $ABANDONED_DEPENDS/$SPELL &>/dev/null

    # this will make the raw log that needs post processing to strip
    # INSTALL_ROOT and insert TRACK_ROOT in its place
    
    message  "${MESSAGE_COLOR}Creating install log" \
             "${FILE_COLOR}${INST_LOG}${DEFAULT_COLOR}"
    track $TMP_INST_LOG
    install_log_filter $INSTALL_ROOT $TRACK_ROOT < $TMP_INST_LOG > $INST_LOG

    message  "${MESSAGE_COLOR}Creating MD5 log"        \
             "${FILE_COLOR}${MD5_LOG}${DEFAULT_COLOR}"
    md5list $TMP_INST_LOG $TMP_MD5_LOG
    md5_log_filter $INSTALL_ROOT $TRACK_ROOT < $TMP_MD5_LOG > $MD5_LOG

    # archives are relative to / in their own environment, and thus
    # INSTALL_ROOT is stripped
    sed "s:^$INSTALL_ROOT/::" $TMP_INST_LOG | archive $INSTALL_ROOT 

    report_install

    rm_source_dir
    rm  -f  $IW_LOG  $TMP_LOG  $CASTING $C_LOG
}

#---------------------------------------------------------------------
## Stuff that should be done if run_build_spell fails
## This is intended to be overridable at some point
#---------------------------------------------------------------------
function run_spell_failure() {
    debug "build_api/common" "cast of $SPELL-$VERSION failed"
    local rc=$1

    sound  FAILURE

    if [ $rc != 1 ] ; then
      create_compile_log
      view_compile_log
    fi
    activity_log "cast" "$SPELL"  "$VERSION" "failure"
    echo $SPELL >> $FAILED_LIST

    local spell_depends=$(hash_get uncommitted_hash $SPELL)
    [ -e $spell_depends ] && rm $spell_depends

    # This may have been locked if there was a failure during the install
    unlock_resources "libgrimoire" "install"

    IW_LOG="$INSTALLWATCHFILE"
    INSTALLWATCHFILE=""
    rm  -f  $IW_LOG  $TMP_LOG  $CASTING $C_LOG

    [[  $CLEAN_SOURCE == on ]] && rm_source_dir
    CAST_EXIT_STATUS=1
}
