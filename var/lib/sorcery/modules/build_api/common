#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## Functions for dealing with the actual compiling/installation of spells
## and walking through casts 'pass 4' pipeline.
##
##=head1 DESCRIPTION
##
##
##=head1 COPYRIGHT
##
## Copyright (C) 2002 The Source Mage Team <http://www.sourcemage.org>
##
##=head1 FUNCTIONS
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## Prompts the user about spells that are in conflict with the current
## spell and allows them to dispel them. If the user chooses not to
## dispel the conflicting spell, the function returns 1
## @return nothing if the user dispels the conflicting spell
## @return 1 if the user chooses not to dispel the conflicting spell
#---------------------------------------------------------------------
function run_conflicts() {

  debug "build_api/common" "Starting run_conflicts() on $SPELL"

  if  [  -x  $SCRIPT_DIRECTORY/CONFLICTS  ]; then
    local CONFLICTS=$(
        persistent_load
        . $SCRIPT_DIRECTORY/CONFLICTS
        persistent_save
    )

    local tmp to_dispel=""
    for  tmp  in  $CONFLICTS  ;  do
      local spell_and_default
      explode  $tmp  ':'  spell_and_default

      local text="${SPELL_COLOR}${SPELL}${MESSAGE_COLOR} conflicts with"
      text="$text ${SPELL_COLOR}${spell_and_default[0]}${MESSAGE_COLOR}."
      text="$text Dispel"
      text="$text ${SPELL_COLOR}${spell_and_default[0]}${MESSAGE_COLOR}?"

      if  query  "$text"  ${spell_and_default[1]}  ;  then
        to_dispel="$to_dispel ${spell_and_default[0]}"
      else
        echo  $SPELL  >>  $FAILED_LIST
        return  1
      fi

      dispel  $to_dispel
    done
  fi

}


#---------------------------------------------------------------------
## Prompts the user about possible security problems with the current
## spell. Allows a safe way of failing a spell due to security problems.
## @return 0 if there are no security problem or the user acknowledges them.
## @return 1 if the user decides not to accept the security concerns
#---------------------------------------------------------------------
# checks for a security file
# returns 0 if spell should be cast, 1 otherwise
function run_security() {
    debug "build_api/common" "Starting run_security() on $SPELL"
    if    [  -f  $SCRIPT_DIRECTORY/SECURITY  ]; then
      echo -e "${SPELL_COLOR}${SPELL}:${DEFAULT_COLOR}"
      tee -a $SECURITY_LOG < $SCRIPT_DIRECTORY/SECURITY
        if [ `grep critical $SCRIPT_DIRECTORY/SECURITY` ]; then
          if query "${RED}SECURITY CRITICAL:${QUERY_COLOR} Do you still want to cast ${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}?" "n"; then
            return 0
          fi
          return 1
        else
          if query "SECURITY: Do you still want to cast ${SPELL_COLOR} $SPELL ${QUERY_COLOR}?" "y"; then
            return 0
          fi
          return 1
        fi
    fi
    return 0
}


#---------------------------------------------------------------------
## pokes around for a configure or src/configure and if it exists
## asks the user if they want to edit the custom options
#---------------------------------------------------------------------
function run_config_loc () {
  debug "build_api/common" "Starting run_config_loc() on $SPELL"
  if  [ -x ./configure ] || [ -x ./src/configure ] ; then
		
    if  [[  $CONFIG_LOC  == on  ]]; then

      if  [  !  -d  $SM_CONFIG_OPTION_CACHE  ] ; then
        mkdir --parents --mode=0755 $SM_CONFIG_OPTION_CACHE
      fi

      if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ] ; then
        message "${MESSAGE_COLOR}These are your current -- config options for spell ${SPELL_COLOR}$SPELL"
        message "${FILE_COLOR}($SM_CONFIG_OPTION_CACHE/$SPELL)"
        cat $SM_CONFIG_OPTION_CACHE/$SPELL | column
      fi

      if    query  "Do you wish to add -- options to ./configure?"  n ;  then
				F_TMP=/tmp/cast.$$.configure
        rm -f $F_TMP
				
        if [ -x ./configure ]; then
          ./configure --help > $F_TMP
        elif [ -x ./src/configure ]; then
          ./src/configure --help > $F_TMP
        fi

        if [ -f $F_TMP ]; then
          sedit 's/^/# /' $F_TMP
        fi

        cat $SM_CONFIG_OPTION_CACHE/$SPELL >> $F_TMP 2>/dev/null
        edit_file $F_TMP
        rm -f $SM_CONFIG_OPTION_CACHE/$SPELL
        sedit '/^#.*$/d' $F_TMP
        mv $F_TMP $SM_CONFIG_OPTION_CACHE/$SPELL
      fi

      # load custom OPTS
      if  [  -f $SM_CONFIG_OPTION_CACHE/$SPELL  ];  then
        OPTS="$OPTS $(cat $SM_CONFIG_OPTION_CACHE/$SPELL)"
        message "${MESSAGE_COLOR} OPTS= ${DEFAULT_COLOR}$OPTS"
      fi

    fi

  fi
}

#---------------------------------------------------------------------
## Checks for a TRIGGERS file in SCRIPT_DIRECTORY, and if it is
## executable, runs it.
#---------------------------------------------------------------------
function run_triggers() {
  debug "build_api/common" "Starting run_triggers() on $SPELL"

  if    [  -x  $SCRIPT_DIRECTORY/TRIGGERS  ]
  then
    persistent_load
    . $SCRIPT_DIRECTORY/TRIGGERS
    persistent_save
  fi

}




#---------------------------------------------------------------------
## Stuff that should be done if run_build_spell succeeds
## This is intended to be overridable at some point
#---------------------------------------------------------------------
function run_spell_success() {
    debug "build_api/common" "cast of $SPELL-$VERSION was successful"

    sound  SUCCESS

    activity_log  "cast"  "$SPELL"  "$VERSION"  "success"
    add_spell $SPELL installed $VERSION
    echo $SPELL >> $SUCCESS_LIST

    track
    md5list $INST_LOG $MD5_LOG
    archive

    report_install

    rm_source_dir
    rm  -f  $IW_LOG  $TMP_LOG  $CASTING $C_LOG $C_FIFO
}

#---------------------------------------------------------------------
## Stuff that should be done if run_build_spell fails
## This is intended to be overridable at some point
#---------------------------------------------------------------------
function run_spell_failure() {
    debug "build_api/common" "cast of $SPELL-$VERSION failed"

    sound  FAILURE

    activity_log "cast" "$SPELL"  "$VERSION" "failure"
    echo $SPELL >> $FAILED_LIST

    # This may have been locked if there was a failure during the install
    unlock_resources "libgrimoire" "install"

    IW_LOG="$INSTALLWATCHFILE"
    INSTALLWATCHFILE=""
    rm  -f  $IW_LOG  $TMP_LOG  $CASTING $C_LOG $C_FIFO

    [[  $CLEAN_SOURCE == on ]] && rm_source_dir
    CAST_EXIT_STATUS=1
}
