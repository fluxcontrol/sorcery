#!/bin/bash
#---------------------------------------------------------------------
## @Synopsis Functions for dealing with dependencies as a non-cyclic directed graph. Since that's such a mouthful, it will simply be referred to as a tree, even though it's not.
## @Copyright (C) 2002 The Source Mage Team <http://www.sourcemage.org>
## A spell is represented as a node containing some pieces of data
## seperated by colons.
## spell:dependent spell:on/off:type:casting_flag:is_a_target_flag
## @Contributers Chris Brien (christopher_brien@hotmail.com)
## @Contributers Paul Mahon (pmahon@sourcemage.org)
#---------------------------------------------------------------------

#
# conceptual function call tree...perhaps this will enlighten sorcery
# students..
#
# compute_uninstalled_depends (the entry point)
#   -> for each spell (this list grows during processing)
#     -> run PREPARE
#     -> run CONFIGURE
#     -> run DEPENDS
#       -> depends <spell> (external)
#         -> work_depends_spell
#           -> private_common_depends -> libstate.add_depends
#             -> add to NEW_DEPENDS
#             -> libstate.add_depends
#       -> optional_depends <spell> (external)
#         -> work_optional_depends_spell
#           -> query
#           -> private_common_depends -> libstate.add_depends
#             -> add to NEW_DEPENDS
#             -> libstate.add_depends
#       -> depends <provider> (external)
#         -> work_depends_provider
#           -> select provider
#           -> private_common_depends -> libstate.add_depends
#             -> add to NEW_DEPENDS
#             -> libstate.add_depends
#       -> optional_depends <provider> (external)
#         -> work_optional_depends_provider
#           -> select provider
#           -> private_common_depends
#             -> add to NEW_DEPENDS
#             -> libstate.add_depends
#     -> private_add_depends
#       -> update hash tables and lists from NEW_DEPENDS
#
# in other words, for every spell run its external files
# and then deal with their callbacks (depends and optional_depends)
# each of those calls eventually arrives at a dependency rule
# which is stored somewhere through libstate calls , and in an internal
# variable (NEW_DEPENDS). After we finish all the files we bundle up
# our new information and move to the next spell.
#

# Surprise env vars:
# SPELL: this is actually locally defined somewhere up the call stack
#  but from most function's point of view it should be there...
# COMPILE: set in cast. It means that the main spells should be recompiled
# RECONFIGURE: set in cast. I means that the info in the state depends should 
#  be disregarded and replaced.
# PRETEND_NOT_INSTALLED: set here. It is a list of spells that are to be 
#  recompiled, so they should not be treated as installed.
# CAST_HASH: The name of the hast table to put spells and dependencies
#  that are to be cast (only used in this lib)
# BACK_HASH: reverse of CAST_HASH will be used to handle failures
#  more gracefully someday...
# CANNOT_CAST: The name of the hash table to put spells that cannot be cast
#  and the reason why. Usualy because they are exiled or don't exist
#  (only used in this lib)


######################BEGIN CALLS TO OUTSIDE WORLD########################

#---------------------------------------------------------------------
## Run the spell's PREPARE script if it exists
## @param Spell to prepare
## @Globals SCRIPT_DIRECTORY
#---------------------------------------------------------------------
function run_prepare() 
{
  local SPELL=$1

  debug "cast" "run_prepare() - SPELL = $SPELL  SCRIPT_DIRECTORY = $SCRIPT_DIRECTORY"
 
  message  "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
           "${CHECK_COLOR}preparing environment...${DEFAULT_COLOR}"

  if  [  -x  $SCRIPT_DIRECTORY/PREPARE  ];  then
    # we need &&'s to preserve the proper return code (persistant_save
    # will probably succeed even if PREPARE fails)
    persistent_load &&
    . $SCRIPT_DIRECTORY/PREPARE &&
    persistent_save
  fi
  
}

#---------------------------------------------------------------------
## This will be home to all "other" questions we are supposed to ask about
## during this phase of things, right now its a placeholder
## @param Spell
#---------------------------------------------------------------------
function run_other() {
  local SPELL=$1
  # ask the questions about xinetd/initd script installation
  use_xinetd
  use_initd

# todo:
#ask about conflicts
#ask about other stuff

}

#---------------------------------------------------------------------
## Run the spell's CONFIGURE script if it exists
## @param Spell to configure
#---------------------------------------------------------------------
function run_configure() 
{

  local SPELL=$1
  debug "cast" "run_configure() - SCRIPT_DIRECTORY = $SCRIPT_DIRECTORY"

 
  if  [  -x  $SCRIPT_DIRECTORY/CONFIGURE  ];  then
    message  "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
             "${CHECK_COLOR}running configuration...${DEFAULT_COLOR}"
    # we need &&'s to preserve the proper return code (persistant_save
    # will probably succeed even if PREPARE fails)
    persistent_load &&
    . $SCRIPT_DIRECTORY/CONFIGURE &&
    persistent_save
  fi
}

#---------------------------------------------------------------------
## Run a spell's DEPENDS if it exists
## @param Spell
#---------------------------------------------------------------------
function run_depends() 
{ 
  local SPELL=$1
  debug "cast" "run_depends() - SCRIPT_DIRECTORY = $SCRIPT_DIRECTORY"
 
  if  [  -x  $SCRIPT_DIRECTORY/DEPENDS  ];  then
    message  "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
             "${CHECK_COLOR}checking dependencies...${DEFAULT_COLOR}"

    # we need &&'s to preserve the proper return code (persistant_save
    # will probably succeed even if PREPARE fails)
    persistent_load &&
    .  $SCRIPT_DIRECTORY/DEPENDS &&
    persistent_save
  fi
}
######################END CALLS TO OUTSIDE WORLD########################



#---------------------------------------------------------------------
## Create a map of spells to their dependent spells.
## Then for all installed or held spells, output a libhash command to
## join the spell name and dependency info.
## Then evaluate the output, thus filling a libhash with dependency info.
## @param Name of hash table to put dependencies
#---------------------------------------------------------------------
function compute_installed_depends() {
  #$1==hash table to fill
  local hash=$1
  touch $DEPENDS_STATUS $SPELL_STATUS

  # From here forward $1 and $2 are only used to refer to awk variables

  # sub(/(.*)/, "", $2) removes a provider name
  eval $(awk -F : 'BEGIN {
    while (getline < ARGV[1] ) {
      if( $3=="on") {
        sub(/\(.*\)/, "", $2);
        depmap[$1]=depmap[$1]" "$2" "
      }
    }
    while (getline < ARGV[2] ) {
      if( $3=="installed" || $3=="held") {
        printf("hash_put $hash %s \"%s\";\n",$1,depmap[$1]);
      }
    }
  }' $DEPENDS_STATUS $SPELL_STATUS )
}

#---------------------------------------------------------------------
## Create a map of spells to their dependent spells.
## Then for all installed or held spells, output a libhash command to
## join the spell name and dependency info.
## Then evaluate the output, thus filling a libhash with dependency info.
## @param Name of hash table to fill with dependencies
#---------------------------------------------------------------------
function compute_reverse_installed_depends() {
  #$1==hash table to fill
  local hash=$1

  # From here forward $1 and $2 are only used to refer to awk variables

  # sub(/(.*)/, "", $2) removes a provider name
  eval $(awk -F : 'BEGIN {
    while (getline < ARGV[1] ) {
      if( $3=="on") {
        sub(/\(.*\)/, "", $2);
        depmap[$2]=depmap[$2]" "$1" "
      }
    }
    while (getline < ARGV[2] ) {
      if( $3=="installed" || $3=="held") {
        printf("hash_put $hash %s \"%s\";\n",$1,depmap[$1]);
      }
    }
  }' $DEPENDS_STATUS $SPELL_STATUS )
}

#---------------------------------------------------------------------
## calling this will accomplish several things:
## <ol>
## <li> most importantly it finds the closure of all spells that need to
##    be cast
## <li> it builds a hash table mapping spells to their depends, possibly by
##    asking the user for input
## <li> it updates DEPENDS_STATUS, arguably it shouldn't be doing this.
## </ol>
##
## What happens: take all the spells we've been asked to resolve
## for each one of them run its details file
## the details file will call back to depends/optional_depends
## at this point we determine/find/query for depends info
## update the hash table, update DEPENDS_STATUS, and append to the
## list of spells to resolve
##
## @param Hashtable name for dependencies
## @param Hashtable name for spells with problem in resolution (or something)
## @param Hashtable name for spells which cannot cast
#---------------------------------------------------------------------
function compute_uninstalled_depends() 
{ 

  # $1=table to place spells in
  # $2=table to put problem spells in, $* = root spells

  debug "libdepends" "compute_depends of $*"
  local CAST_HASH="$1"
  local BACK_CAST_HASH="$2"
  local CANNOT_CAST_HASH="$3"
  shift 3
  local spell spells
  spells=( $@ )

  PRETEND_NOT_INSTALLED=" $@ "

  local i
  
  # All specified spells are assumed to be not installed, or else -c and -r 
  # would have to be specified all the time.
  
  for (( i=0 ; i<${#spells[*]} ; i++ )) ; do
    if [[ ! `hash_get depends_looked_at ${spells[$i]}` ]]; then
      if ! private_run_depends ${spells[$i]} ; then
        # i dont know if this will work, but it will have to suffice
        private_remove_dependees ${spells[$i]}
      fi
    else
      debug "libdepends" "already looked at ${spells[$i]}, skipping"
   fi
  done
  # we no longer need this, no sense in keeping it around
  hash_unset depends_looked_at

  # we need this so processes on the other side of make know whats
  # going on
  hash_export uncommitted_hash
}

#---------------------------------------------------------------------
## A private function for running a spell's DEPENDS script.
## No functions except libdepends functions should use this.
## @param Spell
#---------------------------------------------------------------------
function private_run_depends()
{
  debug "libdepends" "$FUNCNAME - $*"
  local SPELL=$1
  local NEW_DEPENDS=""
  local spell_depends
  hash_put "depends_looked_at" "$SPELL" "start"

  
  # We only need to run the stuff if we are going to be casting.
  # It only needs to be added to the casting hash table if we are
  # really casting it
  if private_should_cast $SPELL ; then
    # this cant go in private_should_cast because then the dependee wont
    # have a chance at being fixed, ideally we should check in 
    # depends/optional_depends and fail there
    if spell_exiled $1; then
      message  "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
               "${CHECK_COLOR}is exiled and will not be cast.${DEFAULT_COLOR}"
      return 1
    fi
    get_uncommitted_depends_file $SPELL spell_depends
    if  [  -n  "$RECONFIGURE"  ];  then
      rm  -f  $DEPENDS_CONFIG/$SPELL
    fi
    prepare_spell_config
    SCRIPT_DIRECTORY=`codex_find_spell_by_name $SPELL`
    run_prepare $SPELL            &&
    run_details                   &&
    run_configure $SPELL          &&
    run_other $SPELL              &&
    run_depends $SPELL            && 
    # possibly recast things that depend on us if option is set (-B)
    private_upward_depends $SPELL &&
    private_add_depends           ||
    { debug "libdepends" "$FUNCNAME: false inside if." ; return 1; }
    # no point in keeping the file around if its empty...
    test -s $spell_depends || rm $spell_depends
  else 
    message  "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
             "${CHECK_COLOR}No work to do.${DEFAULT_COLOR}"
    hash_put "depends_looked_at" "$SPELL" "ignore"
  fi

  # if there weren't any depends no sense in keeping the file around
  return 0
}

#---------------------------------------------------------------------
## Decides if a spell should be case. Check if the spell is installed
## if it matters, etc...
## Perhaps this function is overly splayed out in elif's but its
## easier to add to later than what we had before...
## @param Spell
#---------------------------------------------------------------------
function private_should_cast()
{
  local decision
  # order is important here...
  if ! codex_does_spell_exist $1; then
    return 1
  elif echo "$PRETEND_NOT_INSTALLED" | grep -q " $1 " ; then
    # always look at stuff on the command line unless its exiled
    return 0
  # from here on the spell was not on the command line...
  elif spell_held $1;  then
    # don't recast held even with -R
    return 1
  elif [[ "$RECAST_DOWN" ]] ; then
    # user gave -R so recast...
    return 0
  elif echo "$UP_DEPENDS" | grep -q " $1 " ; then
    # if someone has determined this is an upward depend (-B)
    return 0
  elif spell_installed $1 ; then
    # spell is installed and no -R or -B, so dont cast
    return 1
  fi
  
  # we must need to install this as we know nothing else about it
  return 0
}

#---------------------------------------------------------------------
## @param Spell name
## Find all the spells that depend on the spell given as $1
#---------------------------------------------------------------------
function private_upward_depends() {
  if [[ "$RECAST_UP" ]] ; then
    local tmp
    tmp=$(search_depends_status $DEPENDS_STATUS '.*' "$1"|cut -f1 -d:|tr "\n" " ")
    local j each
    let j=0
    for each in $tmp; do
      UP_DEPENDS[$j]=$each
      let j++
    done
    spells=( $spells[*] $UP_DEPENDS[*] )
  fi
}

###################BEGIN CALLBACKS FROM OUTSIDE#######################

#---------------------------------------------------------------------
## @param  spell or provider name
## @param  addition to OPTS
## @param  description
## Delegates provider and spell cases to different worker functions.
#---------------------------------------------------------------------
function real_depends()
{
  if ! codex_does_spell_exist $1 &> /dev/null; then
    work_depends_provider "$@"
  else
    work_depends_spell "$@"
  fi

}

#---------------------------------------------------------------------
## @param  spell or provider name
## @param  addition to OPTS if enabled
## @param  addition to OPTS if disabled
## @param  description
## Delegates provider and spell cases to different worker functions.
#---------------------------------------------------------------------
function real_optional_depends()
{

  if ! codex_does_spell_exist $1 &> /dev/null; then
    work_optional_depends_provider "$@"
  else
    work_optional_depends_spell "$@" 
  fi

}

#---------------------------------------------------------------------
## Asks the user what provider for a depends is desired if a choice
## has not ben made before.
## @param Service
#---------------------------------------------------------------------
function work_depends_provider()
{

  debug "libdepends" "$FUNCNAME - $@"
  local default tmp installed=no
  local status=()

  if [[ $4 ]] ; then
    message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
            "${CHECK_COLOR}requires some${DEFAULT_COLOR}" \
            "${SPELL_COLOR}${1}${DEFAULT_COLOR} (for $4)."
  else
    message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
            "${CHECK_COLOR}requires some${DEFAULT_COLOR}" \
            "${SPELL_COLOR}${1}${DEFAULT_COLOR}."
  fi
  
  local CANDIDATES=$( find_providers $1)
  if [[ ! $CANDIDATES ]] ; then
    message "${PROBLEM_COLOR}No providers of${DEFAULT_COLOR}" \
            "${SPELL_COLOR}$1${DEFAULT_COLOR}" \
            "${PROBLEM_COLOR} can be found!${DEFAULT_COLOR}"
    return 1
  fi

  # if not reconfiguring check if theres already an answer in DEPENDS_STATUS
  if [[ ! $RECONFIGURE ]]; then
    # notice the clever ignorance of optional/required depends for the
    # provider case, if the user chose none, we would fall out during spell_ok
    # and we transparently switch between optional and required without
    # anyone noticing
    explode "$(search_depends_status $DEPENDS_STATUS "$SPELL" ".*($1)")" ":" "status"
    local tmp=${status[1]%(*}    # Name of spell which provides $1
    if spell_ok $tmp &&
       query "Continue to use ${SPELL_COLOR}$tmp${DEFAULT_COLOR}?" y; then
      private_common_depends "$tmp($1)" "on" "required" "$2" "$3"
      return 0
    fi
  fi

  # check if theres an abandoned answer, but only if its still a provider
  if [[ ! $default ]] && [ -e $ABANDONED_DEPENDS/$SPELL ] ; then
    tmp=$(search_depends_status $ABANDONED_DEPENDS/$SPELL "$SPELL" ".*($1)"|awk -F: '{print $2;exit}')
    [[ $tmp ]] && echo $CANDIDATES|grep -q "\<$tmp\>" && default=$tmp
  fi

  # check if theres a default provider
  if [[ ! $default ]]; then
    explode "$(search_default_provider $DEFAULT_PROVIDERS "" "$1")" ":" "status"
    tmp=${status[0]}
    [[ $tmp ]] && echo $CANDIDATES|grep -q "\<$tmp\>" && default=$tmp
  fi

  # check if we've already answered this question
  if [[ ! $default ]]; then
    for tmp in $CANDIDATES; do
      echo $spells | grep -q "\<$tmp\>" && default=$tmp && break
    done
  fi

  # check if theres a provider already installed
  if [[ ! $default ]]; then
    for tmp in $CANDIDATES; do
      spell_ok $tmp && default=$tmp && break
    done
  fi

  select_provider "provider" "$default" 0 $CANDIDATES

  private_common_depends "$provider($1)" "on" "required" "$2" "$3"
}

#---------------------------------------------------------------------
## One of the worker functions. Checks for exiled spell and passes
## on to the common dependency function, <@function private_common_depends>
## @param Spell
#---------------------------------------------------------------------
function work_depends_spell()
{

  debug "libdepends" "$FUNCNAME - $@"

  message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
          "${CHECK_COLOR}depends on" \
          "${SPELL_COLOR}${1}${DEFAULT_COLOR}"

  if spell_exiled $1 ; then
    hash_put $CANNOT_CAST_HASH "$1" "Exiled"
    message "${SPELL_COLOR}${1}${DEFAULT_COLOR} has been exiled!"
    return 1
  fi
  private_common_depends "$1" "on" "required" "$2" "$3"

}

#---------------------------------------------------------------------
## @param  provider name
## @param  addition to OPTS if enabled
## @param  addition to OPTS if disabled
## @param  description
## Handles optional dependency on a provider.
#---------------------------------------------------------------------
function work_optional_depends_provider()
{

  debug "libdepends" "$FUNCNAME - $@"
  local default tmp installed=no
  local status=()

  if [[ $4 ]] ; then
    message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
            "${CHECK_COLOR}optionally requires some${DEFAULT_COLOR}" \
            "${SPELL_COLOR}${1}${DEFAULT_COLOR} (for $4)."
  else
    message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
            "${CHECK_COLOR}optionally requires some${DEFAULT_COLOR}" \
            "${SPELL_COLOR}${1}${DEFAULT_COLOR}."
  fi
  
  local CANDIDATES=$( find_providers $1)
  # if not reconfiguring check if theres already an answer in DEPENDS_STATUS
  if [[ ! $RECONFIGURE ]]; then
    explode "$(search_depends_status $DEPENDS_STATUS "$SPELL" ".*($1)")" ":" "status"
    local tmp=${status[1]%(*}    # Name of spell which provides $1
    if spell_ok $tmp &&
          query "Continue to use ${SPELL_COLOR}$tmp${DEFAULT_COLOR}?" y; then
      private_common_depends "$tmp($1)" "on" "required" "$2" "$3"
      return 0
    fi
  fi

  # check if theres an abandoned answer, but only if its still a provider
  if [[ ! $default ]] && [ -e $ABANDONED_DEPENDS/$SPELL ] ; then
    tmp=$(search_depends_status $ABANDONED_DEPENDS/$SPELL "$SPELL" ".*($1)"|awk -F: '{print $2;exit}')
    [[ $tmp ]] && echo $CANDIDATES|grep -q "\<$tmp\>" && default=$tmp
  fi

  # check if theres a default provider
  if [[ ! $default ]]; then
    explode "$(search_default_provider $DEFAULT_PROVIDERS "" "$1")" ":" "status"
    tmp=${status[0]}
    if [[ ${status[2]} == on ]] ; then
      # if the user said "on" use the default rather than none
      # unless theres something wrong with the provider they chose 
      # in which case fall back to none
      [[ $tmp ]] && echo $CANDIDATES|grep -q "\<$tmp\>" &&
      default=$tmp || default=none
    else
      default=none
    fi
  fi

  # check if we've already answered this question
  if [[ ! $default ]]; then
    for tmp in $CANDIDATES; do
      echo $spells | grep -q "\<$tmp\>" && default=$tmp && break
    done
  fi

  # check if theres a provider already installed
  if [[ ! $default ]]; then
    for tmp in $CANDIDATES; do
      spell_ok $tmp && default=$tmp && break
    done
  fi

  select_provider "provider" "$default" 1 $CANDIDATES

  if [ $provider == "none" ] ; then
    private_common_depends "($1)" "off" "optional" "$2" "$3"
  else
    private_common_depends "$provider($1)" "on" "optional" "$2" "$3"
  fi

}

#---------------------------------------------------------------------
## @param  spell name
## @param  addition to OPTS if enabled
## @param  addition to OPTS if disabled
## @param  description
## Handles optional dependency on a spell.
#---------------------------------------------------------------------
function work_optional_depends_spell()
{

  debug "libdepends" "$FUNCNAME - $@"
  
  # if $1 optionally depends on something exiled we always say no
  if spell_exiled $1 ; then 
    message "${SPELL_COLOR}${1}${DEFAULT_COLOR} has been exiled! not using as a depends"
    hash_put $CANNOT_CAST_HASH "$1" "Exiled"
    private_common_depends "$1" "off" "optional" "$2" "$3"
    return 0
  fi
  
  
  if [[ ! $RECONFIGURE ]] ; then
    # See if there are preferences already in DEPENDS_STATUS, but only if 
    # not reconfiguring...
    # example: icewm:imlib:off:optional:--with-imlib:--with-xpm
    local status=()
    explode "$(search_depends_status $DEPENDS_STATUS "$SPELL" "$1")" ":" "status"
    if [[ ${status[2]} ]] ; then
      # ah there are! use them
      message "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
              "${CHECK_COLOR}optionally depends on" \
              "${SPELL_COLOR}${1}${DEFAULT_COLOR}"
      private_common_depends "$1" "${status[2]}" "optional" "$2" "$3"
      return 0
    fi
  fi

  # check for abandoned answers
  if [ -e $ABANDONED_DEPENDS/$SPELL ] ; then
    debug "libdepends" "Checking in abandoned depends"
    default=$(search_depends_status $ABANDONED_DEPENDS/$SPELL "$SPELL" "$1"|awk -F: '{print $3;exit}')
  fi

  # check the defaults file...
  # first for explicit $SPELL -> $2
  if [[ ! $default ]]; then
    debug "libdepends" "Checking in default answers"
              search_default_depends $DEFAULT_DEPENDS $SPELL $1
    default=$(search_default_depends $DEFAULT_DEPENDS $SPELL $1|awk -F: '{print $3; exit}')
  fi

  # then for anything -> $2
  if [[ ! $default ]]; then
    debug "libdepends" "Checking in default answers"
    default=$(search_default_depends $DEFAULT_DEPENDS ".*" $1|awk -F: '{print $3; exit}')
  fi

  # then for $1 -> anything
  if [[ ! $default ]]; then
    debug "libdepends" "Checking in default answers"
    default=$(search_default_depends $DEFAULT_DEPENDS $SPELL |awk -F: '{print $3; exit}')
  fi

  # check the install queue
  if [[ ! $default ]]; then
    debug "libdepends" "Checking in queue"
    #\< and \> match the empty string at the start and end of a word
    echo $spells | grep -q "\<$1\>" && default=on
  fi

  # check if installed/held
  if [[ ! $default ]]; then
    debug "libdepends" "Checking if already installed"
    spell_ok $1 && default=on
  fi

  # otherwise default to no
  [[ ! $default ]] && default=off

  local install=off

  local stuff
  [[ $default == off ]] && stuff=n || stuff=y

  message "${SPELL_COLOR}${1}${DEFAULT_COLOR}" \
          "is an optional dependency for" \
          "${SPELL_COLOR}$SPELL${DEFAULT_COLOR} ($4)"

  if spell_ok $1 ; then
     query "Do you want to use ${SPELL_COLOR}$1${DEFAULT_COLOR}?" "$stuff" && 
          install="on"
  else
    query "Do you want to cast ${SPELL_COLOR}$1${DEFAULT_COLOR}?" "$stuff" && 
        install="on"
  fi

  private_common_depends "$1" "$install" "optional" "$2" "$3"
}


#---------------------------------------------------------------------
## @param  name of return variable
## @param  default answer
## @param  0 if required 1 if optional
## @param  list of possible providers
## Present a list to the user complete with info about whats installed
## and what isnt and allow a default value to be used
#---------------------------------------------------------------------
function select_provider()
{
    local returnvar=$1
    local default=$2
    local optional=$3
    shift 3

    local each default_char=0 stuff=()
    local char answer spell

    # we can only read one character so use every one we can, I dont expect
    # there to be more than 62 providers

    # in bash 3.0 this expands to all the numbers and letters
    # stuff=({0..9} {a..z} {A..Z})
    # but we're still on bash 2 which cant do that, if someone
    # knows a better way to do this please tell me
    stuff=(0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)

    if [ $optional == 1 ] ; then
      hash_put CHAR_TO_SPELL 0 "none"
      let i=1
      message "\t${DEFAULT_COLOR}(0)\t${SPELL_COLOR}[none]${DEFAULT_COLOR}"
    else
      let i=0
    fi

    for each in $@; do
      char=${stuff[$i]}
      hash_put CHAR_TO_SPELL $char $each
      
      [[ $each == $default ]] && default_char=$char
      if spell_ok $each ; then
        message "\t${DEFAULT_COLOR}($char)\t${SPELL_COLOR}$each${DEFAULT_COLOR}\t (installed)"
      else
        message "\t${DEFAULT_COLOR}($char)\t${SPELL_COLOR}$each${DEFAULT_COLOR}"
      fi
      let i++
    done

    message -n "\n${QUERY_COLOR}Which one do you want? " \
               "[$default_char]$DEFAULT_COLOR "
    read   -t  $PROMPT_DELAY  -n  1 answer 
    [[ $answer ]] || answer=$default_char
    spell="$(hash_get CHAR_TO_SPELL $answer)"

    while [[ ! $spell ]] ; do
      message -n "\n${QUERY_COLOR}Which one do you want? " \
                 "[$default_char]$DEFAULT_COLOR "
      read   -t  $PROMPT_DELAY  -n  1 answer 
      [[ $answer ]] || answer=$default_char
      spell=$(hash_get CHAR_TO_SPELL $answer)
    done
    echo
    hash_unset CHAR_TO_SPELL
    eval $returnvar=\"$spell\"
}

#---------------------------------------------------------------------
## all the depends callbacks eventually bottom out here
## if a spell depends or doesnt depend on some other spell
## @param Spell
## @param on/off 
#---------------------------------------------------------------------
function private_common_depends()
{
  debug "libdepends" "$FUNCNAME - $@"
  add_depends $spell_depends "$SPELL" "$@"
  
  if [[ $2 == on ]] ; then
    # ${1%(*} = spell name (strips potential provider name)
    local spell_name=${1%(*}
    NEW_DEPENDS=( ${NEW_DEPENDS[*]} $spell_name )
  fi
  
  return 0
}

#---------------------------------------------------------------------
## Adds the dependency to the hastable 
#---------------------------------------------------------------------
function private_add_depends()
{
  debug "libdepends" "$FUNCNAME: SPELL=$SPELL, NEW_DEPENDS=${NEW_DEPENDS[*]}"
  hash_put "$CAST_HASH" "$SPELL" "${NEW_DEPENDS[*]}"
  for child in ${NEW_DEPENDS[*]}; do
    hash_append "$BACK_CAST_HASH" "$child" "$SPELL"
  done
  
  spells=( ${spells[*]} ${NEW_DEPENDS[*]} )

  hash_put "depends_looked_at" "$SPELL" "done"

}


#########################BEGIN OTHER STUFF############################

#---------------------------------------------------------------------
## Removes a dependency from the list.
#---------------------------------------------------------------------
function private_remove_dependees()
{
	local SPELL=$1
        local i
	echo "Removing dependees of $1"

	# spell is being removed from cast list, add to FAILED_LIST
	echo "$SPELL" >> $FAILED_LIST
        hash_put depends_looked_at $SPELL failed
        hash_unset "$CAST_HASH" "$SPELL"
        hash_put $CANNOT_CAST_HASH "$SPELL" "Failed"
}

#---------------------------------------------------------------------
## Sets a spell's aux. config info.
## @Globals SPELL 
#---------------------------------------------------------------------
function run_spell_config() 
{

  SPELL_CONFIG=$DEPENDS_CONFIG/$SPELL
  debug "libdepends" "run_spell_config() - DEPENDS_CONFIG=$DEPENDS_CONFIG SPELL=$SPELL, SPELL_CONFIG=$SPELL_CONFIG DEPENDS_STATUS=$DEPENDS_STATUS" 
    
  if  [  -x  $SPELL_CONFIG  ];  then
    debug "libdepends" "run_spell_config() - found $SPELL_CONFIG"
	.  $SPELL_CONFIG
  fi
}

#---------------------------------------------------------------------
# i dont know if this should be here
#---------------------------------------------------------------------
function show_depends()  
{
  debug "libdepends" "show_depends() - $@"
  local DEP_SPELL=`esc_str $1`
  local DEPTH=$2

  if  !  echo  "$DONE"  |  grep  -q  "$DEP_SPELL";  then
    DONE="$DONE  $1"

    function ld99()  {

     [[ $MAX_DEPTH ]] && [[ $DEPTH -ge $MAX_DEPTH ]] && return 1
 
      SPELL=`echo  $1 |  cut  -d :  -f1`
      STATUS=`echo  $1  |  cut  -d :  -f3`

      if    [  "$STATUS"  ==  "on"  ]; then
        echo          $1 
        show_depends  $SPELL $(( DEPTH + 1 ))
      fi
      
    }
    
    iterate "ld99" $'\n' `grep  ":$DEP_SPELL:"  $DEPENDS_STATUS`

  fi
}

#---------------------------------------------------------------------
# this needs to go away :-/
#---------------------------------------------------------------------
function satisfy_depends()
{

  debug "libdepends" "Running satisfy_depends() on $SPELL"  
  local DEP
 
  unset  OPTS

  # some spells apply changes to OPTS directly
  run_spell_config

  local LINE=''
  search_depends_status $DEPENDS_STATUS "$SPELL" | while read LINE; do

    debug "libdepends" "satisfy_depends() - $LINE"

    # line format is:
    #  spell:dependency(provider):status:something:on-opts:off=opts
    DEP=()
    explode "$LINE" ":" "DEP"
    DEP[1]=${DEP[1]%(*}   # Strip possible provider name

    # If dependency name is "" then don't bother with the rest of this loop.
    if [[ ! ${DEP[1]} ]] ; then
      continue
    fi

    # First, see if the spell exists.
    DEP_SPELL_LOCATION=`codex_find_spell_by_name ${DEP[1]}`
    if  [  -z  "$DEP_SPELL_LOCATION"  ];  then
      message  "${PROBLEM_COLOR}Unable to find previously configured"  \
               "dependency ${SPELL_COLOR}'${DEP[1]}'${PROBLEM_COLOR}"
      message  "in grimoire.  Removing spell from cached depends."     \
               "${DEFAULT_COLOR}"
      remove_depends_status  "$SPELL"  "${DEP[1]}"
    else

      #Second, am I trying to cast --fix or is this just a normal cast?
      if  [[  $FIX  ]] ; then
      
	#Third, if it's a fix, and the dependency is on, cast --fix it
        if  [[ ${DEP[2]} == on ]] 
	then  debug "libdepends" "cast  $FIX  ${DEP[1]}" && cast  $FIX  ${DEP[1]}
	else debug "libdepends" "Fix=$FIX, and DEP[2]=${DEP[2]}"
        fi

      #(second) It's a normal cast, and this may need to be cast
      elif  [[  ${DEP[2]}  ==  on  ]]; then
        #
        # Spell must be installed or help up to this point (this is a guard fence)
        #
        if  !  spell_installed  ${DEP[1]}  &&
            !  spell_held       ${DEP[1]}
        then
          message "One of the dependencies of ${DEP[0]} failed to cast."
          message "You should try to cast ${DEP[1]} manualy."
          message "Failed to cast ${DEP[1]}. I will have trouble casting ${DEP[0]}."
          return 1          
        fi
        #
        # End of guard fence
        #
      fi
    fi

  done

  #
  # TODO: Do something about exiled spells so that they've got `off'
  #       in DEPENDS_STATUS file, or something else do improve this
  #
  local OPTS_DEPENDS=$(get_depends_options $DEPENDS_STATUS "$SPELL")
  OPTS="$OPTS $OPTS_DEPENDS"
  debug 'libdepends' "satisfy_depends() - final OPTS=$OPTS"
}

#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
