#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
## Functions for dealing with dependencies as a non-cyclic directed
## graph. Since that's such a mouthful, it will simply be referred to
## as a tree, even though it's not.
##
##=head1 DESCRIPTION
##
## A spell is represented as a node containing some pieces of data
## seperated by colons.
## :spellname:casting_flag:is_a_target_flag:
##
##=head1 COPYRIGHT
##
## Copyright (C) 2002 The Source Mage Team <http://www.sourcemage.org>
##
##=head1 CONTRIBUTORS
## Chris Brien <christopher_brien@hotmail.com>
## Paul Mahon <pmahon@sourcemage.org)
##
##=head1 FUNCTIONS
#---------------------------------------------------------------------

# Surprise env vars:
# COMPILE: set in cast. It means that the main spells should be recompiled
# RECONFIGURE: set in cast. I means that the info in the state depends should 
#  be disregarded and replaced.
# LAST_SPELL: set in here. It is for the recursive dependency checking. It is
#  set to the parent spell.
# PRETEND_NOT_INSTALLED: set here. It is a list of spells that are to be 
#  recompiled, so they should not be treated as installed.

function run_prepare() {

  SCRIPT_DIRECTORY=`codex_find_spell_by_name $SPELL`
  debug "cast" "run_prepare() - SCRIPT_DIRECTORY = $SCRIPT_DIRECTORY"
 
  if  [  -n  "$RECONFIGURE"  ];  then
    rm  -f  $DEPENDS_CONFIG/$SPELL
    remove_depends_status  $SPELL
  fi

  prepare_spell_config
# Should this be here? It causes the questions to be asked twice - Chris 20030123
#  use_xinetd
#  use_initd

  if  [  -x  $SCRIPT_DIRECTORY/PREPARE  ];  then
    . $SCRIPT_DIRECTORY/PREPARE
  fi

}


function run_depends()
{ #SPELL=SPELL
 
  if  [  -x  $SCRIPT_DIRECTORY/DEPENDS  ];  then

    message  "${CHECK_COLOR}Checking dependencies for"  \
               "${SPELL_COLOR}${SPELL}"                   \
               "${DEFAULT_COLOR}"

      .  $SCRIPT_DIRECTORY/DEPENDS

    fi

}


function run_configure() {

  SCRIPT_DIRECTORY=`codex_find_spell_by_name $SPELL`
  debug "cast" "run_configure() - SCRIPT_DIRECTORY = $SCRIPT_DIRECTORY"
 
  if  [  -n  "$RECONFIGURE"  ];  then
    rm  -f  $DEPENDS_CONFIG/$SPELL
    remove_depends_status  $SPELL
  fi

  prepare_spell_config
  use_xinetd
  use_initd

  if  [  -x  $SCRIPT_DIRECTORY/CONFIGURE  ];  then
    . $SCRIPT_DIRECTORY/CONFIGURE
  fi

}


function show_depends()  {
  debug "libdepends" "show_depends() - $@"
  local DEP_SPELL=`esc_str $1`

  if  !  echo  "$DONE"  |  grep  -q  "$DEP_SPELL";  then
    DONE="$DONE  $1"

    function ld99()  {
      
      SPELL=`echo  $1 |  cut  -d :  -f1`
      STATUS=`echo  $1  |  cut  -d :  -f3`

      if    [  "$STATUS"  ==  "on"  ]; then
        echo          $1
        show_depends  $1
      fi
      
    }
    
    iterate "ld99" $'\n' `grep  ":$DEP_SPELL:"  $DEPENDS_STATUS`

  fi

}

function private_run_depends()
{   #1=spell
  
  SPELL=$1
  run_prepare    &&
  run_details    &&
  run_configure  &&
  run_depends $1
  
}

function build_depends()
{

  echo "Bad. Deprecated."

}


function spell_to_node()
{ #1=spell

  hash_get "spell_to_node" "$1"

}

function node_to_spell()
{ #1=node

  hash_get "node_to_spell" "$1"

}

function all_spells_added()
{

  hash_get_table "node_to_spell"

}

function all_spells_to_install()
{
  debug "libdepends" "all_spells_to_install($*)"
  local allConnections allSpells
  local i
  
  #Reminder, this next line needs the \<newline> to work properly. Ooops.
  allConnections=$(hash_get_table_fields "GRAPHS" | sed -n 's/\([[:digit:]]*\)_to_\([[:digit:]]*\).*$/\1\
\2/p' | sort -n | uniq)
  allSpells=$(hash_get_table "spell_to_node")
debug "DB" "allConnections=$allConnections"
debug "DB" "allSpells=$allSpells"
  for i in $* ; do
    allSpells="$allSpells"$'\n'`spell_to_node $i`
  done

  debug "libdepends" "all_spells_to_install() - $*"
  
  function ld172()  {
  
    debug "libdepends" "looking at spell $1"
    
    if ( [[ $(graph_node_data $1) != installed ]] ||
      echo "$PRETEND_NOT_INSTALLED" | grep -q " `node_to_spell $1` "  ) 
    then
      node_to_spell $1
    else
      debug "libdepends" "$1 is not in PRETEND_NOT_INSTALLED list and is installed"
    fi
  
  }
  iterate "ld172" $'\n' `echo -e "${allConnections}\n${allSpells}" | sort -n | uniq -d`

}

function is_looked_at()
{ #1=spell

  if [[ `spell_to_node $1` ]] ; then
    return 0
  else
    return 1
  fi

}

function depends()
{ #1=spell, 2=on args, 3=off args
  debug "libdepends" "depends - $*"
  local node=""

  #If it's exiled, 
  if spell_exiled $1       ; then 
    message "${SPELL_COLOR}$1${DEFAULT_COLOR} is exiled."
    [[ $LAST_SPELL ]] && message "${SPELL_COLOR}$1${DEFAULT_COLOR} is required for ${SPELL_COLOR}$LAST_SPELL${DEFAULT_COLOR}."
    return 1
  fi
  
  depends_recurse "$1" "$2" "$3" "required" "absolutely"
  
  # Make sure this node is marked as required
  if [ "$( graph_node_data $(spell_to_node $1) )" = "optional" ] ; then
    graph_node_modify_data $(spell_to_node $1) "required"
  fi
  

}


function optional_depends()
{ #1=spell
  debug "libdepends" "optional_depends() - $@"
  
  local install="SureWhyNot"
  local status=()

  # If it's installed, no need to do anything
#  if spell_installed $1 || spell_held $1 ; then return 0 ; fi
  #If it's exiled, 
  if spell_exiled "$1"       ; then 
    message "${SPELL_COLOR}$1${DEFAULT_COLOR} is exiled."
    [[ $LAST_SPELL ]] && message "${SPELL_COLOR}$1${DEFAULT_COLOR} is optional for ${SPELL_COLOR}$LAST_SPELL${DEFAULT_COLOR}."
    return 0
  fi
  
  # If this node isn't being used yet:  
  if ! is_looked_at "$1"                                          ||
     ! [[ $( graph_node_connections_to $(spell_to_node "$1") ) ]] &&
     ! ( spell_installed "$1" || spell_held "$1" )
  then
      #See if there are preferences already
      #example: icewm:imlib:off:optional:--with-imlib:--with-xpm
      explode `search_depends_status "$LAST_SPELL" "$1"` ":" "status"
      if [[ ${status[2]} == off ]] && ! [[ $RECONFIGURE ]] ; then
        install=""
      elif [[ $RECONFIGURE ]] || ! [[ ${status[2]} ]] ; then
        message "${SPELL_COLOR}$1${DEFAULT_COLOR} is an optional dependency for ${SPELL_COLOR}$LAST_SPELL${DEFAULT_COLOR} ($4)"
        query "Do you want to cast ${SPELL_COLOR}$1${DEFAULT_COLOR}?" "n" || 
	  install=""      
      fi
  fi
   
  depends_recurse "$1" "$2" "$3" "optional" $install
  
}

#---------------------------------------------------------------------
##=item requires <"provides" specification>
##
## Given a category of spell, returns true if a spell is installed
## that provides that category of spell.  For example,
## C<requires email-client> returns true if evolution is installed.
##
#---------------------------------------------------------------------
requires()  { 

  local CANDIDATES SATISFIED CANDIDATE 
  local temp

  CANDIDATES=$(  find_providers  $1  )

  for   CANDIDATE  in       $CANDIDATES;  do
    if ! spell_exiled  $CANDIDATE ; then
      temp="$temp"$'\n'"$CANDIDATE"
    fi
  done
  CANDIDATES="$temp"

  for  CANDIDATE  in       $CANDIDATES;  do
    if    spell_installed  $CANDIDATE  ||
          spell_held       $CANDIDATE
    then  
          return 0;
    fi
  done

  message  "${QUERY_COLOR}This spell requires a"  \
           "${MESSAGE_COLOR}$1${DEFAULT_COLOR}"   \
           "which can be provided by:"
  message  "${FILE_COLOR}$CANDIDATES${DEFAULT_COLOR}"

  SATISFIED="false"
  for  CANDIDATE  in  $CANDIDATES;  do
    if    query "Cast ${SPELL_COLOR}$CANDIDATE${DEFAULT_COLOR}? " "y"  && 
          depends  $CANDIDATE
    then  SATISFIED="true";  break
    else
          message "Didn't cast ${SPELL_COLOR}$CANDIDATE${DEFAULT_COLOR}."
    fi
  done

  $SATISFIED

}

function depends_recurse()
{ #1=spell, 2=on-opts, 3=off-opts, 4=type, 5=connect or not?

  debug "libdepends" "depends_recurse - $*"
  local parent=()
  local node=""
  local was_not_needed=""  is_new_node=""
  local connect="$5"

  #Does the spell even exist??
  if ! [[ `codex_get_spell_section $1` ]] ; then
    message "${PROBLEM_COLOR}I was unable to find spell ${SPELL_COLOR}$1${DEFAULT_COLOR}"
    return 1
  fi

  # Only make a new node for this spell if it doesn't already have one
  if ! is_looked_at $1 ; then
    graph_new_node "$4" "node" 
    hash_put "spell_to_node" "$1" "$node"
    hash_put "node_to_spell" "$node" "$1"
    is_new_node="yes"
  else
    node=`spell_to_node $1`  
  fi
  
  is_already_needed=$( graph_node_connections_to $node )
  
  if [[ $LAST_SPELL ]] ; then
    debug "libdepends" "depends_recurse, I think that $LAST_SPELL($LAST_NODE) is my parent."
    parent[0]=$LAST_SPELL
    parent[1]=$LAST_NODE
    [[ $connect ]] && graph_connect_node ${parent[1]} $node

    hash_put "${LAST_SPELL}-depends" "${1}-on"   "$2"
    hash_put "${LAST_SPELL}-depends" "${1}-off"  "$3"
    hash_put "${LAST_SPELL}-depends" "${1}-type" "$4"
  fi
  
  # We only need to recurse if this node has been looked at and has at least one connection
  #  A spell's depends aren't checked until the spell is actualy a dependency. It's node is
  #   always created though, even if it's an unwanted optional_depends.
  if ( ! [[ $is_new_node ]] && [[ $is_already_needed ]] ) || ! [[ $connect ]] ; then
    return 0 
  fi

  # Set the last spell info for the dependencies of me
  LAST_SPELL=$1
  LAST_NODE=$node

  # do the depends of me
  if ( spell_installed $1                               && 
       echo "$PRETEND_NOT_INSTALLED" | grep -qv " $1 " ) ||
     spell_held $1
  then 
    debug "libdepends" "$1 is installed and not in [$PRETEND_NOT_INSTALLED]"
    graph_node_modify_data $node "installed"
  else
    private_run_depends $1 || return 1
  fi

  # Reset the last spell info for the next depends of my parent
  LAST_SPELL=${parent[0]}
  LAST_NODE=${parent[1]}

}


# This assumes that the graph has been constructed already
function list_required_depends()
{ #1=some spell
  local rootNode=`spell_to_node $1`
  local wholeGraph=`graph_all_downstream $rootNode`
  
  for node in $wholeGraph ; do
     [ `graph_node_data $node` == required ] && node_to_spell $node  
  done  

}

# This assumes that the graph has been constructed already
function list_optional_depends()
{ #1=some spell
  local rootNode=`spell_to_node $1`
  local wholeGraph=`graph_all_downstream $rootNode`
  
  for node in $wholeGraph ; do
     [ `graph_node_data $node` == optional ] && node_to_spell $node  
  done  

}

function remove_selected_depends()
{

  local rmSpells newRmSpells
  local spellList=()
  spellList=( $MAIN_SPELLS )

  read rmSpells
  
  message -n "Computing parents... "
  for spell in $rmSpells ; do
      node=`spell_to_node $spell`
      tempList=${tempList}$(graph_all_upstream $node)$'\n'
  done
    rmSpells=$(echo "$tempList" |sort | uniq)
    message "done"
  
    message "Removing spells... "
    # Remove spells from the parameters passed
  for (( i=0 ; i<${#spellList[*]} ; i++ )) ; do
      for j in $rmSpells ; do
        [[ `node_to_spell $j` == ${spellList[$i]} ]]  &&  spellList[$i]=""
      done
  done
  spellList=( ${spellList[*]} )
  
  if [ ${#spellList[*]} -lt 1 ] ; then
      MAIN_SPELLS=""
      return 1
  fi  

  # Actualy remove the spells from the graph now
  while [[ $rmSpells ]] ; do
    newRmSpells=""
    for i in $rmSpells ; do
      spell=`node_to_spell $i`
      tempList=`graph_node_connections_from $i`

      #Now that we have the node's children we can remove it
      message "\tNot casting ${SPELL_COLOR}"$spell"${DEFAULT_COLOR}."
      graph_unset_node "$i"
      hash_unset "spell_to_node" "$spell"
      hash_unset "node_to_spell" "$i"
      hash_reset "${spell}-depends"

      for j in $tempList ; do
        if ! [[ `graph_node_connections_to $j` ]] ; then
          newRmSpells="${newRmSpells} $j"
        fi
      done
      
    done
    rmSpells="${newRmSpells:1}"
  done
  message "done"
  
  MAIN_SPELLS="${spellList[*]}"

}

# This assumes that the graph has been constructed already
function confer_with_user_on_depends()
{ # $1=var to put final spells into, $* is list of spells to cast

  local spellList
  local node tempList 
  local i j
  
  SPELLS=${SPELLS:-$*}
  MAIN_SPELLS="$SPELLS"

  unset SPELL
  unset LAST_SPELL
  
  message "${MESSAGE_COLOR}Gathering spells to cast...${MESSAGE_COLOR}"
  
  tempList=$(all_spells_to_install $MAIN_SPELLS)  

  until  ! ( [[ $MAIN_SPELLS ]] && [[ $tempList ]] ) ;  do
    
    message "${MESSAGE_COLOR}In order to cast ${SPELL_COLOR}${MAIN_SPELLS}${MESSAGE_COLOR}, the following spells are going to be cast:${SPELL_COLOR}" &&

    debug "libdepends" "Wanting to cast $tempList"
    echo "${tempList}"  | column
    if query "${QUERY_COLOR}Do you wish to cast these spells?${DEFAULT_COLOR}" "y"  ; then
      break
    fi    
    
    #Next two lines added until I can test remove_selected_depends properly (duff, 2002/11/01)
    message "${MESSAGE_COLOR}Canceling cast until you figure out what you want.${DEFAULT_COLOR}"
    exit
    
    # At this point, it's ok to assume the user is there, since the question above defaults to yes.
    echo -en "What spell(s) do you wish to remove? "
    
    # remove_selected_depends does the read and modifies the graph and MAIN_SPELLS
    remove_selected_depends 
   
    tempList=$( all_spells_to_install $MAIN_SPELLS )  
    
      
  done

  if ! ( [[ $MAIN_SPELLS ]] && [[ $tempList ]] ) ; then 
    message "${PROBLEM_COLOR}Nothing to cast!${DEFAULT_COLOR}"
    exit
  fi
  
}

function compute_depends()
{ # $1=var to place spells in, $* = root spells


  local spells="$*"
  #PRETEND_NOT_INSTALLED assumes list is space separated
  [[ $COMPILE ]] && PRETEND_NOT_INSTALLED=" $spells "


  for i in $spells ; do
    LAST_SPELL=""
    LAST_NODE=""
    
    if  [[ $RECONFIGURE ]] ; then
      remove_depends_status "$SPELL"
    fi
    
    if [[ $COMPILE ]] || ! ( spell_installed $i || spell_held $i ); then
      SPELL=$i
      depends $i     || 
      return 1
    else
      message "${SPELL_COLOR}$i${DEFAULT_COLOR} is already cast. Try cast -c $i."
    fi
  done

  confer_with_user_on_depends $spells

}

function sort_save_depends()
{

  local spellList i j
  local returnVariable=$1
  local SPELL connections dependency
  shift
  
  message "Sorting spells and saving dependency information..."
  
  SORTED=""
  
  spellList=$( all_spells_to_install $* )
  TOTAL_SPELLS_TO_CHECK=$( hash_get_table spell_to_node | wc -l )
  NUM_SPELLS_CHECKED=0 

  lock_file $DEPENDS_STATUS  
  for SPELL in $spellList ; do
  
    sort_save_depends_recurse $SPELL
  
  done
  unlock_file $DEPENDS_STATUS  

  hash_unset "MarkNodes"
  
  eval "$returnVariable=\"${SORTED:1}\""
  clear_line 51
  message "Done sorting."

  unset SORTED  
}

function sort_save_depends_recurse()
{
  
  local connections dependency
  local i
  
  [[ `hash_get "MarkNodes" "$1"` ]] && return 0
  hash_put "MarkNodes" "$1" "checked"
    
  let NUM_SPELLS_CHECKED++
  progress_bar $NUM_SPELLS_CHECKED $TOTAL_SPELLS_TO_CHECK 50
        
  for i in  $( graph_node_connections_from $( spell_to_node $1 ) ) ; do
    connections="$connections"$'\n'"$i"
  done
    
  for i in  $( hash_get_table_fields "${1}-depends" ) ; do
    if [[ ${i%-type} != ${i} ]] ; then
      dependency=${i:0:${#i}-5}
    else
      continue
    fi
     
    debug "libdepends" "Looking at  $1 -> $dependency "
      
    DEP_NODE=`spell_to_node $dependency`

    if echo "$connections" | grep -q "^$DEP_NODE$" ; then
      sort_save_depends_recurse "$dependency" "$1"
      DEP_MODE="on"
    else
      DEP_MODE="off"
    fi

    #Save depends info
    if [[ $1 ]] ; then
      local DEP_OPTS_TYPE=`hash_get "${1}-depends" "$dependency-type"`
      local DEP_OPTS_ON=`hash_get "${1}-depends" "$dependency-on"`
      local DEP_OPTS_OFF=`hash_get "${1}-depends" "$dependency-off"`
      add_depends  "$1"  "$dependency"  "$DEP_MODE"  \
        "$DEP_OPTS_TYPE"  "$DEP_OPTS_ON"  "$DEP_OPTS_OFF"    
    fi

  done

  echo "$spellList" | grep -q  "^$1$" &&  SORTED="$SORTED $1"  

}

function satisfy_depends()
{

  debug "libdepends" "Running satisfy_depends() on $SPELL"  
  local DEP
 
  unset  OPTS  
  SPELL_CONFIG=$DEPENDS_CONFIG/$SPELL
  debug "libdepends" "satisfy_depends() - DEPENDS_CONFIG=$DEPENDS_CONFIG SPELL=$SPELL, SPELL_CONFIG=$SPELL_CONFIG DEPENDS_STATUS=$DEPENDS_STATUS" 
    
  if  [  -x  $SPELL_CONFIG  ];  then
    debug "libdepends" "satisfy_depends() - found $SPELL_CONFIG"
    .  $SPELL_CONFIG
  fi

  local LINE=''
  search_depends_status "$SPELL" | while read LINE; do

    debug "libdepends" "satisfy_depends() - $LINE"

    # line format is: spell:dependency:status:something:on-opts:off=opts
    DEP=()
    explode "$LINE" ":" "DEP"

    # First, see if the spell exists.
    DEP_SPELL_LOCATION=`codex_find_spell_by_name ${DEP[1]}`
    if  [  -z  "$DEP_SPELL_LOCATION"  ];  then
      message  "${PROBLEM_COLOR}Unable to find previously configured"           \
               "optional dependency ${SPELL_COLOR}'${DEP[1]}'${PROBLEM_COLOR}"
      message  "in grimoire.  Removing spell from cached optional depends."     \
               "${DEFAULT_COLOR}"
      remove_depends_status  "$SPELL"  "${DEP[1]}"
    else

      #Second, am I trying to cast --fix or is this just a normal cast?
      if  [[  $FIX  ]] ; then
      
	#Third, if it's a fix, and the dependency is on, cast --fix it
        if  [[ ${DEP[2]} == on ]] 
	then  debug "libdepends" "cast  $FIX  ${DEP[1]}" && cast  $FIX  ${DEP[1]}
	else debug "libdepends" "Fix=$FIX, and DEP[2]=${DEP[2]}"
        fi

      #(second) It's a normal cast, and this may need to be cast
      elif  [[  ${DEP[2]}  ==  on  ]]; then
        #
        # Spell must be installed or help up to this point (this is a guard fence)
        #
        if  !  spell_installed  ${DEP[1]}  &&
            !  spell_held       ${DEP[1]}
        then
          message "One of the dependancies of ${DEP[0]} failed to cast."
	  message "You should try to cast ${DEP[1]} manualy."
          message "Failed to cast ${DEP[1]}. I will have trouble casting ${DEP[0]}."
          return 1          
        fi
        #
        # End of guard fence
        #
      fi
    fi

  done

  #
  # TODO: Do something about exiled spells so that they've got `off'
  #       in DEPENDS_STATUS file, or something else do improve this
  #
  OPTS=`get_depends_options "$SPELL"`
  debug 'libdepends' "satisfy_depends() - final OPTS=$OPTS"

}


#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
