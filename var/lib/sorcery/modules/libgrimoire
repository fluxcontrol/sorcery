#!/bin/bash
#---------------------------------------------------------------------
##
## @Libgrimoire
##
## @Synopsis Set of functions containing the spell writing API.
##
##
## These functions can be used in the PRE_BUILD, BUILD, POST_BUILD
## and POST_INSTALL sections of spells.
##
## @Copyright
## Original version Copyright 2001 by Kyle Sallee
## Additions/Corrections Copyright 2002 by the Source Mage Team
##
#---------------------------------------------------------------------

#---------------------------------------------------------------------
## @param filename
## @Stdout compressor
##
## Guesses what program was used to compress a file
## Return value is always success due to `file' workings
##
#---------------------------------------------------------------------
function guess_compressor()  {
  # NOTE: if the file doesn't exist, `file' still completes successfully
  #       the COMPRESSOR value in this case will be "can't"

  local OUTPUT=`$FILEPROG -b "$1"`
  local COMPRESSOR=`echo "$OUTPUT" | cut -d ' ' -f1`
  [ "$COMPRESSOR" = "GNU" -o "$COMPRESSOR" = "POSIX" ] && COMPRESSOR=`echo "$OUTPUT" | cut -d ' ' -f2`
  debug "libgrimoire" "guess_compressor() - guessed $1 compressor to be <$COMPRESSOR>"
  echo $COMPRESSOR
}


#---------------------------------------------------------------------
## @param filename 
## @param compressor 
## @param md5 
## @Stdout uncompressed
##
## Just uncompresses the file, but does not expand it. i.e. bunzip
## it, but don't untar it. It dumps the expanded file to stderr.
##
#---------------------------------------------------------------------
function uncompress() {
  debug "libgrimoire" "uncompress - $*"
  set +x #This is here so Duff's super debugging info doesn't screw the next step up

  # Outer subshell is necessary to redirect stderr to stdout
  (
    #Inner subshell decompresses archive to stdout
    # Then outside the inner subshell, the stdout is tee'ed
    # and md5 checked.
    (
    case  $2  in
          bzip2)  bzip2  -cdf   $1  ;;
           gzip)  gzip   -cdf   $1  ;;
      compress*)  gzip   -cdf   $1  ;;
            Zip)  cat           $1  ;;
            RPM)  rpmunpack  <  $1 | gzip  -cd    ;;
            tar)  cat           $1  ;;
              *)  cat           $1  ;;
    esac
    ) | tee /dev/stderr | md5_tar_check $3 2>&1 1>/dev/null #we must avoid this printing
  ) 2>&1

  #This temp file is here because this function MUST NOT send
  # anything to stdout or stderr, and upack needs a way to get the success or
  # failure of this function.
  local a=$?
  [[ $SUPER_DEBUG ]] && set -x  #turn this back on as soon as possible
  echo "$a"  > $TMP_DIR/libgrimoire.uncompress.$$
  return $a

}


#---------------------------------------------------------------------
## @Type API
## @param file to unpack 
## @param md5sum
##
## Given a file, unpack runs the decompression program for that file,
## as well as untar'ing the file if appropriate and if the MD5
## matches.
## Note: zip is a special cast because it doesn't work with streams.
##
#---------------------------------------------------------------------
function real_unpack() {

  message -n "${MESSAGE_COLOR}Unpacking source file ${SPELL_COLOR}${1}"
  message -n "${DEFAULT_COLOR}${MESSAGE_COLOR} for spell ${SPELL_COLOR}"
  message    "${SPELL}${DEFAULT_COLOR}${MESSAGE_COLOR}.${DEFAULT_COLOR}"

  debug "libgrimoire" "Running unpack() on $1"
  FILENAME=`guess_filename  $SOURCE_CACHE/$1` &&
  COMPRESSOR=`guess_compressor $FILENAME`
#  UNCOMPRESSED=""

  uncompress $FILENAME $COMPRESSOR $2 | \
  {

    # This section takes the uncompressed stream and turns it into the
    # fully unarchived form.
    case  $COMPRESSOR  in
            bzip2|gzip|compress*|tar)
                    tar   --owner=root  --group=root  -xf  /dev/stdin 2> /dev/null || cat > /dev/null ;;
              Zip)  cat /dev/stdin >/dev/null   #get rid of unused output
	            unzip  -q  $FILENAME                               ;;
              RPM)  cpio  -idm < /dev/stdin                            ;;
                *)  cat > /dev/null                                    ;;
    esac

  } &&
  {

    # This section takes care of what happens if the md5sum doesn't match.
    # $TMP_DIR/libgrimoire.uncompress.$$ is set in uncompress. It's the only
    # way to get the return value since it's in a pipe.
    if ! [[ $2 ]] ; then

      rm $TMP_DIR/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}doesn't have an MD5 sum for the uncompressed $1."
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
          ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
 ask_risky|ask_abort)  query "Abort?" "y"         && return 1   ||  return 0 ;;
      on|abort_all|*)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    elif [[ $2 == "IGNORE" ]] ; then

      rm $TMP_DIR/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}MD5 sum was purposefully left out for the uncompressed $1."
      message "${QUERY_COLOR}Would you like to abort so you can validate the source yourself via some alternate method?"
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
ask_risky|ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
      ask_abort|on|*)  query "Abort?" "y"         && return 1   ||  return 0 ;;
           abort_all)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    elif [[  `cat $TMP_DIR/libgrimoire.uncompress.$$` != 0  ]]  ; then

      rm $TMP_DIR/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}MD5 sum is different for uncompressed $1."
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
          ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
 ask_risky|ask_abort)  query "Abort?" "y"         && return 1   ||  return 0 ;;
      on|abort_all|*)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    fi
    rm $TMP_DIR/libgrimoire.uncompress.$$

  }

  #By this point, the archive is unarchived, and we know the MD5 check was good.
  return 0

}


#---------------------------------------------------------------------
## @param md5
##
## Checks that the stdin matches the argument.
## Note that DEBUG output may dissapear if it's /dev/stderr due to
## uncompress' 2>/dev/null.
##
#---------------------------------------------------------------------
function md5_tar_check()  {

  local md5

  debug "libgrimoire" "md5_tar_check() - Checking MD5 sum"

  #Do the md5
  md5=`md5sum /dev/stdin | awk '{print $1}'`
  debug "libgrimoire" "md5_tar_check() - MD5 of tarball is $md5."
  debug "libgrimoire" "md5_tar_check() - argument received is $1."

  #See if they match
  if [[ $1 == $md5 ]] ; then
    debug "libgrimoire" "md5_tar_check() - MD5 Sum Success ( $1 == $md5 )"
    return 0
  fi

  #See of we need to md5sum it at all
  if [[ ${MD5SUM_DL:-on} == off ]] || ! [[  $1  ]] ; then
    debug "libgrimoire" "md5_tar_check() - Skipping check"
    return 0
  fi

  #If we get here, the md5's don't match, but should.
  debug "libgrimoire" "md5_tar_check() - bad md5"
  return 1

}


#---------------------------------------------------------------------
## @Type API
## @param directory name 
## @param [size]
## Creates a tmpfs filesystem.  By default, the size is 1GB.
## The caller may optionally supply a size argument.
## <pre>
## Example1:  Create a 2GB mount at $SOURCE_DIRECTORY
##
##    mk_source_dir  $SOURCE_DIRECTORY  2g
##
## Example2:  Create a mount at /tmp/newdir, defaults to 1GB size
##
##    mk_source_dir  /tmp/newdir
## </pre>
#---------------------------------------------------------------------
function real_mk_source_dir() {

  debug  "libgrimoire" "Running mk_source_dir() on $SOURCE_DIRECTORY"

  local NEW_DIR=$1
  local NEW_DIR=${NEW_DIR:=$SOURCE_DIRECTORY}

  local SIZE=$2
  local SIZE=${SIZE:=1g}

  if  [  -n  "$NEW_DIR"  ];  then

    rm_source_dir  $NEW_DIR
    mkdir     $NEW_DIR  &&
    if  [[  $TMPFS == on  ]]; then
      mount  -o  size=$SIZE,nr_inodes=1m  -t  tmpfs  tmpfs  $NEW_DIR
    fi
  fi

}


#---------------------------------------------------------------------
## @param  [directory to remove]
## @Globals SOURCE_DIRECTORY
## Removes the given directory or SOURCE_DIRECTORY if no argument is
## given.
##
#---------------------------------------------------------------------
function rm_source_dir() {

  DEAD_DIR=$1
  DEAD_DIR=${DEAD_DIR:-$SOURCE_DIRECTORY}

  debug  "libgrimoire" "Running rm_source_dir() on $DEAD_DIR"

  if  [  -n  "$DEAD_DIR"  ] &&  [  -d  "$DEAD_DIR"  ];  then

    pushd $BUILD_DIRECTORY 2>&1  >  /dev/null

    umount  -l  $DEAD_DIR  2>  /dev/null

    # We don't really want to use "rm -rf", but if not using tmpfs,
    # we have to. So we move the old dir to a known place before
    # running rm. This prevents accidental damage that could be
    # caused by
    # a) $DEAD_DIR being an empty string
    # b) $DEAD_DIR being set to "/" (or anything above /usr/src)
    # c) $DEAD_DIR containing metacharacters (like newline)
    mv  "$DEAD_DIR"  "$INSTALL_ROOT/usr/src/deaddir"  &&
    rm  -rf          "$INSTALL_ROOT/usr/src/deaddir"  2>  /dev/null

    popd  2>&1  >  /dev/null
    true

  fi

}


#---------------------------------------------------------------------
##
## Override calls to the make program. Used to add custom arguments and
## handle failures when using multiple jobs.
##
#---------------------------------------------------------------------
function make() {

  local JOBS=""

  if  [[ $MAKE_NJOBS == 0 ]]; then
    # Zero jobs has the effect of unlimiting the number of make processes
    JOBS=""
  else
    # Check there is a reasonable value.
    [ $MAKE_NJOBS -gt 0 ] &&
    JOBS="$MAKE_NJOBS"    ||
    JOBS="1" # Use default of one when MAKE_NJOBS is nonsense.
  fi

  debug  "libgrimoire"  "make: running with $JOBS jobs"
  /usr/bin/make -j $JOBS -S "$@"

  # Cache the result
  local  STATUS=$?

  if [[ $STATUS -ne 0 ]] && [[ $JOBS != 1 ]] ; then
    query "Running make with $MAKE_NJOBS jobs failed. Attempt to run with a single job?" y &&
    # Try again
    /usr/bin/make -j1 -S "$@"
    STATUS=$?
  fi

  # Return the exit status
  return $STATUS

}

#---------------------------------------------------------------------
## @Type API
## @param spell
## Returns the current version of the given spell
##
#---------------------------------------------------------------------
function real_installed_version()  {

  local spell="$1"

  grep "^$spell:"  $SPELL_STATUS  |  cut  -d : -f4  |  head  -n 1

}


#---------------------------------------------------------------------
## @param spell
## @param default answer to dispel query
## @Type API
## If the default answer is anything other than 'y' then 'n' is assumed.
## returns the given spellname if it is installed
##
#---------------------------------------------------------------------
function real_conflicts() {

  debug  "libgrimoire" "Running conflicts() on $1. Default query answer $2."

  if  spell_installed  $1;  then
    [  "$2"  =  y  ]  &&  echo  "$1:y"  ||  echo  "$1:n"
  fi

  true

}


#---------------------------------------------------------------------
## @Stdout Warning messages.
## Provides a neatly formatted rejection dialog for the
## various rejected spells that might require user warnings.
## See ask_continue_with_rejected for second part of this function.
##
#---------------------------------------------------------------------
function warn_rejected()
{
  message "${MESSAGE_COLOR}This spell is considered${PROBLEM_COLOR}" \
          "rejected${DEFAULT_COLOR}${MESSAGE_COLOR} because of the"   \
          "following reason:\n"
  message "${PROBLEM_COLOR}$REJECT${DEFAULT_COLOR}${MESSAGE_COLOR}.\n"
  message "Please view the software website for more information:\n"
  message "${DEFAULT_COLOR}$WEB_SITE${MESSAGE_COLOR}\n"
  message "You may continue casting the spell and it will still be tracked" \
          "by Sorcery.\nHowever, the software installation process may have" \
          "questions that need to be\nanswered and/or licensing agreements" \
          "that must be agreed to.${DEFAULT_COLOR}\n"
}


#---------------------------------------------------------------------
## @Stdout Question
## @Stdin  Answer ;-)
## Part two of the warn_rejected funtion, ask if user wants to continue
## anyway. (defaults to NO), unless running in UNATTEND_SAFE mode.
##
#---------------------------------------------------------------------
function ask_continue_with_rejected()
{
  if spell_installed "$SPELL" && [ -e $SCRIPT_DIRECTORY/UNATTEND_SAFE ]; then
    message "${SPELL_COLOR}$SPELL${DEFAULT_COLOR}${MESSAGE_COLOR} is" \
            "installed, and has been determined" \
            "to be ${FILE_COLOR}safe\nfor unattended" \
            "update${DEFAULT_COLOR}${MESSAGE_COLOR}, so the prompt will" \
            "be skipped.${DEFAULT_COLOR}\n"
    return
  fi
  message "\n${MESSAGE_COLOR}Allowing the next question to timeout will" \
          "choose not to install this spell.\nThis means that rejected" \
          "spells ${PROBLEM_COLOR}will not be installed or updated" \
          "automatically.\n"
  message "${DEFAULT_COLOR}${MESSAGE_COLOR}If you want a rejected spell to" \
          "be installed or updated you must\nconfirm your decision now or" \
          "cast the spell later.${DEFAULT_COLOR}\n"
  if ! query  "CONTINUE casting?" n; then
    return 1
  fi
  message "\n${MESSAGE_COLOR}OK, here we go... you are on your" \
          "own!${DEFAULT_COLOR}"
}

#---------------------------------------------------------------------
## @License
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
