#!/bin/bash
#---------------------------------------------------------------------
##
## @Libgrimoire
##
## @Synopsis Set of functions containing the spell writing API.
##
##
## These functions can be used in the PRE_BUILD, BUILD, POST_BUILD
## and POST_INSTALL sections of spells.
##
## @Copyright
## Original version Copyright 2001 by Kyle Sallee
## Additions/Corrections Copyright 2002 by the Source Mage Team
##
#---------------------------------------------------------------------


#---------------------------------------------------------------------
## @param system account
## @param [home directory]
## @param [shell] 
##
## Creates account (if account has been defined).
## @return 0 if success (or account already exists).
## @return 1 if failed (or account has not been defined).
##
#---------------------------------------------------------------------
function create_account() {

	HOME_DIR=/var/run/$1
	if [ -n "$2" ]; then
		HOME_DIR="$2"
	fi

	USER_SHELL=/bin/false
	if [ -n "$3" ]; then
		USER_SHELL="$3"
	fi

  if ! exists_account "$1" ; then
    debug "libgrimoire" "create_account() - $1 not defined!"
    return 0  # should return 0 to gracefully continue casting.
  fi

  ACCOUNT_UID=`get_uid_for_account $1`
  PRIMARY_GID=`get_primary_gid_for_account $1`
  PRIMARY_GNAME=`get_group_name $PRIMARY_GID`

  debug "libgrimoire" "create_account() - $1, UID=$ACCOUNT_UID, GID=$PRIMARY_GID:$PRIMARY_GNAME, HOME=$HOME_DIR, SHELL=$USER_SHELL"

  groupadd -g $PRIMARY_GID -f $PRIMARY_GNAME

	# check for adding user problems and try to notify user.
	useradd -u $ACCOUNT_UID -g $PRIMARY_GNAME -G "$SECONDARY_GIDS" -d "$HOME_DIR" -s "$USER_SHELL" $1
	USERADD_RETURN=$?
	debug "libgrimoire.create_account()" "useradd return code was: $USERADD_RETURN"
	
  if    [  $USERADD_RETURN  ==  0  ] ; then 
		message "${MESAGE_COLOR}The user id $ACCOUNT_UID created!${DEFAULT_COLOR}"
	elif  [  $USERADD_RETURN  ==  4  ] ; then 
		message "${MESAGE_COLOR}The user id $ACCOUNT_UID already exists, so continuing...${DEFAULT_COLOR}"
		return 0
	elif  [  $USERADD_RETURN  ==  9  ] ; then
		message "${MESAGE_COLOR}The user name $1 already exists, so continuing...${DEFAULT_COLOR}"
		return 0
	else
		debug "libgrimoire.create_account()"  "useradd fails with strange code : $USERADD_RETURN"
		message "${MESAGE_COLOR}Something went wrong with adding the user $1 with uid $ACCOUNT_UID"
		message "and gid $PRIMARY_GNAME so going to stop here...${DEFAULT_COLOR}"
		return 1
	fi

}

#---------------------------------------------------------------------
## @param gid
##
## @Stdout group name
## returns that name assigned to a group id.
##
#---------------------------------------------------------------------
function get_group_name() {

  if  grep  -q  ":$1:"  $GROUP_LIST;  then
    grep ":$1:" $GROUP_LIST | cut -d : -f1
  fi

}

#---------------------------------------------------------------------
## @param system account
##
## @Stdout group ids
## Return list of group id's assigned to account name.
## All except primary
##
#---------------------------------------------------------------------
function get_gids_for_account() {

  if  grep  -q  "^$1:"  $ACCOUNT_LIST;  then
    ENTRY=`grep "^1:" $ACCOUNT_LIST`
    i=4
    while  [[  `echo $ENTRY | cut -d : -f$i` ]] ; do
     NEW=`echo $ENTRY | cut -d : -f$i`
     GROUPS="$GROUPS $NEW"
      let i++
    done
  fi
  return $GROUPS
}


#---------------------------------------------------------------------
## @param system account
## @return 0 if exists
## @return 1 if not
##
#---------------------------------------------------------------------
function exists_account() {

  grep  -q  "^$1:"  $ACCOUNT_LIST

}


#---------------------------------------------------------------------
## @param named system account
## @Stdout UID
## Outputs the UID for the named system account
##
#---------------------------------------------------------------------
function get_uid_for_account()  {

  if  grep  -q  "$1:"  $ACCOUNT_LIST;  then
    grep "^$1:" $ACCOUNT_LIST | cut -d : -f2
  fi

}

#---------------------------------------------------------------------
## @param named system account
## @Stdout GID
##
## Outputs the GID for the named system account
##
#---------------------------------------------------------------------
function get_primary_gid_for_account()  {

  if  grep  -q  "$1:"  $ACCOUNT_LIST;  then
    grep "^$1:" $ACCOUNT_LIST | cut -d : -f3
  fi

}


#---------------------------------------------------------------------
## @param filename
## @Stdout compressor
##
## Guesses what program was used to compress a file
## Return value is always success due to `file' workings
##
#---------------------------------------------------------------------
function guess_compressor()  {
  # NOTE: if the file doesn't exist, `file' still completes successfully
  #       the COMPRESSOR value in this case will be "can't"

  local OUTPUT=`$FILEPROG -b "$1"`
  local COMPRESSOR=`echo "$OUTPUT" | cut -d ' ' -f1`
  [ "$COMPRESSOR" = "GNU" -o "$COMPRESSOR" = "POSIX" ] && COMPRESSOR=`echo "$OUTPUT" | cut -d ' ' -f2`
  debug "libgrimoire" "guess_compressor() - guessed $1 compressor to be <$COMPRESSOR>"
  echo $COMPRESSOR
}


#---------------------------------------------------------------------
## @param filename 
## @param compressor 
## @param md5 
## @Stdout uncompressed
##
## Just uncompresses the file, but does not expand it. i.e. bunzip
## it, but don't untar it. It dumps the expanded file to stderr.
##
#---------------------------------------------------------------------
function uncompress() {
  debug "libgrimoire" "uncompress - $*"
  set +x #This is here so Duff's super debugging info doesn't screw the next step up

  # Outer subshell is necessary to redirect stderr to stdout
  (
    #Inner subshell decompresses archive to stdout
    # Then outside the inner subshell, the stdout is tee'ed
    # and md5 checked.
    (
    case  $2  in
          bzip2)  bzip2  -cdf   $1  ;;
           gzip)  gzip   -cdf   $1  ;;
      compress*)  gzip   -cdf   $1  ;;
            Zip)  cat           $1  ;;
            RPM)  rpmunpack  <  $1 | gzip  -cd    ;;
            tar)  cat           $1  ;;
              *)  cat           $1  ;;
    esac
    ) | tee /dev/stderr | md5_tar_check $3 2>&1 1>/dev/null #we must avoid this printing
  ) 2>&1

  #This temp file is here because this function MUST NOT send
  # anything to stdout or stderr, and upack needs a way to get the success or
  # failure of this function.
  local a=$?
  [[ $SUPER_DEBUG ]] && set -x  #turn this back on as soon as possible
  echo "$a"  > /tmp/libgrimoire.uncompress.$$
  return $a

}


#---------------------------------------------------------------------
## @Type API
## @param file to unpack 
## @param md5sum
##
## Given a file, unpack runs the decompression program for that file,
## as well as untar'ing the file if appropriate and if the MD5
## matches.
## Note: zip is a special cast because it doesn't work with streams.
##
#---------------------------------------------------------------------
function real_unpack() {

  message -n "${MESSAGE_COLOR}Unpacking source file ${SPELL_COLOR}${1}"
  message -n "${DEFAULT_COLOR}${MESSAGE_COLOR} for spell ${SPELL_COLOR}"
  message    "${SPELL}${DEFAULT_COLOR}${MESSAGE_COLOR}.${DEFAULT_COLOR}"

  debug "libgrimoire" "Running unpack() on $1"
  FILENAME=`guess_filename  $SOURCE_CACHE/$1` &&
  COMPRESSOR=`guess_compressor $FILENAME`
#  UNCOMPRESSED=""

  uncompress $FILENAME $COMPRESSOR $2 | \
  {

    # This section takes the uncompressed stream and turns it into the
    # fully unarchived form.
    case  $COMPRESSOR  in
            bzip2|gzip|compress*|tar)
                    tar   --owner=root  --group=root  -xf  /dev/stdin 2> /dev/null || cat > /dev/null ;;
              Zip)  cat /dev/stdin >/dev/null   #get rid of unused output
	            unzip  -q  $FILENAME                               ;;
              RPM)  cpio  -idm < /dev/stdin                            ;;
                *)  cat > /dev/null                                    ;;
    esac

  } &&
  {

    # This section takes care of what happens if the md5sum doesn't match
    # /tmp/libgrimoire.uncompress.$$ is set in uncompress. It's the only way to
    # get the return value since it's in a pipe.
    if ! [[ $2 ]] ; then

      rm /tmp/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}doesn't have an MD5 sum for the uncompressed $1."
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
          ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
 ask_risky|ask_abort)  query "Abort?" "y"         && return 1   ||  return 0 ;;
      on|abort_all|*)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    elif [[ $2 == "IGNORE" ]] ; then

      rm /tmp/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}MD5 sum was purposefully left out for the uncompressed $1."
      message "${QUERY_COLOR}Would you like to abort so you can validate the source yourself via some alternate method?"
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
ask_risky|ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
      ask_abort|on|*)  query "Abort?" "y"         && return 1   ||  return 0 ;;
           abort_all)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    elif [[  `cat /tmp/libgrimoire.uncompress.$$` != 0  ]]  ; then

      rm /tmp/libgrimoire.uncompress.$$
      message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}MD5 sum is different for uncompressed $1."
      case $MD5SUM_DL in
                 off)  message "${RED}Continuing!${DEFAULT_COLOR}"; return 0 ;;
          ask_ignore)  query "Abort?" "n"         && return 1   ||  return 0 ;;
 ask_risky|ask_abort)  query "Abort?" "y"         && return 1   ||  return 0 ;;
      on|abort_all|*)  message "${RED}Aborting.${DEFAULT_COLOR}"  ; return 1 ;;
      esac

    fi
    rm /tmp/libgrimoire.uncompress.$$

  }

  #By this point, the archive is unarchived, and we know the MD5 check was good.
  return 0

}


#---------------------------------------------------------------------
## @param md5
##
## Checks that the stdin matches the argument.
## Note that DEBUG output may dissapear if it's /dev/stderr due to
## uncompress' 2>/dev/null.
##
#---------------------------------------------------------------------
function md5_tar_check()  {

  local md5

  debug "libgrimoire" "md5_tar_check() - Checking MD5 sum"

  #Do the md5
  md5=`md5sum /dev/stdin | awk '{print $1}'`
  debug "libgrimoire" "md5_tar_check() - MD5 of tarball is $md5."
  debug "libgrimoire" "md5_tar_check() - argument received is $1."

  #See if they match
  if [[ $1 == $md5 ]] ; then
    debug "libgrimoire" "md5_tar_check() - MD5 Sum Success ( $1 == $md5 )"
    return 0
  fi

  #See of we need to md5sum it at all
  if [[ ${MD5SUM_DL:-on} == off ]] || ! [[  $1  ]] ; then
    debug "libgrimoire" "md5_tar_check() - Skipping check"
    return 0
  fi

  #If we get here, the md5's don't match, but should.
  debug "libgrimoire" "md5_tar_check() - bad md5"
  return 1

}


#---------------------------------------------------------------------
## @Type API
## Prepares to install the spell.  Writes the boost lock file.  If the
## spell is installed already, the libraries are saved with
## save_libraries() and the spell is dispelled.  Usually called from
## the BUILD sript of a spell.
##
#---------------------------------------------------------------------
function real_prepare_install() {

  debug  "libgrimoire" "Running prepare_install() on $SPELL"

  message  "${MESSAGE_COLOR}Preparing to install"  \
           "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}"

  lock_resources "libgrimoire" "install"
# pre liblock code: (2002/09/29)
#  while  boost_locked;  do
#    sleep  5
#  done
#  echo  $$  >  $BOOST_LOCK

    if  spell_installed  $SPELL   ||
        spell_held       $SPELL
    then

      trap  "spell_recover"  SIGINT
      save_libraries
      dispel  --notriggers --nosustain  $SPELL

    fi

    rm  -f  /tmp/$SPELL.iw
    true

}


#---------------------------------------------------------------------
## @Type API
## @param directory name 
## @param [size]
## Creates a tmpfs filesystem.  By default, the size is 1GB.
## The caller may optionally supply a size argument.
## <pre>
## Example1:  Create a 2GB mount at $SOURCE_DIRECTORY
##
##    mk_source_dir  $SOURCE_DIRECTORY  2g
##
## Example2:  Create a mount at /tmp/newdir, defaults to 1GB size
##
##    mk_source_dir  /tmp/newdir
## </pre>
#---------------------------------------------------------------------
function real_mk_source_dir() {

  debug  "libgrimoire" "Running mk_source_dir() on $SOURCE_DIRECTORY"

  local NEW_DIR=$1
  local NEW_DIR=${NEW_DIR:=$SOURCE_DIRECTORY}

  local SIZE=$2
  local SIZE=${SIZE:=1g}

  if  [  -n  "$NEW_DIR"  ];  then

    rm_source_dir  $NEW_DIR
    mkdir     $NEW_DIR  &&
    if  [[  $TMPFS == on  ]]; then
      mount  -o  size=$SIZE,nr_inodes=1m  -t  tmpfs  tmpfs  $NEW_DIR
    fi
  fi

}


#---------------------------------------------------------------------
## @param  [directory to remove]
## @Globals SOURCE_DIRECTORY
## Removes the given directory or SOURCE_DIRECTORY if no argument is
## given.
##
#---------------------------------------------------------------------
function rm_source_dir() {

  DEAD_DIR=$1
  DEAD_DIR=${DEAD_DIR:-$SOURCE_DIRECTORY}

  debug  "libgrimoire" "Running rm_source_dir() on $DEAD_DIR"

  if  [  -n  "$DEAD_DIR"  ] &&  [  -d  "$DEAD_DIR"  ];  then

    pushd $BUILD_DIRECTORY 2>&1  >  /dev/null

    umount  -l  $DEAD_DIR  2>  /dev/null

    # We don't really want to use "rm -rf", but if not using tmpfs,
    # we have to. So we move the old dir to a known place before
    # running rm. This prevents accidental damage that could be
    # caused by
    # a) $DEAD_DIR being an empty string
    # b) $DEAD_DIR being set to "/" (or anything above /usr/src)
    # c) $DEAD_DIR containing metacharacters (like newline)
    mv  "$DEAD_DIR"  "/usr/src/deaddir"  &&
    rm  -rf          "/usr/src/deaddir"  2>  /dev/null

    popd  2>&1  >  /dev/null
    true

  fi

}


#---------------------------------------------------------------------
## @Type API
## Creates the source directory and unpacks the source package into it.
## Used if no PRE_BUILD script is found for a spell.
##
#---------------------------------------------------------------------
function real_default_pre_build() {

  debug "libgrimoire" "default_pre_build() - SOURCE=$SOURCE SOURCE_DIRECTORY=$SOURCE_DIRECTORY"
  mk_source_dir        $SOURCE_DIRECTORY  &&
  unpack               $SOURCE ${MD5[0]}

}


#---------------------------------------------------------------------
##
## Override calls to the make program. Used to add custom arguments and
## handle failures when using multiple jobs.
##
#---------------------------------------------------------------------
function make() {

  local JOBS=""

  if  [[ $MAKE_NJOBS == 0 ]]; then
    # Zero jobs has the effect of unlimiting the number of make processes
    JOBS=""
  else
    # Check there is a reasonable value.
    [ $MAKE_NJOBS -gt 0 ] &&
    JOBS="$MAKE_NJOBS"    ||
    JOBS="1" # Use default of one when MAKE_NJOBS is nonsense.
  fi

  debug  "libgrimoire"  "make: running with $JOBS jobs"
  /usr/bin/make -j $JOBS -S "$@"

  # Cache the result
  local  STATUS=$?

  if [[ $STATUS -ne 0 ]] && [[ $JOBS != 1 ]] ; then
    query "Running make with $MAKE_NJOBS jobs failed. Attempt to run with a single job?" y &&
    # Try again
    /usr/bin/make -j1 -S "$@"
    STATUS=$?
  fi

  # Return the exit status
  return $STATUS

}


#---------------------------------------------------------------------
## @Type API
## Used if no BUILD script is found for a spell
## Default build is:
## <pre>
##  ./configure  --build=$BUILD        \
##               --prefix=/usr         \
##               --sysconfdir=/etc     \
##               --localstatedir=/var  \
##               $OPTS                 &&
##  make                               &&
##  prepare_install                    &&
##  make    install
## </pre>
##
#---------------------------------------------------------------------
function real_default_build() {

(
#If these switches are used, they stop distcc and ccache from working
#  We could write wrappers for all of the possible binaries
[[ $CROSS_INSTALL == on ]] && OPTS="$OPTS --host=${HOST} --build=${BUILD}"
	
  ./configure --prefix=${INSTALL_ROOT}/usr  \
          --sysconfdir=${INSTALL_ROOT}/etc  \
       --localstatedir=${INSTALL_ROOT}/var  \
              --mandir=${INSTALL_ROOT}/usr/share/man   \
             --infodir=${INSTALL_ROOT}/usr/share/info  \
                       $OPTS                 &&
  make                                       &&
  prepare_install                            &&
  make    install

) > $C_FIFO 2>&1

}


#---------------------------------------------------------------------
##
## Gathers all documentation files from source archive and installs
## them as part of the spell
##
#---------------------------------------------------------------------
function gather_docs()  {

  if  [  "$GATHER_DOCS"  ==  "on"  ]; then

    debug  "libgrimoire" "Running gather_docs() on $SPELL"

    DOC_DIR=$DOCUMENT_DIRECTORY/$SPELL
    mkdir  -p  $DOC_DIR

    for i in ${DOCS[@]}
    do
      cp -r $SOURCE_DIRECTORY/${i} $DOC_DIR 2>/dev/null
    done

    cp $SOURCE_DIRECTORY/*rc $DOC_DIR 2>/dev/null

		# making installed docs readable for all users.
		chmod -fR a+r $DOC_DIR

  fi

}


#---------------------------------------------------------------------
##
## Copies pam configuration files to /etc/pam.d/
##
#---------------------------------------------------------------------
function install_pam_confs()  {

  debug  "libgrimoire" "Running install_pam_confs() on $SPELL"

  if  [  -d  "$SCRIPT_DIRECTORY/pam.d"  ];  then
    cd       "$SCRIPT_DIRECTORY/pam.d"

    mkdir  -p  /etc/pam.d

    for  FILE  in  `ls`;  do
      if  !  [  -f  /etc/pam.d/$FILE  ];  then
        cp  $FILE   /etc/pam.d
      fi
    done

  fi

}


#---------------------------------------------------------------------
##
## Copies xinetd configuration files to /etc/xinetd.d/
## Accepts list of services to be installed.
#---------------------------------------------------------------------
function install_xinetd_confs()  { (

  debug  "libgrimoire" "Running install_xinetd_confs() on $SPELL"

  LIST=$@

  debug  "libgrimiore" "services from install_xinetd_confs to be activated : '$LIST'"
  
  # Something is seriously wrong if this doesn't already exist.
  mkdir  -p  /etc/xinetd.d
  cd       "$SCRIPT_DIRECTORY/xinetd.d"

  for  SERVICE  in  $LIST;  do
    for  FILE  in  `ls`;  do
      if    grep  -q  "service $SERVICE"   $FILE
      then  
        debug  "libgrimoire" "Activating service in install_xinetd_confs for '$FILE'"
        # activate service.
        cp  $FILE  /etc/xinetd.d
      fi
    done
  done

  LD_PRELOAD_OLD="$LD_PRELOAD"
  unset LD_PRELOAD

  # only restart if xinetd script installed and xinetd is available.
  if  [   -n  "$LIST"  ]  &&  ps  -C  xinetd  >  /dev/null ;  then
    if  [  -x  /etc/init.d/runlevels/%3/xinetd  ] ; then
      /sbin/telinit  run  xinetd  restart
    else
      message "${MESSAGE_COLOR}Unable to restart xinetd, missing runlevel 3 script.${DEFAULT_COLOR}" 
    fi
  fi

  export LD_PRELOAD="$LD_PRELOAD_OLD"

) }

#---------------------------------------------------------------------
##
## Installs init scripts in /etc/init.d, and creates links in
## /etc/rc*.d
## Accepts list of scripts to be installed.
#---------------------------------------------------------------------
function install_initd_confs()  { (

  debug  "libgrimoire" "Running install_initd_confs() on $SPELL"

  local enable_script="$1"
  shift
  LIST="$@"
  
  debug  "libgrimiore" "install_initd_confs LIST: '$LIST'"
  
  # Something is seriously wrong if this doesn't already exist.
  mkdir  -p  $INSTALL_ROOT/etc/init.d

  for  INITSCRIPT  in  $LIST;  do
    init_install  $enable_script ${INITSCRIPT}
  done

) }


#---------------------------------------------------------------------
##
## Appends the spell's services file to /etc/services
## @Globals SCRIPT_DIRECTORY
##
#---------------------------------------------------------------------
function install_services()  { (

  debug  "libgrimoire" "Running install_services() on $SPELL"

  if  [  -f  $SCRIPT_DIRECTORY/services  ];  then

    local t_services=$( lock_start_transaction /etc/services )
    local LINE=''
    
    cat  $SCRIPT_DIRECTORY/services  |  while  read  LINE;  do
    
      debug "install_services" "LINE : '$LINE'"
	    explode "$LINE" '[\t ]+' tmp
    
      # Cleaning out existing lines in service file with
      # tmp[0] is "service name", tmp[1] is "space", tmp[2] is "port/protocol"
      debug "tmp[0]" "tmp 0 / 1 / 2 : '${tmp[0]}' / '${tmp[1]}' / '${tmp[2]}'"

      tmp=$( grep  -ve "${tmp[0]}.*${tmp[1]//\//[/]}"  $t_services )

      debug "install_services" "LINE var : '$LINE' "
      echo  "$tmp" > $t_services
      echo "$LINE" >> $t_services
      
    done
  lock_commit_transaction /etc/services
  fi

) }


#---------------------------------------------------------------------
## @Type API
## Installs configuration files and documentation.  Stops installwatch.
## Used if no POST_BUILD script is found for a spell.
##
#---------------------------------------------------------------------
function real_default_post_build() {

  install_pam_confs
  install_services
  gather_docs
  devoke_installwatch
  init_post_install
  ldconfig
  # release_saved_libraries
  cd  /

  # Note: bad function name is boost
  boost

}


#---------------------------------------------------------------------
## @Type API
## @param spell
## Returns the current version of the given spell
##
#---------------------------------------------------------------------
function real_installed_version()  {

  local spell="$1"

  grep "^$spell:"  $SPELL_STATUS  |  cut  -d : -f4  |  head  -n 1

}


#---------------------------------------------------------------------
## @param spell
## @Type API
## returns the given spellname if it is installed
##
#---------------------------------------------------------------------
function real_conflicts() {

  debug  "libgrimoire" "Running conflicts() on $1"

  if  spell_installed  $1;  then
    echo $1 
  fi

  true

}


#---------------------------------------------------------------------
## @Stdin list of files
## @Stdout list of files
## Reads a list of files from standard in, and returns a list of the
## files that exist.
##
#---------------------------------------------------------------------
function exists()  {
  while  read  ITEM;  do  [  -e  "$ITEM"  ]  &&  echo  $ITEM;  done;
}


#---------------------------------------------------------------------
##
## Given a list of files it will notify installwatch of them.
## Usfull for spells whos components are not dynamicly linked
## to glibc. Uses simple hack of touching files while
## installwatch is running.
##
#---------------------------------------------------------------------
function track_manual()  {

  if  [[  -z  "$INSTALLWATCHFILE"  ]];  then
    echo "Can't tell installwatch to manually track... installwatch isn't running."
    return 1
  fi

  local  i
  for i in $* ; do
    [ -e $i ] && touch $i
  done

  return 0

}



#---------------------------------------------------------------------
## @Stdout Warning messages.
## Provides a neatly formatted rejection dialog for the
## various rejected spells that might require user warnings.
## See ask_continue_with_rejected for second part of this function.
##
#---------------------------------------------------------------------
function warn_rejected()
{
  message $(cat <<EOT
${MESSAGE_COLOR}This spell is considered ${PROBLEM_COLOR}rejected${DEFAULT_COLOR}${MESSAGE_COLOR} because of the following reason:
EOT
  )
  message ""
  message $(cat <<EOT
${PROBLEM_COLOR}$REJECT${DEFAULT_COLOR}${MESSAGE_COLOR}.
EOT
  )
  message ""
  message $(cat <<EOT
Please view the software website for more information:
EOT
  )
  message ""
  message $(cat <<EOT
${DEFAULT_COLOR}$WEB_SITE${MESSAGE_COLOR}.
EOT
  )
  message ""
  message $(cat <<EOT
You may continue casting the spell and it will still be tracked by Sorcery.
EOT
  )
  message $(cat <<EOT
However, the software installation process may have questions that need to be
EOT
  )
  message $(cat <<EOT
answered and/or licensing agreements that must be agreed to.${DEFAULT_COLOR}
EOT
  )
  message ""
}



#---------------------------------------------------------------------
## @Stdout Question
## @Stdin  Answer ;-)
## Part two of the warn_rejected funtion, ask if user wants to continue
## anyway. (defaults to NO), unless running in UNATTEND_SAFE mode.
##
#---------------------------------------------------------------------
function ask_continue_with_rejected()
{
  if spell_installed "$SPELL" && [ -e $SCRIPT_DIRECTORY/UNATTEND_SAFE ]; then
    message $(cat <<EOT
${MESSAGE_COLOR}$SPELL ${FILE_COLOR}is${MESSAGE_COLOR} installed, and has been
determined to be ${FILE_COLOR}safe
EOT
  )
    message $(cat <<EOT
for unattended update ${DEFAULT_COLOR} ${MESSAGE_COLOR}, so the prompt will be skipped.${DEFAULT_COLOR}
EOT
    )
    message ""
    return
  fi

  message ""
  message $(cat <<EOT
${MESSAGE_COLOR}Allowing the next question to timeout will choose not to install this spell.
EOT
    )
  message $(cat <<EOT
This means that rejected spells ${PROBLEM_COLOR}will not be installed or updated automatically.
EOT
    )
  message ""
  message $(cat <<EOT
${DEFAULT_COLOR}${MESSAGE_COLOR}If you want a rejected spell to be installed or updated you must
EOT
    )
  message $(cat <<EOT
confirm your decision now or cast the spell later.${DEFAULT_COLOR}
EOT
  )
  message ""
  if ! query  "CONTINUE casting?" n; then
    message ""
    message "${MESSAGE_COLOR}You chose to stop the installation, or you let the prompt timeout."
    message "Maybe you'll be braver next time?${DEFAULT_COLOR}"
	
   	# check for more spells to be cast before exiting.
    if  [  -n  "$SPELLS"  ] ; then
      message ""
      message "${MESSAGE_COLOR}We will skip casting $SPELL, but still more spells to be cast so "
      message "continuing on...${DEFAULT_COLOR}"
      message ""

      # now remove the spell from our list of spells to cast.
      TEMP_SPELLS=$(echo "$SPELLS" |grep -v "$SPELL")
      SPELLS=$TEMP_SPELLS
      return 1
    fi
  fi

  message ""
  message "${MESSAGE_COLOR}OK, here we go... you are on your own!${DEFAULT_COLOR}"
}

#---------------------------------------------------------------------
## @License
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
