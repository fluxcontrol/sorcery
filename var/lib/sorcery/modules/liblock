

#---------------------------------------------------------------------
##	liblock is used to lock and unlock resources. It should be deadlock 
##	free, and clean up locks after processes that had locks die without
##	unlocking the files. It uses the directory /tmp/liblock-$UID.
##
##	@Globals LOCK_DIR LOCK_TRANSACTIONS MAX_SLEEP
#---------------------------------------------------------------------
[ -d $LOCK_DIR ] || mkdir $LOCK_DIR

#---------------------------------------------------------------------
##	@param Directory which contains the lock stuff
##	@param (optional) Type of resource (optional)
##	@param (optional) Name of locked resource
##	@param (optional) Pid of lock owner
##
## Lists all lockfiles for the specified info
##
#---------------------------------------------------------------------

function locked_resources()
{ #1=dir, 2=type, 3=name, 4=pid
	local t="${2//\//^}" n=${3//\//^} p=${4//\//^}
	local i
	t=${t:-*}; n=${n:-*}; p=${p:-*}
	
	local A=$( echo $1/$t.$n.$p.lock )
	
	#These next lines are because if there is no file to match the
	# glob, bash will treat the string literaly.
	# So we get to look at the first element and see if it actualy 
	# is a file.
	for i in $A ; do
		[ -e $i ] || return 1
		break
	done
	[[ $A ]] || return 1
	
	echo "${A}"

}


#---------------------------------------------------------------------
##	@param Name of file to lock
##	@param <file> ... (optional)
##
## Locks files for access to only this PID. Will cause attempts by 
## other processes that want to lock the file(s) to block until this
## PID unlocks the file, or this PID dies.
## It cannot prevent bad programs from modifying the file w/o 
## permission.
## Note: Files with funky chars may break things. No colons or stuff.
## @Blocking
##
#---------------------------------------------------------------------
function lock_file()
{
	debug "liblock" "$FUNCNAME - $*"
	local FILE
	lock_resources $( 
		for FILE in "$@" ; do
			echo file $FILE
		done
	)
}


#---------------------------------------------------------------------
##	@param Name of file to unlock
##	@param <file> ... (optional)
##
## Unlocks a file so that another process can lock and modify it.
##
#---------------------------------------------------------------------
function unlock_file()
{
	debug "liblock" "$FUNCNAME - $*"
	local FILE
	unlock_resources $(
		for FILE in "$@" ; do
			echo file $FILE
		done
	)
}


#---------------------------------------------------------------------
##	@param Type of resource, file, castSOLO, ...
##	@param Name of resource, /var/state/sorcery/packages, cast
##	@param <type> <name> ... (optional)
##
## The generalized locking mechanism. Every resource to be locked
## is accompanied by a type. Currently used types are "lockfunction"
## and "file".
## This is the function that makes use of lockexec to make the 
## resource tracking safe in a multiprocess environment.
## @Blocking
##
#---------------------------------------------------------------------
function lock_resources()
{
	debug "liblock" "$FUNCNAME - $*"
	local lockfile good_locks
	local i ALL_LOCKED="no"
	local rType="${1//\//^}"
	local rName="${2//\//^}"

	while [[ $ALL_LOCKED == no ]] ; do
		lock_clean_locklist
		ALL_LOCKED="yes"
		for (( i=0; i<$#; i+=2 )) ; do
			lockfile="$LOCK_DIR/$rType.$rName.$$.lock"
			touch $lockfile
			A=$(locked_resources $LOCK_DIR $rType $rName )
			B=${A// /}
			if [ $(( ${#A}-${#B}+1 )) -gt 1 ] ; then
				ALL_LOCKED="no"
				rm "$lockfile" "${good_locks[@]}" 2>/dev/null
				echo "Trying to lock $rType ($rName), with $$ ($(ls -l $LOCK_DIR/$rType.$rName.*.lock))."
				good_locks=()
				sleep $(( RANDOM % MAX_SLEEP ))
				break
			fi
			good_locks=("${good_locks[@]}" "$lock_file")
		done
	done
}


#---------------------------------------------------------------------
##	@param Type of resource
##	@param Name of resource
##	@param <type> <name> ... (optional)
##
## Unlocks exclusive access to the resource so other processes can
## use it.
##
#---------------------------------------------------------------------
function unlock_resources()
{
	debug "liblock" "$FUNCNAME - $*"
	local rType="${1//\//^}"
	local rName="${2//\//^}"

	while [ $# -gt 1 ] ; do
		rm "$LOCK_DIR/$rType.$rName.$$.lock" 2>/dev/null || debug "liblock" "unlock_resources - $* wasn't locked!"
		shift 2
	done
}


#---------------------------------------------------------------------
##	@param Type of resource locked
##	@param Name of resource
##
## Prints the PID of the process owning a lock on the file
## Returns 0 if a lock exists
## Returns 1 if the file is not locked
## Note this is slower that lock_owned_by, but obtains a lock and
## cleans losck list
##
#---------------------------------------------------------------------
function is_locked()
{ # $1=type $2=name 
	debug "liblock" "$FUNCNAME - $*"
	
#	lock_clean_locklist
	
	local A=$( locked_resources $LOCK_DIR $1 $2 )
	[[ ${A[@]} ]] || return 1
	return 0	
	
}


#---------------------------------------------------------------------
##	@param Type of resource
##	@param Name of resource
##
## Prints the PID of the process owning a lock on the file
## Returns 0 if a lock exists
## Returns 1 if the file is not locked
## Note: This function does not obtain a lock on the lock list. It
## only reads and it checks that each line conforms to the format.
##
#---------------------------------------------------------------------
function lock_owned_by()
{
	debug "liblock" "$FUNCNAME - $*"
	dir_list $LOCK_FILE "${1//\//^}.${2//\//^}.\*.lock" | \
		sed -n 's/[^.]*\.[^.]*\.\([^.]*\)\.lock/\1/p'
}


#---------------------------------------------------------------------
##	@param File to start transaction on
##	@param <file> ... (optional)
##
## A transaction locks a file and ensures that changes made to the
## file are all made at once. No changes are made to the file until
## the transaction is commited. Furthermore, a transaction can be 
## killed before it is commited, ending the transaction and not 
## making any changes to the files. All files are locked at once. 
## If not all can be locked, they will be unlocked, and another try 
## will be made.
##
##	@return The name of a temporary file that should be written to instead of the real file.
##
#---------------------------------------------------------------------
function lock_start_transaction()
{
  debug "liblock" "$FUNCNAME - $*"
  local i TRANSNAME NUMTRANS RET=""
  
  #debug liblock lock_start_transaction - $*
  
  if lock_file "$@" ; then
  
    lock_file $LOCK_TRANSACTIONS
    [ -s $LOCK_TRANSACTIONS ] || echo "0:::" > $LOCK_TRANSACTIONS
    
    NUMTRANS=`tail -n 1 $LOCK_TRANSACTIONS | cut -d : -f 1`
    NUMTRANS=${NUMTRANS:-1}
    RET=()
    
    for i in $* ; do
      let NUMTRANS++
      # copy the file to the temp file, if it doesn't exist then create an empty file.
      if [ -e "$i" ]   ; then
        cp "$i" "$LOCK_TRANSACTIONS.$NUMTRANS" 
      else
        echo -n "" > $LOCK_TRANSACTIONS.$NUMTRANS
      fi
      echo "$NUMTRANS:$i:$$" >$LOCK_TRANSACTIONS
      RET[$NUMTRANS]="${LOCK_TRANSACTIONS}.${NUMTRANS}"
    done
    
    unlock_file $LOCK_TRANSACTIONS
    echo ${RET[*]}
    return 0
  
  else
    return 1
  fi
}

#---------------------------------------------------------------------
##	@param File to commit transaction of
##	@param <file> ... (optional)
##
## Commits the changes made to the files as atomicaly as possible
## Before this func is called, the files remain unchanged.
##
#---------------------------------------------------------------------
function lock_commit_transaction()
{
  debug "liblock" "$FUNCNAME - $*"
  local TMP_FILE unlockList=""
  
  lock_file $LOCK_TRANSACTIONS
  for i in $* ; do
    TMP_FILE=${LOCK_TRANSACTIONS}.$(grep ".*:$i:$$" $LOCK_TRANSACTIONS | cut -d : -f 1)
    [ -e $TMP_FILE ] && cp $TMP_FILE $i && rm $TMP_FILE
    unlock_file $i
    cp $LOCK_TRANSACTIONS $LOCK_TRANSACTIONS.new
    grep -v ".*:$i:$$" $LOCK_TRANSACTIONS.new >$LOCK_TRANSACTIONS
    rm $LOCK_TRANSACTIONS.new
  done
  unlock_file $LOCK_TRANSACTIONS  

}

#---------------------------------------------------------------------
##	@param File to stop the transaction of
##	@param file ... (optional)
##
## Stops a transaction. Causes the changes to the file(s) to be
## ignored/undone.
##
#---------------------------------------------------------------------
function lock_kill_transaction()
{
  debug "liblock" "$FUNCNAME - $*"
  local TMP_FILE
  
  lock_file $LOCK_TRANSACTIONS
  for i in $* ; do
    TMP_FILE=$(grep `esc_str ".*:$i:$$"` $LOCK_TRANSACTIONS | cut -d : -f 1)
    ##  [ -e $TMP_FILE ] && cp $TMP_FILE $i && rm $TMP_FILE  <-- this is the only diff between commit and kill
    unlock_file $i
    cp $LOCK_TRANSACTIONS $LOCK_TRANSACTIONS.1
    grep -v `esc_str ".*:$i:$$"` $LOCK_TRANSACTIONS.1 >$LOCK_TRANSACTIONS
  done
  unlock_file $LOCK_TRANSACTIONS  
}

#---------------------------------------------------------------------
##=item SYNCHRONIZE
## 
## Prevents more than one process from entering a section of code 
## at a time
## NOTE: This assumes that two functions of the same name will
## not havethe SYNCHRONIZE command on the same line in different
## files.
##
## Example:
## #!/bin/bash
## echo "Script started with PID=$$
## eval "$SYNCHRONIZE" && {
## echo "PID $$ is in the synched section of code."
## sleep 10
## } && eval "$UNSYNCHRONIZE"
## echo "PID $$ done."
##
## Note: SYNCHRONIZE and UNSYNCHRONIZE must be in the same local 
## scope. Nested SYNCHs are not allowed in the same local scopes.
## Local scope usualy being a function.
## (Blocking)
##
#---------------------------------------------------------------------
SYNCHRONIZE='
  __llSYNCH_LINE=$LINENO
  debug "liblock" "+++ in synch code"
  lock_resources "lockfunction" "${FUNCNAME}/${__llSYNCH_LINE}"'

#---------------------------------------------------------------------
##=item UNSYNCHRONIZE
##
## Terminates a section of SYNCHRONIZED code
##
#---------------------------------------------------------------------
UNSYNCHRONIZE='
  debug "liblock" "+++ in unsynch code"
  unlock_resources "lockfunction" "${FUNCNAME}/${__llSYNCH_LINE}"
  unset __llSYNCH_LINE'
  
  
######################################################################
##
## LOCK STUFF _PRIVATE_!
##
######################################################################
#---------------------------------------------------------------------
##	@Private Don't call
##
## Removes locks owned by PIDs that don't exist anymore.
##
#---------------------------------------------------------------------
function lock_clean_locklist()	#IF YOU CALL THIS I WILL HUNT YOU DOWN
{
  debug "liblock" "lock_clean_locklist() - Cleaning lock list" 
	
  local locklist_clean=$LOCK_DIR/locklist.clean
  local locklist=$LOCK_DIR/locklist
  
  # If this file doesn't exist, then the locklist will never be cleaned 
  # automatiacly of dead locks
  [ -e $LOCK_TRANSACTIONS ] || touch $LOCK_TRANSACTIONS
  [ -e $locklist_clean ] || touch $locklist_clean
  
  #Obtain a lock, do this manualy as we don't want an infinite loop 
  # by using lock_file ;)
  while  touch $LOCK_TRANSACTIONS.$$.lock
    A=$( locked_resources $LOCK_DIR liblock locklist )
    B=${A// /}
    [ $(( ${#A}-${#B}+1 )) -gt 1 ]
  do
    for i in $A ; do
		B=${i%.lock}
		B=${B##*.}
		if ! [ -d /proc/$i ] ; then
			debug "liblock" "$FUNCNAME - cleaning out $i"
			rm $i 2>/dev/null
		fi			
	done
    rm $LOCK_TRANSACTIONS.$$.lock
	
    sleep $(( RANDOM % MAX_SLEEP ))
  done
  #We now have a lock on the locklist
  # We can now mess with it without fear of other cleaners coming around.
  
  #Clean the lock list only if necessary (clean every minute)

  filen=`basename $locklist_clean`
  if [[ `find "$LOCK_DIR" -name "$filen" -maxdepth 1 -mindepth 1 -mmin +1` ]] ; then
  
    echo "" > ${LOCK_TRANSACTIONS}.1

    for i in `cat $LOCK_TRANSACTIONS` ; do
      debug "liblock" "aftualy looking at locks to clean" 
      if ! [[ $i ]] ; then continue; fi
      PID=`echo $i | cut -d : -f 3`

      if [ -d $( echo /proc/$PID) ] ; then
        echo "$i" >> ${LOCK_TRANSACTIONS}.1
      else
        debug "liblock" "lock_clean_locklist() - Removing $i from list" 
      fi
    done
	
	for i in $( locked_resources $LOCK_DIR  ) ; do
		local p=${i%.lock}
		p=${p##*.}
		if ! [ -d $( echo /proc/$p) ] ; then
			debug "liblock" "lock_clean_locklist() - Removing $i"
			rm $i
		fi
	done

    mv ${LOCK_TRANSACTIONS}.1 $LOCK_TRANSACTIONS
    date > $locklist_clean
  fi
  rm $LOCK_TRANSACTIONS.$$.lock

}

