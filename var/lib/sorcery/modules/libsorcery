#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 LIBSORCERY
##
##=head1 SYNOPSIS
##
## Set of functions used by the internal sorcery scripts
##
##=head1 DESCRIPTION
##
## In addition to being used in the core sorcery commands, many of
## these functions are useful in creating new spells.  These functions
## can be used in the PRE_BUILD, BUILD, and POST_BUILD sections of
## spells.
##
##=head1 COPYRIGHT
##
## Original version Copyright 2001 by Kyle Sallee
## Additions/Corrections Copyright 2002 by the Source Mage Team
##
##=head1 FUNCTIONS
#---------------------------------------------------------------------

#---------------------------------------------------------------------
##=item update_sorcery_scripts <branch>
##
## Updates the sorcery scripts to their latest version for specified
## branch.
##
#---------------------------------------------------------------------
update_sorcery_scripts() {

  BRANCH=$1

  debug "libsorcery" "update_sorcery_scripts() (sorcery-$BRANCH)"

  . /etc/sorcery/update/DETAILS          &&
  {
    #This section is to make sure that all sorcery dependencies are cast
    #Keep this outer if until basesystem is in the grimoires properly. (2002/10/13)
    if [[ `codex_find_spell_by_name basesystem` ]] ; then
      if ! ( spell_installed basesystem ||
             spell_held basesystem  )
      then
        cast basesystem
      fi
      cast --fix basesystem
    fi
  }

  FILENAME=`guess_filename $SOURCE_CACHE/$SOURCE`
  INST_LOG="/etc/sorcery/update/sorcery-$BRANCH.log"
  CACHE="/tmp/$SPELL-$VERSION-$BUILD.tar"
  FORCE_DOWNLOAD=1
  C_LOG=/tmp/$SPELL.compile.log
  C_FIFO=/tmp/$SPELL.compile.fifo
  TMP_LOG="/tmp/$SPELL-$BRANCH"
  IW_LOG="/tmp/$SPELL.iw"

  if [ -f $INST_LOG ]; then
    mv $INST_LOG $INST_LOG.prev
  fi

  dl_source  $SOURCE  ${SOURCE_URL[*]}   &&

  # pre build
  mk_source_dir  $SOURCE_DIRECTORY       &&
  cd /usr/src                            &&
  bzip2  -cdf   $SOURCE_CACHE/$FILENAME |
  tar --owner=root --group=root -xf /dev/stdin   &&
  cd      $SOURCE_DIRECTORY              &&
  invoke_installwatch                    &&

  # build
  (
  echo `pwd` &&
  prepare_install  &&
  ./install
  ) > $C_FIFO 2>&1                       &&

  # post build
  devoke_installwatch                    &&
  cd /                                   &&
  #archive                                &&
  track                                  &&

  # post install
#  rm  -f  /var/lock/casting.sorcery      &&

  report  $INST_LOG  "Install log"       &&
  sound SUCCESS                          &&

  SORCERY_VERSION=`cat /etc/sorcery/version`
  if [ $? -eq 0 ] ; then
    activity_log "update" "sorcery-$BRANCH" "$SORCERY_VERSION" "success"
    rm_source_dir
  else
    activity_log "update" "sorcery-$BRANCH" "$SORCERY_VERSION" "failure"
    if [[  $CLEAN_SOURCE == on ]]; then
      rm_source_dir
    fi
  fi

  message "${MESSAGE_COLOR}Current ${SPELL_COLOR}sorcery-$BRANCH${DEFAULT_COLOR} ${MESSAGE_COLOR} version ${VERSION_COLOR}$SORCERY_VERSION${DEFAULT_COLOR}"
}


disconnect()  {

  debug "libsorcery" "disconnect()"

  if    ps  -C disconnect  >  /dev/null
  then  return
  fi

  rm  -rf          /tmp/disconnect
  cat  <<  EOF  >  /tmp/disconnect
#!/bin/bash

while  ps  -A  |  egrep  -q  "summon|leach";  do  sleep  120;  done
poff
rm  /tmp/disconnect
EOF

chmod  a+x  /tmp/disconnect
            /tmp/disconnect  &

}


connect()  {

  debug "libsorcery" "connect()"

  if  !  ifconfig  |  grep  -q  "^eth"   &&
      !  ifconfig  |  grep  -q  "^wlan"  &&
      !  ifconfig  |  grep  -q  "^tr"    &&
      !  ifconfig  |  grep  -q  "^ppp";  then
    pon

    # Timeout in deciseconds to wait for Interface to come up.
    TIMEOUT=30

    until  ifconfig  |  grep  -q  eth   ||
           ifconfig  |  grep  -q  ppp   ||
           [  $TIMEOUT == 0  ]
    do
      sleep  10
      (( TIMEOUT-- ))
    done
    disconnect

  fi


}


get() {

  debug "libsorcery" "get() $*"

  if  [  -n  "$*"  ] ;  then

    connect                                       &&
    url_download  $*                              &&
    testpack      $FILE                           &&
    mv            $FILE  $SOURCE_CACHE            &&
    touch         $SOURCE_CACHE/$FILE

  fi

}


#---------------------------------------------------------------------
##=item dl_source <filename> <url> [<url> ...]
##
## Downloads <filename> from one of the listed <url>s.  The file
## is not downloaded if it is already in the source cache unless:
## - it's lifespan has expired
## - the user has requested a forced download
##
## NOTE: This and get() should be moved into summon soon.
## (duff, 2002/10/13)
##
#---------------------------------------------------------------------
dl_source()  {

  debug "libsorcery" "dl_source() $*"

  if  [  -n  "$1"  ];  then

    FILE="$1"
    shift  1

    remove_old_cache_src $FILE   #Removes if it's lifespan is over

    if  ! file_exists_in_cache $FILE  ||  [  -n  "$FORCE_DOWNLOAD"  ]
    then
      message  "${MESSAGE_COLOR}Downloading source file"  \
               "${FILE_COLOR}${FILE}${DEFAULT_COLOR}"     \
               "for spell"                                \
               "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}"

      if [ -n "$LEAPFORWARD_URL" ] ; then
        LFURLFILE="$LEAPFORWARD_URL/$FILE"
      fi
      if  get  "$LFURLFILE" $*;  then
        activity_log  "summon"  "$SPELL"  "$VERSION"  "success"  "$URL downloaded"
      else
        message  "${PROBLEM_COLOR}Download of"            \
                 "${FILE_COLOR}${FILE}${DEFAULT_COLOR}"   \
                 "${PROBLEM_COLOR}for spell"              \
                 "${SPELL_COLOR}${SPELL}${DEFAULT_COLOR}" \
                 "${PROBLEM_COLOR}failed${DEFAULT_COLOR}"
      fi

    fi

  fi

}


file_exists_in_cache()  {

  guess_filename  $SOURCE_CACHE/$1  >  /dev/null

}

remove_old_cache_src()  {

    if    [  -n  "$LIFESPAN"  ]
    then  rm  -f  $( find $SOURCE_CACHE/$1 -mmin +$LIFESPAN 2>/dev/null )
    fi
}




#---------------------------------------------------------------------
##=item report <filename>
##
## Displays and/or mails the contents of the file given as the first
## argument.
##
#---------------------------------------------------------------------
report() {

  if  !  [  -f  $1  ];  then  return;  fi

  if  [  "$VIEW_REPORTS"  ==  "on"  ];  then

    debug  "libsorcery" "Prompting to view $2 for $SPELL"

    VIEW_PROMPT="View $2 for ${SPELL_COLOR}${SPELL}-${VERSION_COLOR}${VERSION}${DEFAULT_COLOR}?"
    sound  REPORT
    if  query  "$VIEW_PROMPT" n;  then  $PAGER  $1;  fi
  fi

  if  [  "$MAIL_REPORTS"  ==  "on"  ];  then
    debug  "libsorcery" "Mailing report ($2) for $SPELL to $SORCERER"
    date  -u  |
    mail  -s  "Sorcery Report : $HOSTNAME : $2 for $SPELL-$VERSION"  \
              $SORCERER  -a  $1  2>/dev/null
  fi

  true

}


#---------------------------------------------------------------------
##=item guess_filename <filename>
##
## Given a filename, will return the actual filename if a similar
## filename with a different extension exists.
##
#---------------------------------------------------------------------
guess_filename()  {

  FILENAME=$1

  debug  "libsorcery" "Running guess_filename() on $FILENAME"

  BASENAME=`echo  $FILENAME         |
            sed  "s/\.tar\.gz$//"   |
            sed  "s/\.tgz$//"       |
            sed  "s/\.tar\.bz2$//"`

  if    [  -f  $FILENAME          ];  then  echo  $FILENAME
  elif  [  "$FUZZ"  ==  "off"     ];  then  return  1
  elif  [  -f  $BASENAME.tar.gz   ];  then  echo  $BASENAME.tar.gz
  elif  [  -f  $BASENAME.tar.bz2  ];  then  echo  $BASENAME.tar.bz2
  elif  [  -f  $BASENAME.tgz      ];  then  echo  $BASENAME.tgz
  else  false
  fi

}


#---------------------------------------------------------------------
##=item testpack <filename>
##
## Given a file, testpack runs the decompression program for that file
## in test mode (-t option).  Returns the exit status.
##
#---------------------------------------------------------------------
testpack() {

  FILENAME=`guess_filename                $1`  ||
  FILENAME=`guess_filename  $SOURCE_CACHE/$1`

  if [  -f  $FILENAME  ]; then

    debug  "libsorcery" "Running testpack() on $FILENAME"

    COMPRESSOR=`$FILEPROG  -b  $FILENAME  |  cut  -d ' '  -f1`    &&

    debug  "libsorcery" "Compressor guessed to be $COMPRESSOR"    &&

    case  $COMPRESSOR  in
          bzip2)  bzip2  -tf   $FILENAME   1>/dev/null 2>&1  ;;
           gzip)  gzip   -tf   $FILENAME   1>/dev/null 2>&1  ;;
      compress*)  gzip   -tf   $FILENAME   1>/dev/null 2>&1  ;;
            Zip)  unzip  -tq   $FILENAME   1>/dev/null 2>&1  ;;
            RPM)  rpmunpack  < $FILENAME   |                 \
                  gzip   -t                1>/dev/null 2>&1  ;;
              *)  ! filename_indicates_compression $FILENAME ;;
    esac
  fi

}


#---------------------------------------------------------------------
##=item boost_locked
##
## Returns true if a boost lock file exists for a live cast process.
##
#---------------------------------------------------------------------
boost_locked()  {

  [  -f     $BOOST_LOCK  ]  &&
  ps  `cat  $BOOST_LOCK`    |
  grep  -q  cast

}


#---------------------------------------------------------------------
##=item save_libraries
##
## Saves the current libraries associated with the spell, from /lib
## and /usr/lib into $SOURCE_DIRECTORY/old.libraries/
## Also runs ldconfig with the saved libraries.
##
#---------------------------------------------------------------------
save_libraries()  {

  if    [  -z  "$SOURCE_DIRECTORY"  ]
  then  return
  fi

  debug  "libsorcery" "Running save_libraries()"

  OLD_LIBS=$SOURCE_DIRECTORY/old.libraries
  mkdir  -p  $OLD_LIBS

  SAVED=$OLD_LIBS/$SPELL.saved.libraries
  lock_file $SAVED
  rm  -rf  $SAVED

  OLD_VERSION=`installed_version  $SPELL`
      OLD_LOG=$INSTALL_LOGS/$SPELL-$OLD_VERSION

  grep   "^/lib/\|^/usr/lib"  $OLD_LOG  |
  while  read        LINE;  do

    if   [  -f      $LINE   ]  &&
         file  -bL  $LINE   |
         grep  -q   "shared object"
    then
      if  [  -h  $LINE  ];  then
        DEST=$(  basename  $(  ls   -la  "$LINE"  |
                               cut  -d  '>'  -f2  |
                               cut  -c  2-
                            )
              )
        ln  -sf  $DEST  $OLD_LIBS/`basename  $LINE`
      else
        cp  $LINE  $OLD_LIBS
      fi
      echo       $OLD_LIBS/`basename  $LINE`  >>  $SAVED
    fi


  done

  ldconfig  $OLD_LIBS
  unlock_file $SAVED

  if  [  -z   "$LD_LIBRARY_PATH"  ]
  then  export  LD_LIBRARY_PATH="$OLD_LIBS"
  else  export  LD_LIBRARY_PATH="$OLD_LIBS:LD_LIBRARY_PATH"
  fi

  if  [  "$SPELL"  ==  "glibc"         ]   ||
      [  "$SPELL"  ==  "glibc-custom"  ];  then
    ln  -sf  $OLD_LIBS/ld-$OLD_VERSION.so  /lib/ld-linux.so.2
  fi

}


#---------------------------------------------------------------------
##=item release_saved_libraries
##
## Runs default ldconfig to stop using the saved libraries
##
#---------------------------------------------------------------------
release_saved_libraries()  {
  ldconfig
}


#---------------------------------------------------------------------
##=item spell_recover
##
## Recovers from a CTRL-C while casting a spell
##
#---------------------------------------------------------------------
spell_recover()  {

  debug  "libsorcery" "Running spell_recover()"

  message  "${MESSAGE_COLOR}Aborting dispel of ${SPELL_COLOR}${SPELL}" \
           "${MESSAGE_COLOR} and recovering${DEFAULT_COLOR}"

  CURRENT_VERSION=$(installed_version  $SPELL)
  CACHE_BZ="$INSTALL_CACHE/$SPELL-$CURRENT_VERSION-$BUILD.tar.bz2"

  if  [      -e   $CACHE_BZ  ]  &&
      bzip2  -tf  $CACHE_BZ;    then

    bzcat   $CACHE_BZ  |  tar  -Pkx  2>/dev/null
    add_spell  $SPELL  installed  $CURRENT_VERSION

  fi

  exit  130

}


#---------------------------------------------------------------------
##=item find_section <spell name>
##
## Returns the section a spell is in.
##
#---------------------------------------------------------------------
find_section()  {

  debug  "libsorcery" "Running find_section() on $1"

  codex_get_spell_section_name  $1

}


#---------------------------------------------------------------------
##=item get_status <spell name>
##
## Returns the given spell's status (installed, held, exiled, etc.)
##
#---------------------------------------------------------------------
get_status()  {

  if    query_spell_status $1    >/dev/null
  then  query_spell_status $1    |  cut  -d : -f3
  else  query_spell_status "$1-" |  cut  -d : -f3
  fi

}


#---------------------------------------------------------------------
##=item spell_installed <spell name>
##
## Returns true if the given spell's status is "installed"
##
#---------------------------------------------------------------------
spell_installed() {
  [  "$(  get_status  $1  )"  ==  "installed"  ];
}


#---------------------------------------------------------------------
##=item spell_held <spell name>
##
## Returns true if the given spell's status is "held"
##
#---------------------------------------------------------------------
spell_held()      {
  [  "$(  get_status  $1  )"  ==  "held"       ];
}


#---------------------------------------------------------------------
##=item spell_exiled <spell name>
##
## Returns true if the given spell's status is "exiled"
##
#---------------------------------------------------------------------
spell_exiled()    {
  [  "$(  get_status  $1  )"  ==  "exiled"     ];
}


#---------------------------------------------------------------------
##=item remove_spell <spell name>
##
## Removes the given spell from the /var/state/sorcery/packages file.
## if C<EXILE> is set, the spell is changed to "exiled" in the file.
##
#---------------------------------------------------------------------
remove_spell()  {

  debug  "libsorcery" "Running remove_spell() on $1"

  remove_spell_status $1

  if  [  -n  "$EXILE"  ];  then
    add_spell_status $1 "." "exiled" "0.0"
    remove_depends_status ".*" $1
  fi

}


#---------------------------------------------------------------------
##=item add_spell <spell name>
##
## Given a spell, status (installed, held, etc), and version, add_spell
## adds the spell to the /var/state/sorcery/packages file
##
#---------------------------------------------------------------------
add_spell()  {

  remove_spell  $1
  add_spell_status $1 $2 $3

}


#---------------------------------------------------------------------
##=item directories
##
## Reads a list from standard input, and prints out each entry that is
## a directory (and not a symbolic link to a directory).
##
#---------------------------------------------------------------------
directories() {

  while  read       ITEM;  do
    if  [     -d  "$ITEM"  ]   &&
        !  [  -h  "$ITEM"  ];  then
      echo        "$ITEM"
    fi
  done

}


#---------------------------------------------------------------------
##=item files
##
## Reads a list from standard input, and prints out each entry that is
## a file (and not a symbolic link to a file).
##
#---------------------------------------------------------------------
files()  {

  while  read       ITEM;   do
    if  [     -f  "$ITEM"  ]   &&
        !  [  -h  "$ITEM"  ];  then
      echo        "$ITEM"
    fi
  done

}


#---------------------------------------------------------------------
##=item symlinks
##
## Reads a list from standard input, and prints out each entry that is
## a symbolic linke
##
#---------------------------------------------------------------------
symlinks()  {

  while  read    ITEM;   do
    if  [  -h  "$ITEM"  ];  then
      echo     "$ITEM"
    fi
  done

}


#---------------------------------------------------------------------
##=item filter
##
## First argument is a file that contains filenames.  C<filter> will
## filter standard input to remove any filenames that match an entry
## in that file.  Used to filter out excluded or protected files from
## a list of files.
##
#---------------------------------------------------------------------
filter() {

  if  [  -f  $1  ];  then

     DIRS=`directories  <  $1  2>/dev/null`
    FILES=`files        <  $1  2>/dev/null`
     SYMS=`symlinks     <  $1  2>/dev/null`

    RID_LIST=`for  DIR   in  $DIRS;   do  echo  -n  "^$DIR\|";     done
              for  FILE  in  $FILES;  do  echo  -n  "^$FILE\$\|";  done
              for  SYM   in  $SYMS;   do  echo  -n  "^$SYM\$\|";   done
              echo  -n  "/dev/null"`

    grep  -v  "$RID_LIST"

  else
    cat
  fi

}


#---------------------------------------------------------------------
##=item reap_modified_file
##
## If C<PRESERVE> is off, will move the file to filename.YYYYMMDD.  If
## C<PRESERVE> is on, the file will not be moved.
##
#---------------------------------------------------------------------
reap_modified_file()  {

  message  "${FILE_COLOR}${1}${DEFAULT_COLOR}"
  message  "${MESSAGE_COLOR}was previously modified by SA?"
  case  $PRESERVE  in
     on)  message  "Therefore, it was not reaped."  ;;
    off)  SAVE="$1.`date  -u  +%Y%m%d`"
          mv  $1  $SAVE
          message  "Therefore, it was moved to"
          message  "${FILE_COLOR}${SAVE}"  ;;
  esac
  message  "${DEFAULT_COLOR}"

}


#---------------------------------------------------------------------
##=item dirnames
##
## Given a list of files from standard input, returns the directory
## of each file.
##
#---------------------------------------------------------------------
dirnames()  {
  while  read  FILE;  do  dirname  "$FILE";  done;
}


#---------------------------------------------------------------------
##=item reap_regular_files
##
## Given a list of files from standard input, deletes each file.
## Performs a "rm -f" on each file given in standard input, so be
## careful using this function!
##
#---------------------------------------------------------------------
reap_regular_files()  {
  debug "libsorcery" "reap_regular_files()"
  while  read  FILE;  do  rm  -f   "$FILE";  done;
}


#---------------------------------------------------------------------
##=item reap_config_files
##
## Reads a list of files from standard input.  If the file has been
## modified (md5sum doesn't match the stored md5sum), then function
## C<reap_modified_file> is called.  Otherwise, the file is deleted.
##
#---------------------------------------------------------------------
reap_config_files()  {

  debug "libsorcery" "reap_config_files()"
  while  read  FILE;  do

    if    grep  -q  "$(  md5sum  "$FILE" )"  "$MD5S"
    then  rm    -f               "$FILE"
    else  reap_modified_file     "$FILE"
    fi

  done

}


#---------------------------------------------------------------------
##=item reaper
##
## First argument is a file containing a list of files to reap.
## Second argument is a file containing md5 sums of those files, used
## to detect if a config file has been modified.  Config files are any
## files in /etc or any of its sub-directories.
##
#---------------------------------------------------------------------
reaper()  { (
#  Example:  reaper "$INSTALL_LOG"  "$MD5_LOG"

  debug  "libsorcery" "Running reaper() on $1"

  if  !  [  "$REAP"  ==  "on"  ]   ||
      !  [  -f  $1             ];  then  return
  fi

  MD5S=$2
  MD5S=${MD5S:=/dev/null}

        UNIQUE="$$.$RANDOM"
  REAPER_FILES="/tmp/reaper.$UNIQUE.files"
   REAPER_DIRS="/tmp/reaper.$UNIQUE.dirs"
   REAPER_SYMS="/tmp/reaper.$UNIQUE.syms"

  rm  -f  $REAPER_FILES  $REAPER_DIRS  $REAPER_SYMS

  filter  $PROTECTED  <  $1  |
  filter  $EXCLUDED          |
  while   read  ITEM;  do
    if    [  -h  "$ITEM"  ];  then  echo  "$ITEM"  >>  $REAPER_SYMS
    elif  [  -f  "$ITEM"  ];  then  echo  "$ITEM"  >>  $REAPER_FILES
    elif  [  -d  "$ITEM"  ];  then  echo  "$ITEM"  >>  $REAPER_DIRS
    fi
  done

  [     -f           $REAPER_FILES  ]  &&
  grep      "^/etc"  $REAPER_FILES     |
  reap_config_files

  [     -f           $REAPER_FILES  ]  &&
  grep  -v  "^/etc"  $REAPER_FILES     |
  reap_regular_files

  [  -f  $REAPER_SYMS   ]  &&  rm     -f  `cat          $REAPER_SYMS`                         2>/dev/null
  [  -f  $REAPER_DIRS   ]  &&  rmdir      `sort  -r     $REAPER_DIRS`                         2>/dev/null
  [  -f  $REAPER_FILES  ]  &&  rmdir      `dirnames  <  $REAPER_FILES  |  uniq  |  sort  -r`  2>/dev/null

  rm  -f  $REAPER_FILES  $REAPER_DIRS  $REAPER_SYMS

) }


#---------------------------------------------------------------------
##=item pop_queue <queue filename> [<items to remove>]
##
## The first argument is the name of the file containing the queue.
## If a second argument is given, any items in the queue that match
## the second argument are removed from the queue.  Otherwise, the top
## line of the queue is removed, and returned.
##
#---------------------------------------------------------------------
pop_queue() {  (

  local ITEM=`esc_str $2`

  tQUEUE_FILE=`lock_start_transaction $1`
  if  !  [  -f  "$1"  ];  then  return  1;  fi

  if  [  -n  "$ITEM"  ];  then
    grep  -v  "^$ITEM\$"  $1 > $tQUEUE_FILE
  else

    FOUND=`sed  -n  1p  $1`

    if  [  -z  "$FOUND"  ];  then  return  1;  fi

    FOUND=`esc_str $FOUND`
    grep  -v  "^$FOUND$"  $1 > tQUEUE_FILE
    echo  $FOUND

  fi
  lock_commit_transaction $1

) }


#---------------------------------------------------------------------
##=item push_queue <queue filename> <item to add>
##
## The first argument is the name of the file containing the queue.
## The second argument is an item to add to the end of the queue.  If
## the item exists anywhere in the queue, the item is removed from the
## queue before being added at the end.
##
#---------------------------------------------------------------------
push_queue()  {
  lock_file $1
  pop_queue  "$1"  "$2";  echo  "$2" >>  $1;
  unlock_file $1
}


#---------------------------------------------------------------------
##=item push_install_queue <spell>
##
## Adds the given spell to the install queue and removes it from the
## remove queue.
##
#---------------------------------------------------------------------
push_install_queue() {

  pop_queue   $REMOVE_QUEUE    "$1"
  pop_queue   $INSTALL_QUEUE   "$1"
  !  spell_installed           "$1"  &&
  push_queue  $INSTALL_QUEUE   "$1"

}


#---------------------------------------------------------------------
##=item push_remove_queue <spell>
##
## Adds the given spell to the remove queue and removes it from the
## install queue.
##
#---------------------------------------------------------------------
push_remove_queue() {

  pop_queue   $INSTALL_QUEUE  "$1"
  pop_queue   $REMOVE_QUEUE   "$1"
  spell_installed             "$1"  &&
  push_queue  $REMOVE_QUEUE   "$1"

}


#---------------------------------------------------------------------
##=item apprentice_off
##
## Removes files installed by apprentice.
##
## (2002/0929) Is there any more apprentice?
##
#---------------------------------------------------------------------
apprentice_off()  { (

  rm  -f  $(  find  /usr/bin /usr/games /usr/sbin  -group  apprentice  2>/dev/null )

) }


#---------------------------------------------------------------------
##=item optimize
##
## Sets some environment variables (such as C<CFLAGS>) based on the
## option passed.  Options may be on or more of:  i386, i486, i586,
## pentium, pentium-mmx, i686, pentiumpro, pentium2, pentium3,
## pentium4, k6, k6-2, k6-3, athlon, athlon-tbird, athlon-4,
## athlon-xp, athlon-mp, powerpc, speedy, tiny, risky, strip,
## combreloc
##
#---------------------------------------------------------------------
optimize()  {

  debug "libsorcery" "In optimize(), ARCHITECTURE='${ARCHITECTURE}'"
  debug "libsorcery" "TARGET='${TARGET}'"
  debug "libsorcery" "OPTIMIZATIONS='${OPTIMIZATIONS}'"

  unset  CFLAGS CXXFLAGS LDFLAGS
  unset  FAST SMALL SPEEDY TINY RISKY STRIP

  local SPECFILE
  SPECFILE=`find ${ARCH_SPECS} -name "$ARCHITECTURE"`;
  [  -x  "$SPECFILE"  ]  &&  .  "$SPECFILE"

  BUILD=${HOST}

  if  [[ $CROSS_INSTALL == on ]]; then
    if  [[ $TARGET ]]; then
      SPECFILE=`find ${ARCH_SPECS} -name "$TARGET"`;
      [  -x  "$SPECFILE"  ]  &&  .  "$SPECFILE"
    fi
    invoke_cross_environment
  fi
  debug "libsorcery" "BUILD is $BUILD, HOST is $HOST"

  for  PARAM  in  $OPTIMIZATIONS;  do
    case  $PARAM  in
      speedy)
        CFLAGS="$CFLAGS $FAST"
        SPEEDY="on"
        ;;

      tiny)
        CFLAGS="$CFLAGS $SMALL"
        TINY="on"
        ;;

      risky)
        CFLAGS="$CFLAGS -ffast-math -funroll-loops"
        RISKY="on"
        ;;

      strip)
        LDFLAGS="$LDFLAGS -s"
        STRIP="on"
        ;;

      combreloc)
        LDFLAGS="$LDFLAGS -z combreloc"
        COMBRELOC="on"
        ;;

    esac
  done

  export  CFLAGS
  export  CXXFLAGS="$CFLAGS"
  export  LDFLAGS

}


#---------------------------------------------------------------------
##=item list_install_queue
##
## List files in install queue, give user chance to modify it.
##
#---------------------------------------------------------------------
list_install_queue() {
  if  [  -f  $INSTALL_QUEUE  ];  then
    lock_file $INSTALL_QUEUE

    message -n "The following spells will be updated:"
    message "${SPELL_COLOR}"
    cat  $INSTALL_QUEUE | column
    message "${DEFAULT_COLOR}"

    if    query  "Do you wish to edit ${FILE_COLOR} $INSTALL_QUEUE ${DEFAULT_COLOR}?" n
    then  edit_file  $INSTALL_QUEUE
    fi

    if  [  -n  "`cat  $INSTALL_QUEUE`"  ];  then
      SPELLS=`cat $INSTALL_QUEUE`
    fi

    unlock_file $INSTALL_QUEUE
  else
    message "${MESSAGE_COLOR}No spells listed in queue.${DEFAULT_COLOR}"
  fi
}


#---------------------------------------------------------------------
##=item update_install_queue
##
## Checks all installed spells for newer versions, and creates an
## install queue.
##
#---------------------------------------------------------------------
update_install_queue()  { (

  message  "${CHECK_COLOR}Generating list of spells to update... ${DEFAULT_COLOR} "
  wait_flag_up

  rm  -f  $INSTALL_QUEUE
  for  LINE  in  `all_spell_status`;  do

  	#0=spell, 1=date, 2=status, 3=version
	explode "$LINE" ":" "INFO"

    if  [  "${INFO[2]}"  ==  "installed"  ]          &&
        codex_set_current_spell_by_name  ${INFO[0]};  then

      if  [[ $VERSION != ${INFO[3]} ]]  ||
          [[     -z ${INFO[1]}      ]]	||
	  	  (( UPDATED  >  ${INFO[1]} ))
	  then

          push_queue  $INSTALL_QUEUE  $SPELL

      fi

    fi

  done

  wait_flag_down

) }


#---------------------------------------------------------------------
##=item build_install_queue
##
## Builds all spells in the install queue.
##
#---------------------------------------------------------------------
build_install_queue()  {

  if  [  -f  $INSTALL_QUEUE  ];  then
    lock_file $INSTALL_QUEUE

    message  "The following spells will be updated :"
    cat  $INSTALL_QUEUE

    unset  SPELL
    if    query  "Do you wish to edit ${FILE_COLOR}$INSTALL_QUEUE${DEFAULT_COLOR}?" n
    then  edit_file  $INSTALL_QUEUE
    fi

    if  [  -n  "`cat  $INSTALL_QUEUE`"  ];  then
      cast      `cat  $INSTALL_QUEUE`
      rm              $INSTALL_QUEUE
    fi

    unlock_file $INSTALL_QUEUE
  else
    message  "No spells will be updated."
  fi
}


#---------------------------------------------------------------------
##=item fix_installed_spells
##
## Attempt to fix any spells that may be broken.
##
#---------------------------------------------------------------------
fix_installed_spells()  {

  local ANSWER=

  [  "$AUTOFIX"  ==  "on"  ]  &&  ANSWER=y  ||  ANSWER=n
  if  query  "Attempt to fix spells that may have become broken ?" $ANSWER;  then
    cast  --fix;
  fi

  if  [  "$AUTOPRUNE"  ==  "on"  ];  then  prune;  fi
}


#---------------------------------------------------------------------
##=item upgrade_install_queue
##
## Casts all spells in the install queue.
##
## DEPRICATED: tagged for removal - nkj
##
#---------------------------------------------------------------------
upgrade_install_queue()  {

  if  [  -f  $INSTALL_QUEUE  ];  then
    lock_file $INSTALL_QUEUE

    message  "The following spells will be updated:"
    cat  $INSTALL_QUEUE

    unset  SPELL
    if    query  "Do you wish to edit ${FILE_COLOR}$INSTALL_QUEUE${DEFAULT_COLOR}?" n
    then  edit_file  $INSTALL_QUEUE
    fi

    if  [  -n  "`cat  $INSTALL_QUEUE`"  ];  then
      cast      `cat  $INSTALL_QUEUE`
      rm              $INSTALL_QUEUE
    fi

    unlock_file $INSTALL_QUEUE
  else
    message  "No spells will be updated."
  fi

  local ANSWER

  [  "$AUTOFIX"  ==  "on"  ]  &&  ANSWER=y  ||  ANSWER=n
  if  query  "Attempt to fix spells that may have become broken ?" $ANSWER;  then
    cast  --fix;
  fi

  if  [  "$AUTOPRUNE"  ==  "on"  ];  then  prune;  fi
}


#---------------------------------------------------------------------
##=item log_list
##
## Returns a list of the log files for each spell.
##
#---------------------------------------------------------------------
log_list()  {

  for  LINE  in  `all_spell_status`;  do
    SPELL=`echo  $LINE  |  cut  -d  :  -f1`
      VER=`echo  $LINE  |  cut  -d  :  -f4`
    echo  "$SPELL-$VER"
    echo  "$SPELL-$VER.bz2"
  done

}


#---------------------------------------------------------------------
##=item clean_logs
##
## Removes stale logs.
##
#---------------------------------------------------------------------
clean_logs()  {

  wait_flag_down
  message "${CHECK_COLOR}Cleaning log files... ${DEFAULT_COLOR} "

  debug  "libsorcery" "Running clean_logs()"

  LOGS=`log_list`

  for  FILE  in  `ls  $INSTALL_LOGS`;  do
    if  !  echo  -e  "$LOGS"  |  grep  -q  $FILE;  then
      message  "Removing stale log  :  $INSTALL_LOGS/$FILE "
      rm                               $INSTALL_LOGS/$FILE
    fi
  done

  for  FILE  in  `ls  $COMPILE_LOGS`;  do
    if  !  echo  -e  "$LOGS"  |  grep  -q  $FILE;  then
      message  "Removing stale log  :  $COMPILE_LOGS/$FILE "
      rm                               $COMPILE_LOGS/$FILE
    fi
  done

  for  FILE  in  `ls  $MD5SUM_LOGS`;  do
    if  !  echo  -e  "$LOGS"  |  grep  -q  $FILE;  then
      message  "Removing stale log  :  $MD5SUM_LOGS/$FILE "
      rm                               $MD5SUM_LOGS/$FILE
    fi
  done

  for  GRIMOIRENAME  in  `codex_get_all_grimoires`;  do
    EMPTY=$(  find  $GRIMOIRENAME  -type d  -empty  |  grep  -v  "pam.d"  )
    if    [  -n  "$EMPTY"  ];  then
      rmdir   $EMPTY
    fi
  done

}


#---------------------------------------------------------------------
##=item activity_log
##
## Updates the activity log.
##
#---------------------------------------------------------------------
activity_log()  { (

  lock_file $ACTIVITY_LOG

     DATE=`date  -u  +%Y%m%d:%H%M\(%z\)`
  COMMAND=$1
    SPELL=$2
  VERSION=$3
  OUTCOME=$4
     INFO=$5

  echo  -e "$DATE\t$COMMAND\t$SPELL\t$VERSION\t$OUTCOME\t$INFO"  >> $ACTIVITY_LOG
  unlock_file $ACTIVITY_LOG
) }


#---------------------------------------------------------------------
##=item run_details
##
## Executes the spell's DETAILS file.
##
#---------------------------------------------------------------------
run_details() {

  if  !  codex_set_current_spell_by_name  $SPELL;  then
    local  GRIMOIRES=`codex_get_all_grimoires`
    message  "${PROBLEM_COLOR}Unable to find spell"        \
             "${SPELL_COLOR}${SPELL}${PROBLEM_COLOR}"      \
             "in grimoire(s): $GRIMOIRES ${DEFAULT_COLOR}"
    false
  fi
}


unset_details()  {

  local VARS="SPELL VERSION SOURCE_DIRECTORY WEB_SITE UPDATED ENTERED SHORT"
  local TEMP=""

  # Take care or SOURCEx and SOURCEx_URL
  for i in ${!SOURCE*} ; do
    TEMP=${TEMP}${i}\\n
  done
  VARS="$VARS `echo -e $TEMP | egrep "^SOURCE[[:digit:]]*(_URL)?$"`"
  unset TEMP

  for i in $VARS ; do
    unset $i
  done

}


#---------------------------------------------------------------------
##=item color
##
## First argument is "off" or "on" to turn console colors off or on
##
#---------------------------------------------------------------------
color()  {

  case  $1  in
    off)  unset  SPELL_COLOR
          unset  VERSION_COLOR
          unset  QUERY_COLOR
          unset  DISPEL_COLOR
          unset  CHECK_COLOR
          unset  RESURRECT_COLOR
          unset  FILE_COLOR
          unset  SYMLINK_COLOR
          unset  PROBLEM_COLOR
          unset  MESSAGE_COLOR
          unset  DEFAULT_COLOR
          COLOR=off
          ;;
     on)  COLOR=on
          ;;
  esac

}


#---------------------------------------------------------------------
##=item invoke_installwatch
##
## Sets up installwatch.
##
#---------------------------------------------------------------------
invoke_installwatch()  {

  if  [  -e  /usr/lib/installwatch.so  ];  then
    rm  -rf  /tmp/$SPELL.iw
    export  INSTALLWATCHFILE=/tmp/$SPELL.iw
    export  LD_PRELOAD=/usr/lib/installwatch.so
  fi

}


#---------------------------------------------------------------------
##=item devoke_installwatch
##
## Stops using installwatch
##
#---------------------------------------------------------------------
devoke_installwatch()  {

  unset  LD_PRELOAD
  unset  INSTALLWATCHFILE

}


#---------------------------------------------------------------------
##=item syms_not_owned <filename>
##
## First argument is a file containing a list of files.  Checks for
## broken symbolic links.
##
#---------------------------------------------------------------------
syms_not_owned()  {

  cat  $1  |
  while  read  ITEM;  do

    if  [  -h  "$ITEM"  ]   &&
        [  -f  "$ITEM"  ];  then

      DEST=$(  basename  $(  ls   -la  "$ITEM"  |
                             cut  -d  '>'  -f2  |
                             cut  -c  2-
                          )
            )

      if  !  grep  -q  "$DEST"  "$1"
      then   echo  -n  "$ITEM\|"
             echo      "$ITEM"  >>  /tmp/$SPELL.rejected.symlinks
      fi

    fi

  done

}


#---------------------------------------------------------------------
##=item parse_iw
##
## Parses the installwatch log for files installed by a spell.
##
#---------------------------------------------------------------------
parse_iw()  {

  OMIT="^/dev\|^/tmp\|^/usr/src"
  OMIT_IN="	rename\|	symlink\|	unlink"

  grep -v "$OMIT_IN" $IW_LOG | cut -f3 | grep -v "$OMIT"
  cat                $IW_LOG | cut -f4 | grep -v "$OMIT" | grep "^/"

}


#---------------------------------------------------------------------
##=item track
##
## Creates the install log containing all files installed by the spell.
##
#---------------------------------------------------------------------
track()  {

  debug  "libsorcery" "Running track() on $SPELL"

  message  "${MESSAGE_COLOR}Creating install log ${FILE_COLOR}${INST_LOG}${DEFAULT_COLOR}"

  parse_iw                   |
  sort                       |
  uniq                       |
  filter  "$EXCLUDED"        |
  filter  "$LOCAL_EXCLUDED"  |
  exists                     >  $TMP_LOG

  echo  "$C_LOG_BZ"         >>  $TMP_LOG
  echo  "$MD5_LOG"          >>  $TMP_LOG
  echo  "$INST_LOG"         >>  $TMP_LOG

  MISOWNED_SYMLINKS=`syms_not_owned  $TMP_LOG
                     echo  -n  "/dev/null"`

  if    [  "$MISOWNED_SYMLINKS"  ==  "/dev/null"  ]
  then  cp  $TMP_LOG  $INST_LOG
  else  grep  -v  "$MISOWNED_SYMLINKS"  $TMP_LOG  >  $INST_LOG
  fi

  rm  -f  $IW_LOG  $TMP_LOG

}


#---------------------------------------------------------------------
##=item archive
##
## Creates a bzip'ed tar file containing an archived backup of every
## file installed by a spell.
##
#---------------------------------------------------------------------
archive()  {

  debug  "libsorcery" "Running archive() on $SPELL"

  LINES=`wc  -l  <  $INST_LOG`
  ((  CHUNKS     =  LINES  /  1024  ))
  ((  REMAINDER  =  LINES  %  1024  ))
  if  ((  REMAINDER  !=  0  ));  then
    ((  CHUNKS++  ))
  fi

  ((  START  =  1     ))
  ((  STOP   =  1024  ))

  for  ((  CX  =  0  ;  CX  !=  CHUNKS  ;  CX++  ));  do

    md5sum  $(  sed  -n  ${START},${STOP}p  $INST_LOG  |
                files  )  >> $MD5_LOG

    ((  START   =  STOP  +  1  ))
    ((  STOP   +=  1024        ))

  done

  if    [  "$ARCHIVE"  ==  "off"  ]; then
    debug "libsorcery" "archive() - ARCHIVE=$ARCHIVE, aborting archival."
    return
  fi

  debug "libsorcery" "archive() - ARCHIVE=$ARCHIVE, archiving."

  ((  START  =  1     ))
  ((  STOP   =  1024  ))

  for  ((  CX  =  0  ;  CX  !=  CHUNKS  ;  CX++  ));  do

    tar  --no-recursion  \
         -rPf  $CACHE    \
         $(  sed  -n ${START},${STOP}p  ${INST_LOG}  )

    ((  START   =  STOP  +  1  ))
    ((  STOP   +=  1024        ))

  done

  message  "${MESSAGE_COLOR}Creating ${FILE_COLOR}${CACHE_BZ}${DEFAULT_COLOR}"
  bzip2  -9f  <  $CACHE  >  $CACHE_BZ
  rm     -f      $CACHE

}


#---------------------------------------------------------------------
##=item boost
##
## Runs C<track> and C<archive> on the current spell.
##
## NOTE: boost and boost_locked should be removed or renamed, due
## to liblock being introduced
##
#---------------------------------------------------------------------
boost()	{ (

  debug  "libsorcery" "Running boost() on $SPELL"

     CACHE="/tmp/$SPELL-$VERSION-$BUILD.tar"
  CACHE_BZ="$INSTALL_CACHE/$SPELL-$VERSION-$BUILD.tar.bz2"
  C_LOG_BZ="$COMPILE_LOGS/$SPELL-$VERSION.bz2"
   TMP_LOG="/tmp/$SPELL-$VERSION"
  INST_LOG="$INSTALL_LOGS/$SPELL-$VERSION"
   MD5_LOG="$MD5SUM_LOGS/$SPELL-$VERSION"
    IW_LOG="/tmp/$SPELL.iw"

  rm  -rf  $CACHE
  rm  -rf  $INST_LOG
  touch    $INST_LOG
  rm  -rf  $TMP_LOG
  rm  -rf  $MD5_LOG
  touch    $MD5_LOG

  track    &&
  archive  &&
  add_spell  $SPELL installed $VERSION  &&
  unlock_resources "libgrimoire" "install"  #This was set in prepare_install

) }


#---------------------------------------------------------------------
##=item find_pam_aware
##
## Returns a list of all installed spells that use Linux-PAM
##
## NOTE: this will become useless when triggers are introduced.
##
#---------------------------------------------------------------------
find_pam_aware()  { (

  cat  $SPELL_STATUS    |
  while  read  LINE;  do

     SPELL="`echo  $LINE  |  cut  -d  :  -f1`"
    STATUS="`echo  $LINE  |  cut  -d  :  -f3`"

    if  [  "$STATUS"  ==  "installed"  ]   ||
        [  "$STATUS"  ==  "held"       ];  then

      SPELL_DIRECTORY=`codex_find_spell_by_name  $SPELL`

      if    [  -d  "$SPELL_DIRECTORY/pam.d"  ]  &&
            [  "$SPELL"  !=  "Linux-PAM"              ]
      then  echo  $SPELL
      fi

    fi
  done

) }


#---------------------------------------------------------------------
##=item verify_source
##
## Given a list of source files, returns true if each file exists.
##
#---------------------------------------------------------------------
verify_source()  { (

  VERIFIED="true"

  for  SOURCE_FILE  in  $@;  do
    if  !  guess_filename  $SOURCE_CACHE/$1  >/dev/null
    then
      message  "${PROBLEM_COLOR}Missing ${FILE_COLOR}${1}${DEFAULT_COLOR}"
      message  "${PROBLEM_COLOR}Cast aborting.${DEFAULT_COLOR}"
      activity_log  "cast"  "$SPELL"  "$VERSION"  "failed"  \
                    "because it was missing source:  $1"
      VERIFIED=false
      break
    fi
  done

  $VERIFIED

) }


#---------------------------------------------------------------------
##=item sources <spell>
##
## Returns a list of each source file used by a spell.  Most have only
## one, but xfree86 for example splits the sources into three separate
## source files.
##
#---------------------------------------------------------------------
sources()  { (

  local i srcVar

  if  [  -z  "$SOURCE"  ];  then
    codex_set_current_spell_by_name  $1
  fi

  if  [  -n  "$SOURCE"    ];  then  echo  $SOURCE;    fi

  i=2
  ii=SOURCE$i
  while  [  -n "${!ii}"  ];  do
    echo ${!ii}
    i=$(($i+1))
    ii=SOURCE$i
  done

) }


#---------------------------------------------------------------------
##=item generate_keep_list
##
## Returns a list of files that should not be pruned.
##
#---------------------------------------------------------------------
generate_keep_list()  { (

  for  SPELL_DIRECTORY  in  `codex_get_all_spells`;  do
  (
    codex_set_current_spell  $SPELL_DIRECTORY
    sources  $SPELL
    echo     $SPELL-$VERSION-$BUILD.tar.bz2
  )
  done

  #Add the README in the cache to list of files to keep
  echo  README

) }


#---------------------------------------------------------------------
##=item prune
##
## Removes unnecessary files from the source cache and install cache.
##
#---------------------------------------------------------------------
prune()  { (

  debug  "libsorcery" "Running prune()"

  message "${MESSAGE_COLOR}Generating list of files to keep...${DEFAULT_COLOR}"
  KEEP="/tmp/prune.keep"
  generate_keep_list  >  $KEEP

  message "${MESSAGE_COLOR}Cleaning up source cache (${DEFAULT_COLOR}$SOURCE_CACHE${MESSAGE_COLOR})...${DEFAULT_COLOR}"
  ls  $SOURCE_CACHE  |
  while  read  FILE;  do
    local FILENAME=`guess_filename $SOURCE_CACHE/$FILE`
    if  [  -n  "$FILENAME"  ];  then
      grep  -q -m 1  "^$( basename $FILENAME )$"  $KEEP  ||
      rm  $FILENAME
    fi
  done

  message "${MESSAGE_COLOR}Cleaning up install cache (${DEFAULT_COLOR}$INSTALL_CACHE${MESSAGE_COLOR})...${DEFAULT_COLOR}"
  ls  $INSTALL_CACHE  |
  while  read  FILE;  do
    if  [  -f  $INSTALL_CACHE/$FILE  ];  then
      grep  -q  "^$FILE$"  $KEEP  ||
      rm  $INSTALL_CACHE/$FILE
    fi
  done

  rm  -f  $KEEP

) }


#---------------------------------------------------------------------
##=item invoke_build_dir
##
## Adds /var/lib/sorcery/build to the C<PATH>
##
#---------------------------------------------------------------------
invoke_build_dir()  {

  if    [  "$CCACHE"  ==  "on"  ]  &&  spell_installed  ccache  ||
        [  -n "$DISTCC_HOSTS"   ]  &&  spell_installed  distcc
  then  export  PATH="/var/lib/sorcery/build:$PATH"
  fi

}


#---------------------------------------------------------------------
##=item find_providers
##
## First argument is a category of spell.  Returns a list of spells
## that match that category.  For example,
## C<find_providers email-client> returns evolution,althea,mutt,etc.
##
#---------------------------------------------------------------------
find_providers()  {

  for  GRIMOIRENAME  in  `codex_get_all_grimoires`;  do
    # FIXME: Remove lowercase "provides" in a few days.
    for  PROVIDER  in  $(  find  $GRIMOIRENAME  -follow -name provides -or -name  PROVIDES);  do
      if    grep  -q  $1  $PROVIDER
      then  basename  $( dirname  $PROVIDER  )
      fi
    done
  done

}


#---------------------------------------------------------------------
##=item verify_sources
##
## Returns false if one or more source files for the current spell
## are missing.
##
#---------------------------------------------------------------------
verify_sources()  {
  verify_source  "`sources  $SPELL`";
}



#---------------------------------------------------------------------
##=item filename_indicates_compression <filename>
##
## Returns true if the name of the file indicates that it should be
## a compressed file.  In other words, this function returns true if
## the filename ends in .gz, .tgz, .bz2, .zip, .rpm, or .Z.
##
#---------------------------------------------------------------------
filename_indicates_compression()  {
  local FILENAME=`echo "file$1" | sed 's/^.*\.gz$//'  \
                                | sed 's/^.*\.tgz$//' \
                                | sed 's/^.*\.bz2$//' \
                                | sed 's/^.*\.zip$//' \
                                | sed 's/^.*\.Z$//'   \
                                | sed 's/^.*\.rpm$//' \
                                | sed 's/^.*\.bz2$//'`
  [  -z  "$FILENAME"  ]
}


#---------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
