#!/bin/bash



#---------------------------------------------------------------------
##
## Adds a dependency to the DEPENDS_STATUS file.  Returns 1 is the 
## 3rd or 4th fields are not valid.
##
## @param  Name of the "parent" spell
## @param  Name of the spell the parent spell depends on
## @param  "on" or "off" depending on whether the user installed the dependency
## @param  Type of dependency (required or optional)
## @param  option to pass to C<configure> if the dependency is installed
## @param  option to pass to C<configure> if the dependency is not installed
##
## @Example add_depends kdelibs alsa-driver on optional --with-alsa --without-alsa
##
#---------------------------------------------------------------------
function add_depends()
{ # $1=spell, $2=depends, $3=on/off, $4=optional/required, $5=on arg, $6=off arg
	debug "libstate" "add_depends() - $*"
	#Locking the file at the start to avoid multiple casts adding the same thing
	#lock_file $DEPENDS_STATUS  Locking done in run_depends now

	#already here for some reason
	search_depends_status_exact "$@" >/dev/null  && return 0
	
	#remove stale depends info
	search_depends_status "$@" >/dev/null && remove_depends_status "$@"
	
	#ensure the info is valid (perhaps add check that spells exist?)
	if ( [[ $3 != on ]]       && [[ $3 != off ]]       )   ||
           ( [[ $4 != required ]] && [[ $4 != optional ]]  )
	then
	  # unlock_file $DEPENDS_STATUS  Locking done in run_depends now
	  return 1 
	fi
	
	echo "$1:$2:$3:$4:$5:$6" >> $DEPENDS_STATUS
	#unlock_file $DEPENDS_STATUS  Locking done in run_depends now
	
	return 0	

}


#---------------------------------------------------------------------
##
## In case you want to search in all the fields of the 
## DEPENDS_STATUS
##
## Arguments can be regexp
##
## Prints out the matching line(s)
## @Stdout the matching line(s)
## @param spell
## @param depends
## @param on/off
## @param optional/required
## @param on arg
## @param off arg
##
#---------------------------------------------------------------------
function search_depends_status_exact()
{ # $1=spell, $2=depends, $3=on/off, $4=optional/required, $5=on arg, $6=off arg

	local a1 a2 a3 a4 a5 a6
	a1=`esc_str "$1"` ; a2=`esc_str "$2"` ; a3=`esc_str "$3"` ; a4=`esc_str "$4"`; a5=`esc_str "$5"`; a6=`esc_str "$6"`
debug "DB" "search_depends_status_exact: [$a1:$a2:$a3:$a4:$a5:$a6]"
	grep "^$a1:$a2:$a3:$a4:$a5:$a6$" $DEPENDS_STATUS

}


#---------------------------------------------------------------------
## @param spell
## @param depends (optional)
## @Stdout mathing lines
## In case you want to search by spell or dependency in 
## DEPENDS_STATUS
##
## Arguments can be regexp
##
## Prints out the matching line(s)
##
#---------------------------------------------------------------------
function search_depends_status()
{ # $1=spell, $2=(opt)depends

  [ $# -eq 1 ] && grep "^`esc_str "$1"`:" $DEPENDS_STATUS
  [ $# -gt 1 ] && grep "^`esc_str "$1"`:`esc_str "$2"`:" $DEPENDS_STATUS

}



#---------------------------------------------------------------------
## 
## @param spell
## @param dependency spell
## @Stdout list of options
##
## Returns a list of options for ./configure from DEPENDS_STATUS
## If the second argument is given, returns options for the
## matching pair of spell:dependency
## Primarily aimed at generating $OPTS contents
##
## Prints out one line of output
#---------------------------------------------------------------------
function get_depends_options()
{ # $1=spell [$2]=dependency spell
  [ -z "$1" ] && {
    message "${PROBLEM_COLOR}${1:-<null>} is not a spell name${DEFAULT_COLOR}"
    return
  }

  local START="$(esc_str $1):"
  [ -n "$2" ] && START="${START}$(esc_str $2):"
  debug "libstate" "get_depends_options() - START=$START"
  awk -F ':' "/^$START/ { if (\$3 == \"on\") OPTS = OPTS \" \" \$5; else OPTS = OPTS \" \" \$6; } END { print OPTS; }" $DEPENDS_STATUS
}


#---------------------------------------------------------------------
##
## Arguments can be regexp, and all but the spell are optional
##
## @param spell
## @param depends
## @param on/off
## @param optional/required
## @param on arg
## @param off arg
##
#---------------------------------------------------------------------
function remove_depends_status()
{ # $1=spell, $2=(OPT)depends, $3=(OPT)on/off, $4=(OPT)optional/required, $5=(OPT)on arg, $6=(OPT)off arg

	local a1 a2 a3 a4 a5 a6
	a1=`esc_str $1` ; a2=`esc_str $2` ; a3=`esc_str $3` ; a4=`esc_str $4`; a5=`esc_str $5`; a6=`esc_str $6`
	
	a2=${a2:-.*}
	a3=${a3:-.*}
	a4=${a4:-.*}
	a5=${a5:-.*}
	a6=${a6:-.*}

	[[ "$a5" == "[none]" ]] && a5="\\[none\\]"

	sedit "/^$a1:$a2:$a3:$a4:$a5:$a6$/D" $DEPENDS_STATUS

}


#---------------------------------------------------------------------
##
## Adds an entry to the SPELL_STATUS file
##
## Arguments may either be SPELL, ACTION, VERSIONS, or just
## ACTION if there exists SPELL and VERSIONS variables already
## set.
## @param spell OR action
## @param (if spell) action
## @param (if spell) version
##
#---------------------------------------------------------------------
function add_spell_status()
{ #$1=spell, $2=action, $3=version, OR $1=action.

  local spell action version date
  if [ $# -eq 1 ] ; then
    spell="$SPELL"
    action="$1"
    version="$VERSION"
  else
    spell=$1
    action=$2
    version=$3
  fi
  [[ $spell ]] || [[ $action ]] || [[ $version ]] || return 1
  date=`date +%Y%m%d`
  tSPELL_STATUS=`lock_start_transaction $SPELL_STATUS`
  echo "$spell:$date:$action:$version" >> $tSPELL_STATUS
  lock_commit_transaction $SPELL_STATUS

}

#---------------------------------------------------------------------
## @param spell name
##
## Given a spell, status (installed, held, etc), and version, add_spell
## adds the spell to the /var/state/sorcery/packages file
##
#---------------------------------------------------------------------
function add_spell()  {

  remove_spell  $1
  add_spell_status $1 $2 $3

}


#---------------------------------------------------------------------
##
## @param spell
## @param version (optional)
## @Stdout mathing lines
## Searches the SPELL_STATUS file for a spell and optionaly
## a version.
##
## Prints out the matching entries
## Returns the result of the search
##
#---------------------------------------------------------------------
function query_spell_status()
{ #$1=spell, $2=(OPT)version

	local version spell
	version=`esc_str ${2:-".*"}`
	spell=`esc_str $1`

	tac $SPELL_STATUS | grep -m 1 "^$spell:.*:.*:$version$" | \
		cut -d ":" -f 3
		
	return $?

}

#---------------------------------------------------------------------
## @param spell name
## @Stdout status
## Returns the given spell's status (installed, held, exiled, etc.)
##
#---------------------------------------------------------------------
function get_status()  {

  if    query_spell_status $1    >/dev/null
  then  query_spell_status $1    |  cut  -d : -f3
  else  query_spell_status "$1-" |  cut  -d : -f3
  fi

}

#---------------------------------------------------------------------
## @Type API
## @param spell name
##
## @return 0 if the given spell's status is "installed"
#---------------------------------------------------------------------
function real_spell_installed() {
  [  "$(  get_status  $1  )"  ==  "installed"  ];
}


#---------------------------------------------------------------------
## @param spell name
##
## @return 0 if the given spell's status is "held"
##
#---------------------------------------------------------------------
function spell_held()      {
  [  "$(  get_status  $1  )"  ==  "held"       ];
}


#---------------------------------------------------------------------
## @param spell name
##
##  @return 0 if the given spell's status is "exiled"
##
#---------------------------------------------------------------------
function spell_exiled()    {
  [  "$(  get_status  $1  )"  ==  "exiled"     ];
}


#---------------------------------------------------------------------
## @param spell to remove status of
## Removes all specified offending entries in SPELL_STATUS
##
#---------------------------------------------------------------------
function remove_spell_status()
{ #$1=spell to remove status of

  tSPELL_STATUS=`lock_start_transaction $SPELL_STATUS`
  grep  -v  "^$1:" $SPELL_STATUS  >  $tSPELL_STATUS
  lock_commit_transaction $SPELL_STATUS
    
}

#---------------------------------------------------------------------
## @param spell name
##
## Removes the given spell from the /var/state/sorcery/packages file.
## if C<EXILE> is set, the spell is changed to "exiled" in the file.
##
#---------------------------------------------------------------------
function remove_spell()  {

  debug  "libsorcery" "Running remove_spell() on $1"

  remove_spell_status $1

  if  [  -n  "$EXILE"  ];  then
    add_spell_status $1 "." "exiled" "0.0"
    remove_depends_status ".*" $1
  fi

}


#---------------------------------------------------------------------
## @Stdout All spell stati
## Just here to round out the SPELL_STATUS functions so that
## SPELL_STATUS doesn't have to mentioned in libsorcery
##
#---------------------------------------------------------------------
function all_spell_status()
{

  cat $SPELL_STATUS

}


#---------------------------------------------------------------------
## @param spells
## sets <spells>'s status to held
##
#---------------------------------------------------------------------
function set_held () {
    local t_status=$(lock_start_transaction $SPELL_STATUS)
    cp $SPELL_STATUS $t_status
    for to_hold in $@; do
        sedit 's/\(^'$(esc_str $to_hold)':[^:]*:\)installed/\1held/' $t_status
    done
    lock_commit_transaction $SPELL_STATUS
}


#---------------------------------------------------------------------
## @param spells
## sets <spells>'s status to installed
##
#---------------------------------------------------------------------
function set_unheld () {
    local t_status=$(lock_start_transaction $SPELL_STATUS)
    cp $SPELL_STATUS $t_status
    for to_hold in $@; do
        sedit 's/\(^'$(esc_str $to_hold)':[^:]*:\)held/\1installed/' $t_status
    done
    lock_commit_transaction $SPELL_STATUS
}


#---------------------------------------------------------------------
## @param status
## @Stdout spells
## returns all spells that are in that status
##
#---------------------------------------------------------------------
function get_all_spells_with_status () {
    lock_file $SPELL_STATUS
    gawk -F: 'BEGIN { status="'$1'" }
              ($3 == status) { print $1 }' $SPELL_STATUS
    unlock_file $SPELL_STATUS
}


#---------------------------------------------------------------------
## @Stdout all held spells
## returns all held spells
##
#---------------------------------------------------------------------
function get_held () {
    get_all_spells_with_status "held"
}


#---------------------------------------------------------------------
## @param variable
## @param value
## @param command (optional)
##
## Modifies (or adds) an entry in the local/config.
## If "command" is the third argument, a space will separate the 
## variable and value rather than the equals sign.
##
#---------------------------------------------------------------------
function modify_local_config() {
  debug "libstate" "modify_local_config() - $*"
    modify_config $LOCAL_CONFIG $@
}


#---------------------------------------------------------------------
## @param Filename
## @param variable
## @param value
## @param command (optional)
##
## Modifies (or adds) an entry in the local/config.
## If "command" is the third argument, a space will separate the 
## variable and value rather than the equals sign.
##
#---------------------------------------------------------------------
function modify_config()  {

  debug "libstate" "modify_config() - $*"
  local FILE=$1
  shift;
  
  if ! [[ $1 ]]; then
    debug "libstate" "modify_config() - Warning: No name given for config option."
    return 1
  fi
  
  local TEMP separator EQUALS_COL VARIABLE
  
  # what to use as separator?
  if [[ $3 == command ]] 
  then separator=" " 
  else separator="=" ; fi
  
  # remove previous reference
  tFILE=`lock_start_transaction $FILE`
  grep  -v  "^[[:blank:]]*${1}${separator}" $FILE >  $tFILE

  # justifying...
  EQUALS_COL=$((20-${#1}))
  [ $EQUALS_COL -lt 0  ] && EQUALS_COL=0
  TEMP=""
  for (( ; EQUALS_COL>0 ; EQUALS_COL-- )) ; do
    TEMP="$TEMP "
  done
  
	# Removing VARIABLE to be set from list of args.
	VARIABLE=$1
	shift;

  debug "libstate" "modify_config() - entering new value $VARIABLE $seperator $@ into $tFILE"
  # put new value and justification in
  echo  "${TEMP}${VARIABLE}${separator}\"$@\""  >>  $tFILE

  lock_commit_transaction $FILE
    
}

#---------------------------------------------------------------------
## @param grimoire-name
##
## returns 0 if the grimoire is set local, 0 otherwise.
#---------------------------------------------------------------------
function codex_is_local () {(
    g_name=$1

    grimoire=$(codex_find_grimoire_by_name $g_name)
    if ! [[ $grimoire ]]; then
        return 1
    fi

    . "$grimoire/GRIMOIRE"

    [[ $CODEX_IS_LOCAL == "yes" ]]
)}


#---------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------
